$BASICTYPE "U"
      SUBROUTINE DOWNLOAD.LOAD
*
* INFO/BASIC SUBROUTINE
* 11/27/90
* DWS
* TITLE ----- DOWNLOAD.LOAD
*
*
* PURPOSE: LOAD DATA RECORDS/VALUES/ETC. PRIOR TO PROCESSING THE RECORD
*
*
*************************************************************************
* Stamped: p1 rotmand, /usr/local/download, user #1043, 17 Aug 04, 07:41AM.
* Version 7.11
*
*
*
*
*
*
*

      $INCLUDE I_WHICH_OP_SYS
      $INCLUDE I_DOWNLOAD_MAX_COMMON
      $INCLUDE I_DOWNLOAD_MAIN_COMMON
      $INCLUDE I_DOWNLOAD_DATA_COMMON
      $INCLUDE I_DOWNLOAD_WHEN_COMMON
      $INCLUDE I_DOWNLOAD_SUBR_COMMON

      DEBUG1OR2
      CRT 'INSIDE DOWNLOAD.LOAD'
      END

*
*
* MAIN CONTROL
*
      GOSUB SET.UP
      SAVE.RECORD = @RECORD
      SAVE.ID = @ID
      FOR FILE.CTR=1 TO DLMAIN.NUM.FILES
         GOSUB LOAD.FILE.DICT.VALUES
      NEXT FILE.CTR
      GOSUB LOAD.SUBR.VALUES
      GOSUB CHECK.WHEN.VALUES
      RETURN


*
*
* SET UP
*
SET.UP: 
      MAT DL.DATA.NEW.DATA.ITEMS = ''
      MAT NEW.SUBR.RET.VALUES = ''
      RETURN


*
*
* LOAD DATA VALUES
*   ALL SECONDARY FILES ARE BASED ON KEYS FROM THE PRIMARY FILE.
*   BY EVALUATING FIELDS IN FILE ORDER, THE SUBSEQUENT FILES
*   WILL ALREADY HAVE THE KEY VALUES CALCULATED
*
*
LOAD.FILE.DICT.VALUES: 
      IF FILE.CTR = 1 THEN
         NUM.RECORDS = 1
      END ELSE
         KEY.DICT.CTR = DLMAIN.INFO.FILE.KEY.DICT.CTR(FILE.CTR)
         DATA.FIELD = DL.DATA.NEW.DATA.ITEMS(KEY.DICT.CTR)
         FILE.KEY = DATA.FIELD
         IF DLMAIN.INFO.FILE.KEY.IS.MULTIVALUE(FILE.CTR) THEN
            IF SELECT.LIST.IS.BY.EXP THEN
               FILE.KEY = FILE.KEY<1,DLMAIN.SELECT.LIST.VALUE.CTR,DLMAIN.SELECT.LIST.SUBVALUE.CTR>
            END
            NUM.RECORDS = COUNT(FILE.KEY,@VM) + (FILE.KEY # '')
         END ELSE
            FILE.KEY = FILE.KEY<1,1,1>
            NUM.RECORDS = 1
         END
      END
      FOR RECORD.CTR=1 TO NUM.RECORDS
         GOSUB LOAD.RECORD.DICT.VALUES
      NEXT RECORD.CTR
      RETURN




LOAD.RECORD.DICT.VALUES: 
      FOR DICT.FIELD.CTR=1 TO DL.DATA.NUM.DICT.RECS
         IF FILE.CTR = 1 THEN
            @ID = SAVE.ID
            @RECORD = SAVE.RECORD
         END ELSE
            @ID = FILE.KEY<1,RECORD.CTR>
            READ @RECORD FROM DLMAIN.F.INFO.FILE(FILE.CTR), @ID ELSE
               @RECORD = ''
            END
         END
         IF DL.DATA.DICT.REC.FILE.NUM(DICT.FIELD.CTR) = FILE.CTR THEN
            GOSUB LOAD.DICT.VALUE
            IF DLMAIN.INFO.FILE.KEY.IS.MULTIVALUE(FILE.CTR) THEN
               CONVERT @VM:@SM TO @SM:@TM IN VALUE
               DL.DATA.NEW.DATA.ITEMS(DICT.FIELD.CTR)<1,RECORD.CTR> = VALUE
            END ELSE
               DL.DATA.NEW.DATA.ITEMS(DICT.FIELD.CTR) = VALUE
            END
         END
      NEXT DICT.FIELD.CTR
      RETURN


LOAD.DICT.VALUE: 
      DICT.REC = DL.DATA.DICT.RECS(DICT.FIELD.CTR)
      FIELD.LOC = DICT.REC<2>
      FIELD.TYPE = DICT.REC<1>[1,1]
      FIELD.TYPE = OCONV(FIELD.TYPE,'MCU')
      IF FIELD.TYPE = 'V' THEN
         FIELD.TYPE = 'I'
      END
      BEGIN CASE
         CASE FIELD.TYPE = 'I'
            VALUE = ITYPE(DICT.REC)
         CASE FIELD.TYPE = 'D'
            IF FIELD.LOC = 0 THEN
               VALUE = @ID
            END ELSE
               VALUE = @RECORD<FIELD.LOC>
            END
         CASE 1
            VALUE = ''
      END CASE
      RETURN


*
*
* LOAD SUBR VALUES
*
LOAD.SUBR.VALUES: 
      FOR USE.SUBR.CTR=1 TO NUM.USE.SUBRS
         WHICH.SUBR.CTR = USE.SUBR.CTR.LIST<USE.SUBR.CTR>
         SUBR.NAME = SUBR.NAMES(WHICH.SUBR.CTR)
         SUBR.NUM.ARGS = SUBR.NUM.ARGS.LIST(WHICH.SUBR.CTR)
         GOSUB LOAD.SUBR.ARG.VALUES
         RET.VALUE = ''
         BEGIN CASE
            CASE SUBR.NUM.ARGS = 1
               CALL @SUBR.NAME(RET.VALUE)
            CASE SUBR.NUM.ARGS = 2
               CALL @SUBR.NAME(RET.VALUE,SUBR.ARG.VALUES(2))
            CASE SUBR.NUM.ARGS = 3
               CALL @SUBR.NAME(RET.VALUE,SUBR.ARG.VALUES(2),SUBR.ARG.VALUES(3))
            CASE SUBR.NUM.ARGS = 4
               CALL @SUBR.NAME(RET.VALUE,SUBR.ARG.VALUES(2),SUBR.ARG.VALUES(3),SUBR.ARG.VALUES(4))
            CASE SUBR.NUM.ARGS = 5
               CALL @SUBR.NAME(RET.VALUE,SUBR.ARG.VALUES(2),SUBR.ARG.VALUES(3),SUBR.ARG.VALUES(4),SUBR.ARG.VALUES(5))
            CASE SUBR.NUM.ARGS = 6
               CALL @SUBR.NAME(RET.VALUE,SUBR.ARG.VALUES(2),SUBR.ARG.VALUES(3),SUBR.ARG.VALUES(4),SUBR.ARG.VALUES(5),SUBR.ARG.VALUES(6))
            CASE SUBR.NUM.ARGS = 7
               CALL @SUBR.NAME(RET.VALUE,SUBR.ARG.VALUES(2),SUBR.ARG.VALUES(3),SUBR.ARG.VALUES(4),SUBR.ARG.VALUES(5),SUBR.ARG.VALUES(6),SUBR.ARG.VALUES(7))
            CASE SUBR.NUM.ARGS = 8
               CALL @SUBR.NAME(RET.VALUE,SUBR.ARG.VALUES(2),SUBR.ARG.VALUES(3),SUBR.ARG.VALUES(4),SUBR.ARG.VALUES(5),SUBR.ARG.VALUES(6),SUBR.ARG.VALUES(7),SUBR.ARG.VALUES(8))
            CASE SUBR.NUM.ARGS = 9
               CALL @SUBR.NAME(RET.VALUE,SUBR.ARG.VALUES(2),SUBR.ARG.VALUES(3),SUBR.ARG.VALUES(4),SUBR.ARG.VALUES(5),SUBR.ARG.VALUES(6),SUBR.ARG.VALUES(7),SUBR.ARG.VALUES(8),SUBR.ARG.VALUES(9))
            CASE SUBR.NUM.ARGS = 10
               CALL @SUBR.NAME(RET.VALUE,SUBR.ARG.VALUES(2),SUBR.ARG.VALUES(3),SUBR.ARG.VALUES(4),SUBR.ARG.VALUES(5),SUBR.ARG.VALUES(6),SUBR.ARG.VALUES(7),SUBR.ARG.VALUES(8),SUBR.ARG.VALUES(9),SUBR.ARG.VALUES(10))
         END CASE
*
* THE SUBR.NAME HAS NOW BEEN "RESOLVED" AND STORING IT IN THE
* ARRAY WILL SPEED UP FURTHER CALLS TO THE ROUTINE
*
         SUBR.NAMES(WHICH.SUBR.CTR) = SUBR.NAME
         NEW.SUBR.RET.VALUES(USE.SUBR.CTR) = RET.VALUE
      NEXT USE.SUBR.CTR
      RETURN


*
*
* LOAD ARG.VALUES
*
LOAD.SUBR.ARG.VALUES: 
      MAT SUBR.ARG.VALUES = ''
      FOR ARG.CTR=1 TO SUBR.NUM.ARGS
         IF USE.SUBR.ARG.TYPE.LIST<USE.SUBR.CTR,ARG.CTR> = '' THEN
            SUBR.ARG.VALUES(ARG.CTR) = USE.SUBR.ARG.VALUE.LIST<USE.SUBR.CTR,ARG.CTR>
         END ELSE
            WHICH.DICT.REC.CTR = USE.SUBR.ARG.DICT.CTR.LIST<USE.SUBR.CTR,ARG.CTR>
            SUBR.ARG.VALUES(ARG.CTR) = DL.DATA.NEW.DATA.ITEMS(WHICH.DICT.REC.CTR)
         END
      NEXT ARG.CTR
      RETURN



*
*
* CHECK WHEN VALUES
*
CHECK.WHEN.VALUES: 
      IF WHEN.ASSOC.NAME # '' THEN
         CONTROL.DATA.ITEM = DL.DATA.NEW.DATA.ITEMS(WHEN.ASSOC.CONTROL.DICT.CTR)
         NUM.ASSOC.CONTROL.VALUES = COUNT(CONTROL.DATA.ITEM,@VM) + 1
      END ELSE
         NUM.ASSOC.CONTROL.VALUES = 0
      END
      WHEN.RESULT.LIST = ''
      IF NUM.WHEN.FIELDS = 0 THEN
         RETURN
      END
      FOR VALUE.CTR=1 TO NUM.ASSOC.CONTROL.VALUES
         CONTROL.VALUE = CONTROL.DATA.ITEM<1,VALUE.CTR>
         NUM.ASSOC.CONTROL.SUBVALUES = COUNT(CONTROL.VALUE,@SM) + 1
         FOR SUBVALUE.CTR=1 TO NUM.ASSOC.CONTROL.SUBVALUES
            WHEN.RESULT = TRUE
            FOR WHEN.FIELD.CTR=1 TO NUM.WHEN.FIELDS UNTIL NOT(WHEN.RESULT)
               WHEN.DICT.CTR = WHEN.DICT.CTR.LIST<WHEN.FIELD.CTR>
               WHEN.DATA.VALUE = DL.DATA.NEW.DATA.ITEMS(WHEN.DICT.CTR)<1,VALUE.CTR,SUBVALUE.CTR>
               WHEN.OPERATOR = WHEN.OPERATOR.LIST<WHEN.FIELD.CTR>
               WHEN.CHECK.VALUE.IS.FIELD = WHEN.CHECK.VALUE.IS.FIELD.LIST<WHEN.FIELD.CTR>
               IF WHEN.CHECK.VALUE.IS.FIELD THEN
                  WHEN.CHECK.VALUE.DICT.CTR = WHEN.CHECK.VALUE.LIST<WHEN.FIELD.CTR>
                  IF DL.DATA.DICT.PART.OF.ASSOC.LIST(WHEN.CHECK.VALUE.DICT.CTR) THEN
                     WHEN.CHECK.VALUE = DL.DATA.NEW.DATA.ITEMS(WHEN.CHECK.VALUE.DICT.CTR)<1,VALUE.CTR,SUBVALUE.CTR>
                  END ELSE
                     WHEN.CHECK.VALUE = DL.DATA.NEW.DATA.ITEMS(WHEN.CHECK.VALUE.DICT.CTR)
                  END
               END ELSE
                  WHEN.CHECK.VALUE = WHEN.CHECK.VALUE.LIST<WHEN.FIELD.CTR>
               END
               CONVERT @VM:@SM TO @FM:@FM IN WHEN.CHECK.VALUE
               BEGIN CASE
                  CASE WHEN.OPERATOR = 'EQ'
                     GOSUB CHECK.WHEN.EQ
                  CASE WHEN.OPERATOR = 'NE'
                     GOSUB CHECK.WHEN.NE
                  CASE WHEN.OPERATOR = 'GE'
                     GOSUB CHECK.WHEN.GE
                  CASE WHEN.OPERATOR = 'GT'
                     GOSUB CHECK.WHEN.GT
                  CASE WHEN.OPERATOR = 'LE'
                     GOSUB CHECK.WHEN.LE
                  CASE WHEN.OPERATOR = 'LT'
                     GOSUB CHECK.WHEN.LT
                  CASE WHEN.OPERATOR = 'LIKE'
                     GOSUB CHECK.WHEN.LIKE
                  CASE WHEN.OPERATOR = 'UNLIKE'
                     GOSUB CHECK.WHEN.UNLIKE
               END CASE
            NEXT WHEN.FIELD.CTR
            WHEN.RESULT.LIST<VALUE.CTR,SUBVALUE.CTR> = WHEN.RESULT
         NEXT SUBVALUE.CTR
      NEXT VALUE.CTR
      RETURN
*
* CHECK WHEN CLAUSE VALUE FOR OPERATOR "EQ"
*
CHECK.WHEN.EQ: 
      LOCATE WHEN.DATA.VALUE IN WHEN.CHECK.VALUE<1> SETTING TEMP.POS ELSE
         WHEN.RESULT = FALSE
      END
      RETURN
*
* CHECK WHEN CLAUSE VALUE FOR OPERATOR "NE"
*
CHECK.WHEN.NE: 
      LOCATE WHEN.DATA.VALUE IN WHEN.CHECK.VALUE<1> SETTING TEMP.POS THEN
         WHEN.RESULT = FALSE
      END
      RETURN
*
* CHECK WHEN CLAUSE VALUE FOR OPERATOR "GT"
*
CHECK.WHEN.GT: 
      WHEN.CHECK.VALUE = WHEN.CHECK.VALUE
      FOUND.VALUE.GT = FALSE
      LOOP
         REMOVE CHECK.VALUE FROM WHEN.CHECK.VALUE SETTING DELIM.CHECK.VALUE
         IF WHEN.DATA.VALUE > CHECK.VALUE THEN
            FOUND.VALUE.GT = TRUE
         END
      UNTIL DELIM.CHECK.VALUE = 0 OR FOUND.VALUE.GT
      REPEAT
      IF NOT(FOUND.VALUE.GT) THEN
         WHEN.RESULT = FALSE
      END
      RETURN
*
* CHECK WHEN CLAUSE VALUE FOR OPERATOR "GE"
*
CHECK.WHEN.GE: 
      WHEN.CHECK.VALUE = WHEN.CHECK.VALUE
      FOUND.VALUE.GE = FALSE
      LOOP
         REMOVE CHECK.VALUE FROM WHEN.CHECK.VALUE SETTING DELIM.CHECK.VALUE
         IF WHEN.DATA.VALUE >= CHECK.VALUE THEN
            FOUND.VALUE.GE = TRUE
         END
      UNTIL DELIM.CHECK.VALUE = 0 OR FOUND.VALUE.GE
      REPEAT
      IF NOT(FOUND.VALUE.GE) THEN
         WHEN.RESULT = FALSE
      END
      RETURN
*
* CHECK WHEN CLAUSE VALUE FOR OPERATOR "LT"
*
CHECK.WHEN.LT: 
      WHEN.CHECK.VALUE = WHEN.CHECK.VALUE
      FOUND.VALUE.LT = FALSE
      LOOP
         REMOVE CHECK.VALUE FROM WHEN.CHECK.VALUE SETTING DELIM.CHECK.VALUE
         IF WHEN.DATA.VALUE < CHECK.VALUE THEN
            FOUND.VALUE.LT = TRUE
         END
      UNTIL DELIM.CHECK.VALUE = 0 OR FOUND.VALUE.LT
      REPEAT
      IF NOT(FOUND.VALUE.LT) THEN
         WHEN.RESULT = FALSE
      END
      RETURN
*
* CHECK WHEN CLAUSE VALUE FOR OPERATOR "LE"
*
CHECK.WHEN.LE: 
      WHEN.CHECK.VALUE = WHEN.CHECK.VALUE
      FOUND.VALUE.LE = FALSE
      LOOP
         REMOVE CHECK.VALUE FROM WHEN.CHECK.VALUE SETTING DELIM.CHECK.VALUE
         IF WHEN.DATA.VALUE <= CHECK.VALUE THEN
            FOUND.VALUE.LE = TRUE
         END
      UNTIL DELIM.CHECK.VALUE = 0 OR FOUND.VALUE.LE
      REPEAT
      IF NOT(FOUND.VALUE.LE) THEN
         WHEN.RESULT = FALSE
      END
      RETURN
*
* CHECK WHEN CLAUSE VALUE FOR OPERATOR "LIKE"
*
CHECK.WHEN.LIKE: 
      WHEN.CHECK.VALUE = WHEN.CHECK.VALUE
      FOUND.VALUE.LIKE = FALSE
      LOOP
         REMOVE CHECK.VALUE FROM WHEN.CHECK.VALUE SETTING DELIM.CHECK.VALUE
         IF WHEN.DATA.VALUE MATCHES CHECK.VALUE THEN
            FOUND.VALUE.LIKE = TRUE
         END
      UNTIL DELIM.CHECK.VALUE = 0 OR FOUND.VALUE.LIKE
      REPEAT
      IF NOT(FOUND.VALUE.LIKE) THEN
         WHEN.RESULT = FALSE
      END
      RETURN
*
* CHECK WHEN CLAUSE VALUE FOR OPERATOR "UNLIKE"
*
CHECK.WHEN.UNLIKE: 
      WHEN.CHECK.VALUE = WHEN.CHECK.VALUE
      FOUND.VALUE.UNLIKE = FALSE
      LOOP
         REMOVE CHECK.VALUE FROM WHEN.CHECK.VALUE SETTING DELIM.CHECK.VALUE
         IF NOT(WHEN.DATA.VALUE MATCHES CHECK.VALUE) THEN
            FOUND.VALUE.UNLIKE = TRUE
         END
      UNTIL DELIM.CHECK.VALUE = 0 OR FOUND.VALUE.UNLIKE
      REPEAT
      IF NOT(FOUND.VALUE.UNLIKE) THEN
         WHEN.RESULT = FALSE
      END
      RETURN






   END
