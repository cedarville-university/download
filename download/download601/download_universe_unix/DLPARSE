      SUBROUTINE DOWNLOAD.PARSE
*
* INFO/BASIC SUBROUTINE
* 11/27/90
* DWS
* TITLE ----- DOWNLOAD.PARSE
*
*
* PURPOSE: PARSE COMMAND LINE/INPUT LINES INTO APPROPRIATE VARIABLES/VALUES
*
*
*************************************************************************
* Stamped: p7 rotmand, /user/local/collive, user #13273, 29 Jan 03, 04:46PM.
* Version 6.01
*
*
*
*
*
*
*

      $INCLUDE IDLMAX
      $INCLUDE IDLMAIN
      $INCLUDE IDLDATA
      $INCLUDE IDLDBMS
      $INCLUDE IDLOPSYS
      $INCLUDE IWHICHDBMS
      $INCLUDE IWHICHOPSYS
      $INCLUDE IDLOUTREC
      $INCLUDE IDLWHEN
      $INCLUDE IDLSUBR
      $INCLUDE IDBF

      DIM F.DICT.FILE(DLMAX.FILES)
      DIM ALIAS.SET(DLMAX.FILES)

      GOSUB SET.UP
      IF NOT(DLMAIN.FATAL.ERROR) THEN
         GOSUB PRE.ITEMS.PROCESSING
      END
      IF NOT(DLMAIN.FATAL.ERROR) THEN
         GOSUB PROCESS.REGULAR.ITEMS
      END
      IF NOT(DLMAIN.FATAL.ERROR) THEN
         GOSUB FINISH.ITEMS
      END
      IF NOT(DLMAIN.FATAL.ERROR) THEN
         GOSUB POST.ITEMS.PROCESSING
      END
      RETURN


*******************************************************************************
**
**   SET UP ROUTINES
**
*******************************************************************************
SET.UP: 
      GOSUB SET.UP.MISC
      GOSUB SET.UP.OPTION.LISTS
      GOSUB SET.UP.KEYWORD.VALUES
      GOSUB SET.UP.AT.VARIABLE.LIST
      GOSUB DBMS.SET.UP
      GOSUB OP.SYS.SET.UP
      RETURN

SET.UP.MISC: 
      PRIMARY.DICT.OPENED = FALSE
      DOWNLOAD.PROMPT = 'DL> '
      OPEN '', 'VOC' TO DLMAIN.F.VOC ELSE
         DLMAIN.ERRMSG<-1> = 'Can not open "VOC"'
         DLMAIN.FATAL.ERROR = TRUE
      END
      PROMPT ''
      CUR.OUT.REC = DETAIL.OUT.REC
      MAT OUT.DEFAULT.VALUE.LIST = ''
      SECONDARY.FIELD.FLAG = '->'
      LEN.SECONDARY.FIELD.FLAG = LEN(SECONDARY.FIELD.FLAG)
      LOOKUP.FIELD.NAME = TRUE
      LOOKUP.FILE.NAME = FALSE
      HEADING.OUT.REC.USE.FIELD.NAMES = FALSE
      HEADING.OUT.REC.USE.FIELD.LABELS = FALSE
      XML.UPCASE = FALSE
      XML.ALLOW.PERIODS = FALSE
      RETURN


SET.UP.OPTION.LISTS: 
      FORMAT.TYPE.LIST = ''
      FORMAT.TYPE.LIST<1,1> = 'FIXED'
      FORMAT.TYPE.LIST<2,1> = 'FIXED'
      FORMAT.TYPE.LIST<1,2> = 'QUOTE'
      FORMAT.TYPE.LIST<2,2> = 'QUOTE'
      FORMAT.TYPE.LIST<1,3> = 'WORDPERFECT.5.0'
      FORMAT.TYPE.LIST<2,3> = 'WP50'
      FORMAT.TYPE.LIST<1,4> = 'WORDPERFECT50'
      FORMAT.TYPE.LIST<2,4> = 'WP50'
      FORMAT.TYPE.LIST<1,5> = 'WP50'
      FORMAT.TYPE.LIST<2,5> = 'WP50'
      FORMAT.TYPE.LIST<1,6> = 'WORDPERFECT.5.1'
      FORMAT.TYPE.LIST<2,6> = 'WP51'
      FORMAT.TYPE.LIST<1,7> = 'WORDPERFECT51'
      FORMAT.TYPE.LIST<2,7> = 'WP51'
      FORMAT.TYPE.LIST<1,8> = 'WP51'
      FORMAT.TYPE.LIST<2,8> = 'WP51'
      FORMAT.TYPE.LIST<1,9> = 'WORDPERFECT'
      FORMAT.TYPE.LIST<2,9> = 'WP50'
      FORMAT.TYPE.LIST<1,10> = 'COMMA'
      FORMAT.TYPE.LIST<2,10> = 'COMMA'
      FORMAT.TYPE.LIST<1,11> = 'DIF'
      FORMAT.TYPE.LIST<2,11> = 'DIF'
      FORMAT.TYPE.LIST<1,12> = 'DBF'
      FORMAT.TYPE.LIST<2,12> = 'DBF'
      FORMAT.TYPE.LIST<1,13> = 'DBASE'
      FORMAT.TYPE.LIST<2,13> = 'DBF'
      FORMAT.TYPE.LIST<1,14> = 'HTML'
      FORMAT.TYPE.LIST<2,14> = 'HTML'
      FORMAT.TYPE.LIST<1,15> = 'TAB'
      FORMAT.TYPE.LIST<2,15> = 'TAB'
      FORMAT.TYPE.LIST<1,16> = 'XML'
      FORMAT.TYPE.LIST<2,16> = 'XML'
*
      ORIENTATION.TYPE.LIST = 'HORIZONTAL'
      ORIENTATION.TYPE.LIST := @FM:'VERTICAL'
*
      OPTION.LIST = 'DISPLAY.COUNT'
      OPTION.LIST := @FM:'NO.DISPLAY.COUNT'
      OPTION.LIST := @FM:'PROGRESS.INTERVAL'
      OPTION.LIST := @FM:'WRITE.INTERVAL'
      OPTION.LIST := @FM:'NO.PAGE'
      OPTION.LIST := @FM:'NOPAGE'
      OPTION.LIST := @FM:'PRINT.ERRORS'
      OPTION.LIST := @FM:'NO.PRINT.ERRORS'
      OPTION.LIST := @FM:'PRINT.LAYOUT'
      OPTION.LIST := @FM:'LPTR'
      OPTION.LIST := @FM:'DEBUG.LEVEL'
      OPTION.LIST := @FM:'SAMPLE'
      OPTION.LIST := @FM:'FROM'
      OPTION.LIST := @FM:'DEFAULT'
      OPTION.LIST := @FM:'FORMAT'
      OPTION.LIST := @FM:'FILE'
      OPTION.LIST := @FM:'BY.EXP'
      OPTION.LIST := @FM:'WHEN'
      OPTION.LIST := @FM:'RECORD.ORIENTATION'
      OPTION.LIST := @FM:'RECORD.LENGTH'
      OPTION.LIST := @FM:'NO.LINEFEED'
      OPTION.LIST := @FM:'OVERWRITING'
      OPTION.LIST := @FM:'APPEND'
      OPTION.LIST := @FM:'HEADING'
      OPTION.LIST := @FM:'DETAIL'
      OPTION.LIST := @FM:'HEADING.ON'
      OPTION.LIST := @FM:'FOOTING'
      OPTION.LIST := @FM:'FOOTING.ON'
      OPTION.LIST := @FM:'DET.SUP'
      OPTION.LIST := @FM:'BEGIN'
      OPTION.LIST := @FM:'END'
      OPTION.LIST := @FM:'QUOTE.CHAR'
      OPTION.LIST := @FM:'COMMA.CHAR'
      OPTION.LIST := @FM:'EOR.CHAR'
      OPTION.LIST := @FM:'UPCASE'
      OPTION.LIST := @FM:'REMOVE.PUNCTUATION'
      OPTION.LIST := @FM:'FIELD.GAP'
      OPTION.LIST := @FM:'HTML.TITLE'
      OPTION.LIST := @FM:'HTML.TOP'
      OPTION.LIST := @FM:'HTML.BOTTOM'
      OPTION.LIST := @FM:'HTML.TABLE'
      OPTION.LIST := @FM:'HTML.BODY'
      OPTION.LIST := @FM:'XML.FILE.NAME'
      OPTION.LIST := @FM:'XML.FILE.ATTRIBUTE'
      OPTION.LIST := @FM:'XML.ROOT.NAME'
      OPTION.LIST := @FM:'XML.ROOT.ATTRIBUTE'
      OPTION.LIST := @FM:'XML.ALLOW.PERIODS'
      OPTION.LIST := @FM:'XML.UPCASE'
*
      AT.VARIABLE.LIST = '@ACCOUNT'
      AT.VARIABLE.LIST := @FM:'@DATE'
      AT.VARIABLE.LIST := @FM:'@DAY'
      AT.VARIABLE.LIST := @FM:'@LOGNAME'
      AT.VARIABLE.LIST := @FM:'@MONTH'
      AT.VARIABLE.LIST := @FM:'@PATH'
      AT.VARIABLE.LIST := @FM:'@SYSTEM.RETURN.CODE'
      AT.VARIABLE.LIST := @FM:'@TIME'
      AT.VARIABLE.LIST := @FM:'@YEAR'
*
      MISC.KEYWORD.LIST = 'ALL'
      MISC.KEYWORD.LIST := @FM:'NONE'
      MISC.KEYWORD.LIST := @FM:'FINAL'
      MISC.KEYWORD.LIST := @FM:'DICT'
*
      MISC.FIELD.LIST = 'SUBR'
      MISC.FIELD.LIST := @FM:'LITERAL'
*
      PREFIX.LIST = 'TOTAL'
      PREFIX.LIST := @FM:'AVERAGE'
      PREFIX.LIST := @FM:'MIN'
      PREFIX.LIST := @FM:'MAX'
      PREFIX.LIST := @FM:'BREAK.ON'
      PREFIX.LIST := @FM:'BREAK.SUP'
*
      QUALIFIER.LIST = 'LINE'
      QUALIFIER.LIST := @FM:'LENGTH'
      QUALIFIER.LIST := @FM:'BEG.COL'
      QUALIFIER.LIST := @FM:'END.COL'
      QUALIFIER.LIST := @FM:'COLUMNS'
      QUALIFIER.LIST := @FM:'FMT'
      QUALIFIER.LIST := @FM:'CONV'
      QUALIFIER.LIST := @FM:'HTML.START'
      QUALIFIER.LIST := @FM:'HTML.END'
      QUALIFIER.LIST := @FM:'HTML.CELL'
      QUALIFIER.LIST := @FM:'HTML.ROW'
      QUALIFIER.LIST := @FM:'XML.ATTRIBUTE'
      QUALIFIER.LIST := @FM:'XML.ASSOC.NAME'
      QUALIFIER.LIST := @FM:'XML.SUBASSOC.NAME'
      QUALIFIER.LIST := @FM:'XML.NAME'
      QUALIFIER.LIST := @FM:'NUM.VALUES'
      QUALIFIER.LIST := @FM:'NUM.SUBVALUES'
      QUALIFIER.LIST := @FM:'MV.ORIENTATION'
      QUALIFIER.LIST := @FM:'VALUE.SEPARATOR'
      QUALIFIER.LIST := @FM:'SUBVALUE.SEPARATOR'
      QUALIFIER.LIST := @FM:'SINGLE.VALUE'
      QUALIFIER.LIST := @FM:'MULTI.VALUE'
      QUALIFIER.LIST := @FM:'FIELD.NAMES'
      QUALIFIER.LIST := @FM:'FIELD.LABELS'
      QUALIFIER.LIST := @FM:'DEFAULT.VALUE'
      QUALIFIER.LIST := @FM:'NO.NULLS'
*
      QUALIFIERS.WITH.NO.DEFAULT = 'END.COL'
      QUALIFIERS.WITH.NO.DEFAULT := @FM:'COLUMNS'
      QUALIFIERS.WITH.NO.DEFAULT := @FM:'MULTI.VALUE'
      QUALIFIERS.WITH.NO.DEFAULT := @FM:'SINGLE.VALUE'
*
      OPERATOR.LIST = ''
      OPERATOR.LIST<1,1> = 'EQ'
      OPERATOR.LIST<2,1> = 'EQ'
      OPERATOR.LIST<1,2> = '='
      OPERATOR.LIST<2,2> = 'EQ'
      OPERATOR.LIST<1,3> = 'NE'
      OPERATOR.LIST<2,3> = 'NE'
      OPERATOR.LIST<1,4> = '<>'
      OPERATOR.LIST<2,4> = 'NE'
      OPERATOR.LIST<1,5> = '#'
      OPERATOR.LIST<2,5> = 'NE'
      OPERATOR.LIST<1,6> = 'GE'
      OPERATOR.LIST<2,6> = 'GE'
      OPERATOR.LIST<1,7> = '>='
      OPERATOR.LIST<2,7> = 'GE'
      OPERATOR.LIST<1,8> = '=>'
      OPERATOR.LIST<2,8> = 'GE'
      OPERATOR.LIST<1,9> = 'GT'
      OPERATOR.LIST<2,9> = 'GT'
      OPERATOR.LIST<1,10> = '>'
      OPERATOR.LIST<2,10> = 'GT'
      OPERATOR.LIST<1,11> = 'LE'
      OPERATOR.LIST<2,11> = 'LE'
      OPERATOR.LIST<1,12> = '<='
      OPERATOR.LIST<2,12> = 'LE'
      OPERATOR.LIST<1,13> = '=<'
      OPERATOR.LIST<2,13> = 'LE'
      OPERATOR.LIST<1,14> = 'LT'
      OPERATOR.LIST<2,14> = 'LT'
      OPERATOR.LIST<1,15> = '<'
      OPERATOR.LIST<1,15> = 'LT'
      OPERATOR.LIST<1,16> = 'LIKE'
      OPERATOR.LIST<2,16> = 'LIKE'
      OPERATOR.LIST<1,17> = 'MATCHES'
      OPERATOR.LIST<2,17> = 'LIKE'
      OPERATOR.LIST<1,18> = 'UNLIKE'
      OPERATOR.LIST<2,18> = 'UNLIKE'
*
      PREPROCESS.LIST = 'USING'
      PREPROCESS.LIST := @FM:'SECONDARY.FILE'
      PREPROCESS.LIST := @FM:'KEY'
      PREPROCESS.LIST := @FM:'ALIAS'

      SYNONYM.LIST = 'LIT'
      SYNONYM.LIST := @FM:'CNV'
      SYNONYM.VALUE.LIST = 'LITERAL'
      SYNONYM.VALUE.LIST := @FM:'CONV'

      RETURN


*
* SET UP @ VARIABLES
*
SET.UP.AT.VARIABLE.LIST: 
      NUM.AT.VARIABLES = COUNT(AT.VARIABLE.LIST,@FM) + 1
      RETURN




*
* LOOK UP KEYWORDS (IF ANY) FOR OPTIONS, QUALIFIERS, & OPERATORS
*
SET.UP.KEYWORD.VALUES: 
      THROWAWAY.KEYWORD = ''
      CALL GETKEYWORD(THROWAWAY.KEYWORD, 'A')
*
      NUM.MISC.KEYWORDS = COUNT(MISC.KEYWORD.LIST,@FM) + 1
      MISC.KEYWORD.KEYWORD.LIST = ''
      FOR MISC.KEYWORD.CTR=1 TO NUM.MISC.KEYWORDS
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, MISC.KEYWORD.LIST<MISC.KEYWORD.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            MISC.KEYWORD.KEYWORD.LIST<MISC.KEYWORD.CTR> = KEYWORD.VALUE
         END ELSE
            MISC.KEYWORD.KEYWORD.LIST<MISC.KEYWORD.CTR> = MISC.KEYWORD.LIST<MISC.KEYWORD.CTR>
         END
      NEXT MISC.KEYWORD.CTR
      LOCATE 'ALL' IN MISC.KEYWORD.LIST<1> SETTING KEYWORD.POS THEN
         KEYWORD.ALL = MISC.KEYWORD.KEYWORD.LIST<KEYWORD.POS>
      END ELSE
         KEYWORD.ALL = 'ALL'
      END
      LOCATE 'NONE' IN MISC.KEYWORD.LIST<1> SETTING KEYWORD.POS THEN
         KEYWORD.NONE = MISC.KEYWORD.KEYWORD.LIST<KEYWORD.POS>
      END ELSE
         KEYWORD.NONE = 'NONE'
      END
      LOCATE 'FINAL' IN MISC.KEYWORD.LIST<1> SETTING KEYWORD.POS THEN
         KEYWORD.FINAL = MISC.KEYWORD.KEYWORD.LIST<KEYWORD.POS>
      END ELSE
         KEYWORD.FINAL = 'FINAL'
      END
      LOCATE 'DICT' IN MISC.KEYWORD.LIST<1> SETTING KEYWORD.POS THEN
         KEYWORD.DICT = MISC.KEYWORD.KEYWORD.LIST<KEYWORD.POS>
      END ELSE
         KEYWORD.DICT = 'DICT'
      END
*
      NUM.PREPROCESS = COUNT(PREPROCESS.LIST,@FM) + 1
      PREPROCESS.KEYWORD.LIST = ''
      FOR PREPROCESS.CTR=1 TO NUM.PREPROCESS
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, PREPROCESS.LIST<PREPROCESS.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            PREPROCESS.KEYWORD.LIST<PREPROCESS.CTR> = KEYWORD.VALUE
         END ELSE
            PREPROCESS.KEYWORD.LIST<PREPROCESS.CTR> = PREPROCESS.LIST<PREPROCESS.CTR>
         END
      NEXT PREPROCESS.CTR
*
      NUM.OPTIONS = COUNT(OPTION.LIST,@FM) + 1
      OPTION.KEYWORD.LIST = ''
      FOR OPTION.CTR=1 TO NUM.OPTIONS
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, OPTION.LIST<OPTION.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            OPTION.KEYWORD.LIST<OPTION.CTR> = KEYWORD.VALUE
         END ELSE
            OPTION.KEYWORD.LIST<OPTION.CTR> = OPTION.LIST<OPTION.CTR>
         END
      NEXT OPTION.CTR
      LOCATE 'BEGIN' IN OPTION.LIST<1> SETTING KEYWORD.POS THEN
         KEYWORD.BEGIN = OPTION.KEYWORD.LIST<KEYWORD.POS>
      END ELSE
         KEYWORD.BEGIN = 'BEGIN'
      END
      LOCATE 'END' IN OPTION.LIST<1> SETTING KEYWORD.POS THEN
         KEYWORD.END = OPTION.KEYWORD.LIST<KEYWORD.POS>
      END ELSE
         KEYWORD.END = 'END'
      END
*
      NUM.MISC.FIELDS = COUNT(MISC.FIELD.LIST,@FM) + 1
      MISC.FIELD.KEYWORD.LIST = ''
      FOR MISC.FIELD.CTR=1 TO NUM.MISC.FIELDS
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, MISC.FIELD.LIST<MISC.FIELD.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            MISC.FIELD.KEYWORD.LIST<MISC.FIELD.CTR> = KEYWORD.VALUE
         END ELSE
            MISC.FIELD.KEYWORD.LIST<MISC.FIELD.CTR> = MISC.FIELD.LIST<MISC.FIELD.CTR>
         END
      NEXT MISC.FIELD.CTR
*
      NUM.PREFIXES = COUNT(PREFIX.LIST,@FM) + 1
      PREFIX.KEYWORD.LIST = ''
      FOR PREFIX.CTR=1 TO NUM.PREFIXES
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, PREFIX.LIST<PREFIX.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            PREFIX.KEYWORD.LIST<PREFIX.CTR> = KEYWORD.VALUE
         END ELSE
            PREFIX.KEYWORD.LIST<PREFIX.CTR> = PREFIX.LIST<PREFIX.CTR>
         END
      NEXT PREFIX.CTR
*
      NUM.QUALIFIERS = COUNT(QUALIFIER.LIST,@FM) + 1
      QUALIFIER.KEYWORD.LIST = ''
      FOR QUALIFIER.CTR=1 TO NUM.QUALIFIERS
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, QUALIFIER.LIST<QUALIFIER.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            QUALIFIER.KEYWORD.LIST<QUALIFIER.CTR> = KEYWORD.VALUE
         END ELSE
            QUALIFIER.KEYWORD.LIST<QUALIFIER.CTR> = QUALIFIER.LIST<QUALIFIER.CTR>
         END
      NEXT QUALIFIER.CTR
*
      NUM.OPERATORS = COUNT(OPERATOR.LIST<1>,@VM) + 1
      OPERATOR.KEYWORD.LIST = ''
      FOR OPERATOR.CTR=1 TO NUM.OPERATORS
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, OPERATOR.LIST<2,OPERATOR.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            OPERATOR.KEYWORD.LIST<2,OPERATOR.CTR> = KEYWORD.VALUE
         END ELSE
            OPERATOR.KEYWORD.LIST<2,OPERATOR.CTR> = OPERATOR.LIST<2,OPERATOR.CTR>
         END
      NEXT OPERATOR.CTR
      RETURN


*******************************************************************************
**
**   OPERATING-SYSTEM SPECIFIC SUBROUTINES
**      AN ATTEMPT HAS BEEN MADE TO ISOLATE ALL OPERATING SYSTEM SPECIFIC
**      CHANGES TO THE FOLLOWING SET OF SUBROUTINES
**
*******************************************************************************
DBMS.SET.UP: 
      XL.IGNORE.OPTION = ''
      BEGIN CASE
         CASE DBMS.NAME = 'INFORMATION'
            GOSUB DBMS.INFORMATION.SET.UP
         CASE DBMS.NAME = 'UNIDATA'
            GOSUB DBMS.UNIDATA.SET.UP
         CASE DBMS.NAME = 'UNIVERSE'
            GOSUB DBMS.UNIVERSE.SET.UP
      END CASE
      RETURN

DBMS.INFORMATION.SET.UP: 
      DBMS.COMMAND.LINE = @SENTENCE
      DBMS.COMMAND.LINE.ITEMS.TO.SKIP = 3
      DBMS.ACCOUNT.PATH.NAME = @PATH
      DBMS.DICT.FIELD.TO.CHECK = 17
      DBMS.PATH.DELIM = '>'
      DBMS.HIGHEST.SELECT.UNIT = 10
      DBMS.VOC.ITEM.TYPE.LIST = 'D,I,X,F,K,PH'
      CONVERT ',' TO @FM IN DBMS.VOC.ITEM.TYPE.LIST
      RETURN

DBMS.UNIDATA.SET.UP: 
      DBMS.COMMAND.LINE = @SENTENCE
      DBMS.COMMAND.LINE.ITEMS.TO.SKIP = 1
      DBMS.ACCOUNT.PATH.NAME = @ACCOUNT
      DBMS.DICT.FIELD.TO.CHECK = 8
      DBMS.PATH.DELIM = '/'
      DBMS.HIGHEST.SELECT.UNIT = 9
      DBMS.VOC.ITEM.TYPE.LIST = 'DIR,D,I,X,F,K,PH'
      CONVERT ',' TO @FM IN DBMS.VOC.ITEM.TYPE.LIST
      RETURN


DBMS.UNIVERSE.SET.UP: 
      DBMS.COMMAND.LINE = @SENTENCE
      DBMS.COMMAND.LINE.ITEMS.TO.SKIP = 1
      DBMS.ACCOUNT.PATH.NAME = @ACCOUNT
      DBMS.DICT.FIELD.TO.CHECK = 17
      DBMS.PATH.DELIM = '/'
      DBMS.HIGHEST.SELECT.UNIT = 9
      DBMS.VOC.ITEM.TYPE.LIST = 'DIR,D,I,X,F,K,PH'
      CONVERT ',' TO @FM IN DBMS.VOC.ITEM.TYPE.LIST
      XL.IGNORE.OPTION = 'FMT'
      CONVERT ' ' TO @VM IN XL.IGNORE.OPTION
      RETURN


OP.SYS.SET.UP: 
      BEGIN CASE
         CASE OP.SYS.NAME = 'PRIMOS'
            GOSUB OP.SYS.PRIMOS.SET.UP
         CASE OP.SYS.NAME = 'UNIX'
            GOSUB OP.SYS.UNIX.SET.UP
         CASE OP.SYS.NAME = 'WINDOWS'
            GOSUB OP.SYS.WINDOWS.SET.UP
      END CASE
      RETURN

OP.SYS.PRIMOS.SET.UP: 
      OP.SYS.PATH.DELIM = '>'
      RETURN

OP.SYS.UNIX.SET.UP: 
      OP.SYS.PATH.DELIM = '/'
      RETURN


OP.SYS.WINDOWS.SET.UP: 
      OP.SYS.PATH.DELIM = '\'
      RETURN


*
* OPERATING SYSTEM DEPENDENT FILE I/O
*
OP.SYS.OPENFILE: 
      BEGIN CASE
         CASE OP.SYS.NAME = 'PRIMOS'
            GOSUB OP.SYS.POPEN
         CASE OP.SYS.NAME = 'UNIX'
            GOSUB OP.SYS.UNIX.OPENFILE
         CASE OP.SYS.NAME = 'WINDOWS'
            GOSUB OP.SYS.WINDOWS.OPENFILE
      END CASE
      RETURN

*
* PRIMOS FILE I/O/ ROUTINES
*
*
* OPEN A PRIMOS FILE FOR WRITING
*
OP.SYS.POPEN: 
      OP.SYS.BUFFER = ''
      OP.SYS.BUFFER.SIZE = 256
      OP.SYS.FILE.FUNIT = ''
      IF INDEX(DLMAIN.TYPE1.FILE.PATH.NAME,OP.SYS.PATH.DELIM,1) > 0 THEN
         OP.SYS.FILE.PATH.NAME = DLMAIN.TYPE1.FILE.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.TYPE1.RECORD.NAME
      END ELSE
         OP.SYS.FILE.PATH.NAME = DBMS.ACCOUNT.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.TYPE1.FILE.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.TYPE1.RECORD.NAME
      END
      ACTION = 'WRITE'
      OPEN.ERRMSG = ''
      IF DLMAIN.DEBUG.LEVEL GT 0 THEN
         CRT 'Calling POPEN for file ':OP.SYS.FILE.PATH.NAME
      END
      CALL POPEN(OP.SYS.FILE.FUNIT, OP.SYS.FILE.PATH.NAME, ACTION, DLMAIN.OVERWRITING, OPEN.ERRMSG)
      IF OPEN.ERRMSG THEN
         DLMAIN.ERRMSG<-1> = 'Error in opening "':OP.SYS.FILE.PATH.NAME:'" for direct write'
         DLMAIN.ERRMSG<-1> = '   ':OPEN.ERRMSG
         DLMAIN.FATAL.ERROR = TRUE
      END
      RETURN

OP.SYS.UNIX.OPENFILE: 
      IF INDEX(DLMAIN.TYPE1.FILE.PATH.NAME,OP.SYS.PATH.DELIM,1) > 0 THEN
         OP.SYS.FILE.PATH.NAME =DLMAIN.TYPE1.FILE.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.TYPE1.RECORD.NAME
      END ELSE
         OP.SYS.FILE.PATH.NAME = DBMS.ACCOUNT.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.TYPE1.FILE.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.TYPE1.RECORD.NAME
      END
      OP.SYS.FILE.EXISTS = TRUE
      IF DLMAIN.DEBUG.LEVEL GT 0 THEN
         CRT 'About to open Unix file ':OP.SYS.FILE.PATH.NAME
      END
      *INFORMATION      OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE
      *INFORMATION         OP.SYS.FILE.EXISTS = FALSE
      *INFORMATION      END
      *UNIDATA          OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE
      *UNIDATA             OP.SYS.FILE.EXISTS = FALSE
      *UNIDATA          END
               OPENSEQ DLMAIN.TYPE1.FILE.NAME,DLMAIN.TYPE1.RECORD.NAME TO OP.SYS.FILE.FUNIT ELSE
                  OP.SYS.FILE.EXISTS = FALSE
               END
      OP.SYS.BUFFER.SIZE = 0
      OSOPEN.STATUS = STATUS()
      BEGIN CASE
         CASE OSOPEN.STATUS # 0 AND OSOPEN.STATUS # 4
            DLMAIN.ERRMSG<-1> = 'Error in opening "':OP.SYS.FILE.PATH.NAME:'" for direct write'
            DLMAIN.FATAL.ERROR = TRUE
         CASE OP.SYS.FILE.EXISTS AND NOT(DLMAIN.OVERWRITING)
            DLMAIN.ERRMSG<-1> = '"':OP.SYS.FILE.PATH.NAME:'" already exists'
            DLMAIN.FATAL.ERROR = TRUE
         CASE 1
            *INFORMATION            OSWRITE '' ON OP.SYS.FILE.PATH.NAME
            *INFORMATION            OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE NULL
            *UNIDATA            OSWRITE '' ON OP.SYS.FILE.PATH.NAME
            *UNIDATA            OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE NULL
             WEOFSEQ OP.SYS.FILE.FUNIT
      END CASE
      RETURN

OP.SYS.WINDOWS.OPENFILE: 
      IF INDEX(DLMAIN.TYPE1.FILE.PATH.NAME,OP.SYS.PATH.DELIM,1) > 0 THEN
         OP.SYS.FILE.PATH.NAME =DLMAIN.TYPE1.FILE.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.TYPE1.RECORD.NAME
      END ELSE
         OP.SYS.FILE.PATH.NAME = DBMS.ACCOUNT.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.TYPE1.FILE.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.TYPE1.RECORD.NAME
      END
      OP.SYS.FILE.EXISTS = TRUE
      IF DLMAIN.DEBUG.LEVEL GT 0 THEN
         CRT 'About to open Windows file ':OP.SYS.FILE.PATH.NAME
      END
      *INFORMATION      OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE
      *INFORMATION         OP.SYS.FILE.EXISTS = FALSE
      *INFORMATION      END
      *UNIDATA          OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE
      *UNIDATA             OP.SYS.FILE.EXISTS = FALSE
      *UNIDATA          END
               OPENSEQ DLMAIN.TYPE1.FILE.NAME,DLMAIN.TYPE1.RECORD.NAME TO OP.SYS.FILE.FUNIT ELSE
                  OP.SYS.FILE.EXISTS = FALSE
               END
      OP.SYS.BUFFER.SIZE = 0
      OSOPEN.STATUS = STATUS()
      BEGIN CASE
         CASE OSOPEN.STATUS # 0 AND OSOPEN.STATUS # 4
            DLMAIN.ERRMSG<-1> = 'Error in opening "':OP.SYS.FILE.PATH.NAME:'" for direct write'
            DLMAIN.FATAL.ERROR = TRUE
         CASE OP.SYS.FILE.EXISTS AND NOT(DLMAIN.OVERWRITING)
            DLMAIN.ERRMSG<-1> = '"':OP.SYS.FILE.PATH.NAME:'" already exists'
            DLMAIN.FATAL.ERROR = TRUE
         CASE 1
            *INFORMATION            OSWRITE '' ON OP.SYS.FILE.PATH.NAME
            *INFORMATION            OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE NULL
            *UNIDATA            OSWRITE '' ON OP.SYS.FILE.PATH.NAME
            CRT 'WRITING ':OP.SYS.FILE.PATH.NAME
            *UNIDATA            OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE NULL
             WEOFSEQ OP.SYS.FILE.FUNIT
      END CASE
      RETURN


*
* DETERMINE FILE TYPE (TYPE1 OR INFO)
*
OP.SYS.FILE.TYPE: 
      BEGIN CASE
         CASE DBMS.NAME = 'INFORMATION'
            GOSUB OP.SYS.INFORMATION.FILE.TYPE
         CASE DBMS.NAME = 'UNIDATA'
            GOSUB OP.SYS.UNIDATA.FILE.TYPE
         CASE DBMS.NAME = 'UNIVERSE'
            GOSUB OP.SYS.UNIVERSE.FILE.TYPE
      END CASE
      RETURN

*
* FINFO$TYPE IS DETERMINED FROM THE INSERT FILE "SYSCOM>FILEINFO.INS.IBAS"
*
OP.SYS.INFORMATION.FILE.TYPE: 
      FILE.TYPE = ''
      FINFO$TYPE = 3
      *INFORMATION       FILE.TYPE = FILEINFO(F.TEST,FINFO$TYPE)
      IF FILE.TYPE = 4 THEN
         ITEM.TYPE = 'TYPE1.FILE'
      END ELSE
         ITEM.TYPE = 'INFO.FILE'
      END
      RETURN

OP.SYS.UNIDATA.FILE.TYPE: 
      IF DLMAIN.DEBUG.LEVEL GT 0 THEN
         CRT 'Checking file type ':VOC.ITEM.TYPE
      END
      IF VOC.ITEM.TYPE = 'DIR' THEN
         ITEM.TYPE = 'TYPE1.FILE'
      END ELSE
         ITEM.TYPE = 'FILE'
      END
      RETURN

OP.SYS.UNIVERSE.FILE.TYPE: 
      IF DLMAIN.DEBUG.LEVEL GT 0 THEN
         CRT 'Checking file type ':VOC.ITEM.TYPE
      END
      IF VOC.ITEM.TYPE = 'DIR' THEN
         ITEM.TYPE = 'TYPE1.FILE'
      END ELSE
         ITEM.TYPE = 'FILE'
      END
      RETURN



*******************************************************************************
**
**   PRE-ITEM PROCESSING (DO THESE THINGS BEFORE PROCESSING ITEMS
**
*******************************************************************************
PRE.ITEMS.PROCESSING: 
      GOSUB PARSE.INITIAL.LINE
      GOSUB CHECK.FOR.INFO.FILE
      GOSUB SET.UP.OPTION.DEFAULTS
      IF NOT(DLMAIN.FATAL.ERROR) THEN
         GOSUB OPEN.PRIMARY.DICT
      END
      IF NOT(DLMAIN.FATAL.ERROR) THEN
         GOSUB PROCESS.PREPROCESS.ITEMS
      END
      ITEM.CTR = 0
      ITEMS.DONE = FALSE
      RETURN


*
*
* PARSE THE COMMAND LINE (DO NOT CHECK DICTIONARY OR VOC FOR PHRASES YET)
*
PARSE.INITIAL.LINE: 
      PCL.DICT.FILE.NAME = ''
      EXPAND.VOC.PHRASES = FALSE
      OTHER.SEPARATORS = '(':@FM:')':@FM:','
      ITEMS.DONE = FALSE
      ITEM.CTR = 0
*
      PARAM.LIST = ''
      PARAM.QUOTED.LIST = ''
      NUM.PARAMS = 0
      CALL PARSECL(DBMS.COMMAND.LINE, PARAM.LIST, PARAM.QUOTED.LIST, NUM.PARAMS, OTHER.SEPARATORS)
*
* SKIP BEGINNING ITEMS ON COMMAND LINE
*
      NUM.ITEMS = NUM.PARAMS - DBMS.COMMAND.LINE.ITEMS.TO.SKIP
      BEG.ITEM.NUM = DBMS.COMMAND.LINE.ITEMS.TO.SKIP + 1
      ITEM.LIST = FIELD(PARAM.LIST,@FM,BEG.ITEM.NUM,NUM.ITEMS)
      ITEM.QUOTED.LIST = FIELD(PARAM.QUOTED.LIST,@FM,BEG.ITEM.NUM,NUM.ITEMS)
      ITEM.USED.LIST = ''
      IF NUM.ITEMS = 0 THEN
         GOSUB PRINT.HELP
         STOP
      END
*
* CHECK FOR KEYWORD "BEGIN" AT END OF FIRST LINE, IF IT IS THERE, CONTINUE
* READING LINES FROM THE TERMINAL UNTIL THE KEYWORD "END" IS AT THE END OF
* A LINE
*
      ITEM = ITEM.LIST<NUM.ITEMS>
      ITEM.QUOTED = ITEM.QUOTED.LIST<NUM.ITEMS>
      GOSUB DETERMINE.ITEM.TYPE
      FOUND.KEYWORD.BEGIN = FALSE
      IF ITEM.TYPE = 'OPTION' AND ITEM.KEYWORD = KEYWORD.BEGIN THEN
         FOUND.KEYWORD.BEGIN = TRUE
         DEL ITEM.LIST<NUM.ITEMS>
         DEL ITEM.QUOTED.LIST<NUM.ITEMS>
         DEL ITEM.USED.LIST<NUM.ITEMS>
         NUM.ITEMS -= 1
      END
      IF FOUND.KEYWORD.BEGIN THEN
         LOOP
            LOOP
               X.LINE = ''
               CALL PROMPTSTACK(DOWNLOAD.PROMPT, PROGRAM.NAME, X.LINE)
               CHECK.FLAG = TRIM(X.LINE)[1,1]
            UNTIL CHECK.FLAG # '*' AND CHECK.FLAG # ''
            REPEAT
            TEST.QUIT = OCONV(TRIM(X.LINE),'MCU')
            IF TEST.QUIT = 'QUIT' THEN
               CRT 'Download aborted!'
               STOP
            END
            GOSUB PARSE.INITIAL.X.LINE
         UNTIL FOUND.KEYWORD.END
         REPEAT
      END
      LOCATE 'HELP' IN ITEM.LIST<1> SETTING HELP.POS THEN
         GOSUB PRINT.HELP
         STOP
      END
      LOCATE 'DEBUG.LEVEL' IN ITEM.LIST<1> SETTING DEBUG.POS THEN
         ITEM.CTR = DEBUG.POS
         GOSUB PROCESS.OPTION.DEBUG.LEVEL
      END
      LOCATE 'FILE' IN ITEM.LIST<1> SETTING FILE.POS THEN
         GOSUB CHECK.VARIABLE.FILE.NAME
      END
      LOCATE 'XML.ALLOW.PERIODS' IN ITEM.LIST<1> SETTING XML.POS THEN
         GOSUB PROCESS.OPTION.XML.ALLOW.PERIODS
      END
      LOCATE 'XML.UPCASE' IN ITEM.LIST<1> SETTING XML.POS THEN
         GOSUB PROCESS.OPTION.XML.UPCASE
      END
      RETURN


*
*
* PARSE THE EXTRA LINES ENTERED UNTIL KEYWORD 'END' IS FOUND
*
PARSE.INITIAL.X.LINE: 
      FOUND.KEYWORD.END = FALSE
      X.ITEM.LIST = ''
      X.ITEM.QUOTED.LIST = ''
      NUM.X.ITEMS = 0
      CALL PARSECL(X.LINE, X.ITEM.LIST, X.ITEM.QUOTED.LIST, NUM.X.ITEMS, OTHER.SEPARATORS)
      X.ITEM.USED.LIST = ''
      CALL EXPAND.ITEMS(X.ITEM.LIST,X.ITEM.QUOTED.LIST,X.ITEM.USED.LIST,NUM.X.ITEMS,PCL.DICT.FILE.NAME,EXPAND.VOC.PHRASES, OTHER.SEPARATORS)
      ITEM.LIST<NUM.ITEMS+1> = X.ITEM.LIST
      ITEM.QUOTED.LIST<NUM.ITEMS+1> = X.ITEM.QUOTED.LIST
      ITEM.USED.LIST<NUM.ITEMS+1> = X.ITEM.USED.LIST
      NUM.ITEMS += NUM.X.ITEMS
      ITEM = ITEM.LIST<NUM.ITEMS>
      ITEM.QUOTED = ITEM.QUOTED.LIST<NUM.ITEMS>
      GOSUB DETERMINE.ITEM.TYPE
      IF ITEM.TYPE = 'OPTION' AND ITEM.KEYWORD = KEYWORD.END THEN
         FOUND.KEYWORD.END = TRUE
         DEL ITEM.LIST<NUM.ITEMS>
         DEL ITEM.QUOTED.LIST<NUM.ITEMS>
         DEL ITEM.USED.LIST<NUM.ITEMS>
         NUM.ITEMS -= 1
      END
      RETURN


*
*
* CHECK FOR AN INFORMATION FILE NAME ON THE COMMAND LINE
* (GET NAME OF FILE TO BE DOWNLOADED)
* FILE NAME MUST BE FIRST PARAMETER
*
CHECK.FOR.INFO.FILE: 
      ITEM.CTR = 1
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      ITEM = ITEM.LIST<ITEM.CTR>
      ITEM.QUOTED = ITEM.QUOTED.LIST<ITEM.CTR>
      LOOKUP.FILE.NAME = TRUE
      GOSUB CHECK.VOC.FOR.NONFIELD
      PHRASE.USED = ''
      DLMAIN.NUM.FILES = PRIMARY.FILE.NUM
      DLMAIN.INFO.FILE.KEY.DICT.CTR(PRIMARY.FILE.NUM) = ''
      DLMAIN.INFO.FILE.ALIAS.LIST<PRIMARY.FILE.NUM> = ''
      DLMAIN.INFO.FILE.NAME.PART.1(PRIMARY.FILE.NUM) = ''
      IF ITEM.KEYWORD = KEYWORD.DICT THEN
         PHRASE.USED = 'DICT '
         DLMAIN.INFO.FILE.NAME.PART.1(PRIMARY.FILE.NUM) = 'DICT'
         ITEM.CTR += 1
         ITEM.USED.LIST<ITEM.CTR> = TRUE
         ITEM = ITEM.LIST<ITEM.CTR>
         ITEM.QUOTED = ITEM.QUOTED.LIST<ITEM.CTR>
         LOOKUP.FILE.NAME = TRUE
         GOSUB CHECK.VOC.FOR.NONFIELD
      END
      PHRASE.USED := ITEM.QUOTED:ITEM:ITEM.QUOTED
      DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM) = ''
      IF ITEM.TYPE = 'INFO.FILE' OR ITEM.TYPE = 'FILE' OR ITEM.TYPE = 'TYPE1.FILE' THEN
         DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM) = ITEM
         OPEN DLMAIN.INFO.FILE.NAME.PART.1(PRIMARY.FILE.NUM), DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM) TO DLMAIN.F.INFO.FILE(PRIMARY.FILE.NUM) ELSE
            DLMAIN.ERRMSG<-1> = 'Can not open "':PHRASE.USED:'"'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PROGRAM.NAME:' ':PHRASE.USED:'": should be "':PROGRAM.NAME:' [DICT] InfoFileName"'
         DLMAIN.ERRMSG<-1> = 'Could not find file ':PHRASE.USED:' in VOC.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      DLMAIN.INFO.FILE.ALIAS.LIST<PRIMARY.FILE.NUM> = DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM)
      RETURN


*
*
* SET UP OPTION DEFAULTS
*
SET.UP.OPTION.DEFAULTS: 
      IF DLMAIN.INFO.FILE.NAME.PART.1(PRIMARY.FILE.NUM) = 'DICT' THEN
         PRIMARY.DICT.PART.1 = 'DICT'
         PRIMARY.DICT.PART.2 = 'DICT'
      END ELSE
         PRIMARY.DICT.PART.1 = 'DICT'
         PRIMARY.DICT.PART.2 = DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM)
      END
*
* DECIDE ON DLMAIN.DISPLAY.COUNT AFTER DLMAIN.PRINT.METHOD IS DETERMINED
*   IF PRINTING TO CRT, THEN DEFAULT IS FALSE
*
      DLMAIN.DISPLAY.COUNT = ''
      DLMAIN.HAVE.NO.PAGE = FALSE
      DEFAULT.PROGRESS.INTERVAL = 10
      DLMAIN.PROGRESS.INTERVAL = DEFAULT.PROGRESS.INTERVAL
      DEFAULT.WRITE.INTERVAL = 10
      DLMAIN.WRITE.INTERVAL = DEFAULT.WRITE.INTERVAL
      DEFAULT.WRITE.SLEEP.TIME = 0
      DLMAIN.WRITE.SLEEP.TIME = DEFAULT.WRITE.SLEEP.TIME
      DLMAIN.PRINT.ERRORS = TRUE
      DLMAIN.LPTR = FALSE
      DLMAIN.DEBUG.LEVEL = 0
      DLMAIN.PRINT.LAYOUT = FALSE
      DLMAIN.SAMPLE.SIZE = ''
      DEFAULT.DLMAIN.SAMPLE.SIZE = 10
      DEFAULT.DEBUG.LEVEL = 999
      DLMAIN.FORMAT = 'COMMA'
      DLMAIN.RECORD.ORIENTATION = 'HORIZONTAL'
      DLMAIN.NO.LINEFEED = FALSE
      DLMAIN.RECORD.LENGTH = ''
      DLMAIN.PRINT.METHOD = ''
      DLMAIN.TYPE1.FILE.NAME = ''
      DLMAIN.TYPE1.RECORD.NAME = ''
      DLMAIN.FROM.UNIT = 0
      DLMAIN.OVERWRITING = FALSE
      DLMAIN.APPEND = FALSE
      DLMAIN.DET.SUP = FALSE
      DEFAULT.OUT.REC = DETAIL.OUT.REC
*
* THESE DEFAULTS ARE USED FOR FIELDS ENTERED ON THE COMMAND LINE FOR
* EVERY FIELD THAT DOES NOT INCLUDE THE CORRESPONDING FIELD QUALIFIER
* WITH THE EXCEPTION OF 'FMT' & 'CONV'
* THESE 2 QUALIFIERS FOLLOW THESE RULES:
*   1. IF THERE IS A SPECIFIC 'FMT' OR 'CONV' QUALIFIER FOR A PARTICULAR
*      FIELD ON THE COMMAND LINE, THEN IT IS USED
*   2. IF THERE IS NOT A SPECIFIC 'FMT' OR 'CONV', BUT 'DEFAULT FMT' OR
*      'DEFAULT CONV' IS SPECIFIED, THEN THE 'DEFAULT ...' CODE IS USED
*   3. IF NEITHER THE 'FMT'/'CONV' OR 'DEFAULT FMT'/'DEFAULT CONV' IS
*      USED, THEN IT CHECKS THE DICTIONARY RECORD FOR THE FMT OR CONV
*      CODE TO USE
*
* THE DEFAULT VALUE FOR ALL FIELD QUALIFIERS CAN BE CHANGED (WITH THE
* EXCEPTION OF 'END.COL' & 'COLUMNS') ON THE COMMAND LINE BY SPECIFYING
* 'DEFAULT qualifier value'
* EG. TO CHANGE THE DEFAULT FOR THE NUM.VALUES FROM '1' TO 'ALL' FOR
*     ALL FIELDS BEING DOWNLOADED, USE THE PHRASE 'DEFAULT NUM.VALUES ALL'
* CHANGING THE DEFAULT VALUE FOR A PARTICULAR QUALIFIER DOES NOT AFFECT
* THOSE FIELDS WHICH HAVE AN EXPLICIT FIELD QUALIFIER SPECIFIED
*
      DEFAULT.NUM.VALUES = 1
      SET.DEFAULT.NUM.VALUES = FALSE
      DEFAULT.NUM.SUBVALUES = 1
      SET.DEFAULT.NUM.SUBVALUES = FALSE
      DEFAULT.MV.ORIENTATION = ''
      DEFAULT.VALUE.SEPARATOR = ''
      DEFAULT.SUBVALUE.SEPARATOR = ''
      SET.DEFAULT.VALUE.SEPARATOR = FALSE
      SET.DEFAULT.SUBVALUE.SEPARATOR = FALSE
      DEFAULT.LINE = 1
      DEFAULT.FMT = ''
      DEFAULT.FIELD.FMT = '30L'
      DEFAULT.CONV = ''
      DEFAULT.HTML.START = ''
      DEFAULT.HTML.END = ''
      DEFAULT.HTML.CELL = ''
      DEFAULT.HTML.ROW = ''
      DEFAULT.SM = 'S'
      DEFAULT.LENGTH = ''
      DEFAULT.BEG.COL = 1
      DEFAULT.DEFAULT.VALUE = ''
      RETURN


*
*
* OPEN PRIMARY DICT
*
OPEN.PRIMARY.DICT: 
      PRIMARY.DICT.OPENED = TRUE
      IF PRIMARY.DICT.PART.2 = 'DICT' THEN
         OPEN '', 'DICT.DICT' TO F.DICT.FILE(PRIMARY.FILE.NUM) ELSE
            DLMAIN.ERRMSG<-1> = 'Can not open "':PRIMARY.DICT.PART.1:'" "':PRIMARY.DICT.PART.2:'"'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END ELSE
         OPEN PRIMARY.DICT.PART.1, PRIMARY.DICT.PART.2 TO F.DICT.FILE(PRIMARY.FILE.NUM) ELSE
            DLMAIN.ERRMSG<-1> = 'Can not open "':PRIMARY.DICT.PART.1:'" "':PRIMARY.DICT.PART.2:'"'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      RETURN


*******************************************************************************
**
**   PROCESS COMMAND LINE ITEMS (OPTIONS, QUALIFIERS, RECORD KEYS, FIELDS)
**       AND BUILD APPROPRIATE LISTS, RECORDS, ETC. USED IN PROCESSING
**       OF DATA RECORDS & I-DESCRIPTORS
**
*******************************************************************************
PROCESS.PREPROCESS.ITEMS: 
      SUB.NAME = 'PREPROCESS'
      PREV.ITEM.TYPE = ''
      GOSUB GET.NEXT.ITEM
      CUR.FILE.NUM = ''
      LOOP
*
* SKIP ITEMS ALREADY USED (IN A PREVIOUS PASS THROUGH THE ITEMS)
* AS LONG AS THEY ARE BETWEEN OPTIONS & THE ITEMS THEY NEED
* (EG. "FROM 3 useditem useditem useditem SAMPLE 5"
*  but not "FROM 3 SAMPLE useditem useditem 5")
*
         LOOP
         UNTIL NOT(ITEM.USED) OR ITEMS.DONE
            GOSUB GET.NEXT.ITEM
         REPEAT
      UNTIL ITEMS.DONE
         ORIGINAL.ITEM = ITEM
         PREV.ITEM.TYPE = ITEM.TYPE
         BEGIN CASE
            CASE ITEM.TYPE = 'PREPROCESS'
               GOSUB PROCESS.PREPROCESS
            CASE 1
               CUR.FILE.NUM = ''
               GOSUB GET.NEXT.ITEM
         END CASE
         IF DLMAIN.FATAL.ERROR THEN
            RETURN
         END
      REPEAT
*
      FOR FILE.CTR=2 TO DLMAIN.NUM.FILES
         IF DLMAIN.INFO.FILE.ALIAS.LIST<FILE.CTR> = '' THEN
            DLMAIN.INFO.FILE.ALIAS.LIST<FILE.CTR> = DLMAIN.INFO.FILE.NAME.PART.2(FILE.CTR)
         END
         IF DLMAIN.INFO.FILE.KEY.DICT.CTR(FILE.CTR) = '' THEN
            DICT.FIELD.NAME = '@ID'
            DICT.FILE.NUM = PRIMARY.FILE.NUM
            ITEM.FIELD.FILE.NUM = PRIMARY.FILE.NUM
            DICT.REC = 'D':@FM:'0'
            GOSUB ADD.DICT.REC
            DLMAIN.INFO.FILE.KEY.DICT.CTR(FILE.CTR) = WHICH.DICT.REC.CTR
            DLMAIN.INFO.FILE.KEY.IS.MULTIVALUE(FILE.CTR) = FALSE
         END
      NEXT FILE.CTR
      RETURN


PROCESS.REGULAR.ITEMS: 
      SUB.NAME = 'REGULAR'
      PREV.ITEM.TYPE = ''
      ACTIVE.PREFIX = ''
      CUR.OUT.FIELD.CTR = ''
      GOSUB GET.NEXT.ITEM
      LOOP
*
* SKIP ITEMS ALREADY USED (IN A PREVIOUS THROUGH THE ITEMS)
* AS LONG AS THEY ARE BETWEEN OPTIONS & THE ITEMS THEY NEED
* (EG. "FROM 3 useditem useditem useditem SAMPLE 5"
*  but not "FROM 3 SAMPLE useditem useditem 5")
*
         LOOP
         UNTIL NOT(ITEM.USED) OR ITEMS.DONE
            GOSUB GET.NEXT.ITEM
         REPEAT
      UNTIL ITEMS.DONE
         ORIGINAL.ITEM = ITEM
         IF PREV.ITEM.TYPE = 'PREFIX' AND ITEM.TYPE # 'FIELD' THEN
            DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must prefix a field name to be downloaded'
         END
         PREV.ITEM.TYPE = ITEM.TYPE
         BEGIN CASE
            CASE ITEM.TYPE = ''
               IF NUM(ITEM) AND ITEM > 0 AND CUR.OUT.FIELD.CTR THEN
                  GOSUB PROCESS.QUALIFIER.LENGTH
               END ELSE
                  GOSUB PROCESS.ITEM.AS.RECORD.KEY
                  CUR.OUT.FIELD.CTR = ''
               END
            CASE ITEM.TYPE = 'OPTION'
               GOSUB PROCESS.OPTION
               CUR.OUT.FIELD.CTR = ''
            CASE ITEM.TYPE = 'MISC.FIELD'
               GOSUB PROCESS.MISC.FIELD
            CASE ITEM.TYPE = 'AT.VARIABLE'
               GOSUB PROCESS.AT.VARIABLE
            CASE ITEM.TYPE = 'PREFIX'
               GOSUB PROCESS.PREFIX
            CASE ITEM.TYPE = 'QUALIFIER'
               GOSUB PROCESS.QUALIFIER
            CASE ITEM.TYPE = 'FIELD'
               GOSUB PROCESS.FIELD
            CASE 1
               GOSUB PROCESS.ITEM.AS.ERROR
               CUR.OUT.FIELD.CTR = ''
         END CASE
         IF PREV.ITEM.TYPE # 'PREFIX' THEN
            ACTIVE.PREFIX = ''
         END
         IF DLMAIN.FATAL.ERROR THEN
            RETURN
         END
      REPEAT
      RETURN



*
*
* SAVE ITEM AS RECORD.KEY
*
PROCESS.ITEM.AS.RECORD.KEY: 
      DLMAIN.RECORD.KEY.LIST<-1> = ITEM
      GOSUB GET.NEXT.ITEM
      RETURN



*
*
* TREAT THIS ITEM AS ERROR
*
PROCESS.ITEM.AS.ERROR: 
      DLMAIN.ERRMSG<-1> = 'Not expecting "':ITEM:'" here'
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS.PREPROCESS
*
PROCESS.PREPROCESS: 
      BEGIN CASE
         CASE WHICH.PREPROCESS = 'USING'
            GOSUB PROCESS.PREPROCESS.USING
         CASE WHICH.PREPROCESS = 'SECONDARY.FILE'
            GOSUB PROCESS.PREPROCESS.SECONDARY.FILE
         CASE WHICH.PREPROCESS = 'KEY'
            GOSUB PROCESS.PREPROCESS.KEY
         CASE WHICH.PREPROCESS = 'ALIAS'
            GOSUB PROCESS.PREPROCESS.ALIAS
      END CASE
      RETURN


PROCESS.PREPROCESS.USING: 
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      LOOKUP.FIELD.NAME = FALSE
      LOOKUP.FILE.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      TEMP.NAME.PART.1 = ''
      IF ITEM.KEYWORD = KEYWORD.DICT THEN
         PHRASE.USED = 'USING'
         PHRASE.USED := ' DICT'
         TEMP.NAME.PART.1 = 'DICT'
         ITEM.USED.LIST<ITEM.CTR> = TRUE
         LOOKUP.FIELD.NAME = FALSE
         LOOKUP.FILE.NAME = TRUE
         GOSUB GET.NEXT.ITEM
      END
      PHRASE.USED := ' ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      TEMP.NAME.PART.2 = ''
      IF ITEM.TYPE = 'INFO.FILE' OR ITEM.TYPE = 'FILE' THEN
         TEMP.NAME.PART.2 = ITEM
         ITEM.USED.LIST<ITEM.CTR> = TRUE
      END
      IF TEMP.NAME.PART.2 # '' THEN
         PRIMARY.DICT.PART.1 = TEMP.NAME.PART.1
         PRIMARY.DICT.PART.2 = TEMP.NAME.PART.2
         GOSUB OPEN.PRIMARY.DICT
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": should be "USING [DICT] InfoFileName"'
         DLMAIN.FATAL.ERROR = TRUE
      END
      GOSUB GET.NEXT.ITEM
      RETURN


PROCESS.PREPROCESS.SECONDARY.FILE: 
      PHRASE.USED = ORIG.ITEM
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      LOOKUP.FIELD.NAME = FALSE
      LOOKUP.FILE.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      PHRASE.USED := ' ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      IF ITEM.TYPE = 'INFO.FILE' OR ITEM.TYPE = 'FILE' THEN
         DLMAIN.NUM.FILES += 1
         CUR.FILE.NUM = DLMAIN.NUM.FILES
         DLMAIN.INFO.FILE.KEY.DICT.CTR(CUR.FILE.NUM) = ''
         DLMAIN.INFO.FILE.ALIAS.LIST<CUR.FILE.NUM> = ITEM
         ALIAS.SET(CUR.FILE.NUM) = FALSE
         DLMAIN.INFO.FILE.NAME.PART.1(CUR.FILE.NUM) = ''
         DLMAIN.INFO.FILE.NAME.PART.2(CUR.FILE.NUM) = ITEM
         OPEN 'DICT', ITEM TO F.DICT.FILE(CUR.FILE.NUM) ELSE
            DLMAIN.ERRMSG<-1> = 'Can not open "DICT" "':ITEM:'"'
            DLMAIN.FATAL.ERROR = TRUE
         END
         OPEN '', ITEM TO DLMAIN.F.INFO.FILE(CUR.FILE.NUM) ELSE
            DLMAIN.ERRMSG<-1> = 'Can not open "':ITEM:'"'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": should be "SECONDARY.FILE InfoFileName"'
         DLMAIN.FATAL.ERROR = TRUE
      END
      GOSUB GET.NEXT.ITEM
      RETURN


PROCESS.PREPROCESS.KEY: 
      PHRASE.USED = ORIG.ITEM
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      GOSUB GET.NEXT.ITEM
      PHRASE.USED := ' ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      BEGIN CASE
         CASE CUR.FILE.NUM = ''
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": should follow a SECONDARY.FILE clause'
         CASE DLMAIN.INFO.FILE.KEY.DICT.CTR(CUR.FILE.NUM) # ''
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": only one KEY clause allowed per relate'
         CASE ITEM.TYPE # 'FIELD' OR (ITEM.FIELD.TYPE # 'I' AND ITEM.FIELD.TYPE # 'D')
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": should be "KEY fieldName"'
         CASE ITEM.FIELD.FILE.NUM # PRIMARY.FILE.NUM
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": field must be a field in the primary file'
         CASE 1
            DICT.FIELD.NAME = ITEM
            DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
            GOSUB ADD.DICT.REC
            DLMAIN.INFO.FILE.KEY.DICT.CTR(CUR.FILE.NUM) = WHICH.DICT.REC.CTR
            FILE.KEY.SM = DICT.RECS(WHICH.DICT.REC.CTR)<6>
            IF FILE.KEY.SM = 'M' THEN
               DLMAIN.INFO.FILE.KEY.IS.MULTIVALUE(CUR.FILE.NUM) = TRUE
               FILE.KEY.ASSOC = DICT.RECS(WHICH.DICT.REC.CTR)<7>
               IF FILE.KEY.ASSOC = '' THEN
                  DICT.RECS(WHICH.DICT.REC.CTR)<7> = DLMAIN.INFO.FILE.NAME.PART.2(CUR.FILE.NUM):'*':DICT.FIELD.NAME
               END
            END ELSE
               DLMAIN.INFO.FILE.KEY.IS.MULTIVALUE(CUR.FILE.NUM) = FALSE
            END
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN


PROCESS.PREPROCESS.ALIAS: 
      PHRASE.USED = ORIG.ITEM
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      PHRASE.USED := ' ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      BEGIN CASE
         CASE CUR.FILE.NUM = ''
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": should follow a SECONDARY.FILE clause'
         CASE ALIAS.SET(CUR.FILE.NUM)
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": only one ALIAS clause allowed per relate'
         CASE 1
            FOUND.ALIAS = FALSE
            FOR TEMP.CTR=1 TO DLMAIN.NUM.FILES UNTIL FOUND.ALIAS
               BEGIN CASE
                  CASE CUR.FILE.NUM = TEMP.CTR
                     NULL
                  CASE DLMAIN.INFO.FILE.ALIAS.LIST<TEMP.CTR> = ITEM
                     FOUND.ALIAS = TRUE
                  CASE DLMAIN.INFO.FILE.ALIAS.LIST<TEMP.CTR> # ''
                     NULL
                  CASE DLMAIN.INFO.FILE.NAME.PART.2(TEMP.CTR) = ITEM
                     FOUND.ALIAS = TRUE
               END CASE
            NEXT TEMP.CTR
            IF FOUND.ALIAS THEN
               DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": alias already used'
            END ELSE
               DLMAIN.INFO.FILE.ALIAS.LIST<CUR.FILE.NUM> = ITEM
               ALIAS.SET(CUR.FILE.NUM) = TRUE
            END
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS.OPTION
*
PROCESS.OPTION: 
      BEGIN CASE
         CASE WHICH.OPTION = 'DISPLAY.COUNT'
            GOSUB PROCESS.OPTION.DISPLAY.COUNT
         CASE WHICH.OPTION = 'NO.DISPLAY.COUNT'
            GOSUB PROCESS.OPTION.NO.DISPLAY.COUNT
         CASE WHICH.OPTION = 'NO.PAGE' OR WHICH.OPTION = 'NOPAGE'
            GOSUB PROCESS.OPTION.NO.PAGE
         CASE WHICH.OPTION = 'PROGRESS.INTERVAL'
            GOSUB PROCESS.OPTION.PROGRESS.INTERVAL
         CASE WHICH.OPTION = 'WRITE.INTERVAL'
            GOSUB PROCESS.OPTION.WRITE.INTERVAL
         CASE WHICH.OPTION = 'PRINT.ERRORS'
            GOSUB PROCESS.OPTION.PRINT.ERRORS
         CASE WHICH.OPTION = 'NO.PRINT.ERRORS'
            GOSUB PROCESS.OPTION.NO.PRINT.ERRORS
         CASE WHICH.OPTION = 'LPTR'
            GOSUB PROCESS.OPTION.LPTR
         CASE WHICH.OPTION = 'DEBUG.LEVEL'
            GOSUB PROCESS.OPTION.DEBUG.LEVEL
         CASE WHICH.OPTION = 'PRINT.LAYOUT'
            GOSUB PROCESS.OPTION.PRINT.LAYOUT
         CASE WHICH.OPTION = 'SAMPLE'
            GOSUB PROCESS.OPTION.SAMPLE
         CASE WHICH.OPTION = 'FROM'
            GOSUB PROCESS.OPTION.FROM
         CASE WHICH.OPTION = 'DEFAULT'
            GOSUB PROCESS.OPTION.DEFAULT
         CASE WHICH.OPTION = 'USING'
            GOSUB PROCESS.OPTION.USING
         CASE WHICH.OPTION = 'FORMAT'
            GOSUB PROCESS.OPTION.FORMAT
         CASE WHICH.OPTION = 'RECORD.ORIENTATION'
            GOSUB PROCESS.OPTION.RECORD.ORIENTATION
         CASE WHICH.OPTION = 'RECORD.LENGTH'
            GOSUB PROCESS.OPTION.RECORD.LENGTH
         CASE WHICH.OPTION = 'NO.LINEFEED'
            GOSUB PROCESS.OPTION.NO.LINEFEED
         CASE WHICH.OPTION = 'FILE'
            GOSUB PROCESS.OPTION.FILE
         CASE WHICH.OPTION = 'BY.EXP'
            GOSUB PROCESS.OPTION.BY.EXP
         CASE WHICH.OPTION = 'WHEN'
            GOSUB PROCESS.OPTION.WHEN
         CASE WHICH.OPTION = 'OVERWRITING'
            GOSUB PROCESS.OPTION.OVERWRITING
         CASE WHICH.OPTION = 'APPEND'
            GOSUB PROCESS.OPTION.APPEND
         CASE WHICH.OPTION = 'HEADING'
            GOSUB PROCESS.OPTION.HEADING
         CASE WHICH.OPTION = 'DETAIL'
            GOSUB PROCESS.OPTION.DETAIL
         CASE WHICH.OPTION = 'HEADING.ON'
            GOSUB PROCESS.OPTION.HEADING.ON
         CASE WHICH.OPTION = 'FOOTING'
            GOSUB PROCESS.OPTION.FOOTING
         CASE WHICH.OPTION = 'FOOTING.ON'
            GOSUB PROCESS.OPTION.FOOTING.ON
         CASE WHICH.OPTION = 'DET.SUP'
            GOSUB PROCESS.OPTION.DET.SUP
         CASE WHICH.OPTION = 'QUOTE.CHAR'
            GOSUB PROCESS.OPTION.QUOTE.CHAR
         CASE WHICH.OPTION = 'EOR.CHAR'
            GOSUB PROCESS.OPTION.EOR.CHAR
         CASE WHICH.OPTION = 'COMMA.CHAR'
            GOSUB PROCESS.OPTION.COMMA.CHAR
         CASE WHICH.OPTION = 'UPCASE'
            GOSUB PROCESS.OPTION.UPCASE
         CASE WHICH.OPTION = 'REMOVE.PUNCTUATION'
            GOSUB PROCESS.OPTION.REMOVE.PUNCTUATION
         CASE WHICH.OPTION = 'FIELD.GAP'
            GOSUB PROCESS.OPTION.FIELD.GAP
         CASE WHICH.OPTION = 'HTML.TITLE'
            GOSUB PROCESS.OPTION.HTML.TITLE
         CASE WHICH.OPTION = 'HTML.TOP'
            GOSUB PROCESS.OPTION.HTML.TOP
         CASE WHICH.OPTION = 'HTML.BOTTOM'
            GOSUB PROCESS.OPTION.HTML.BOTTOM
         CASE WHICH.OPTION = 'HTML.TABLE'
            GOSUB PROCESS.OPTION.HTML.TABLE
         CASE WHICH.OPTION = 'HTML.BODY'
            GOSUB PROCESS.OPTION.HTML.BODY
         CASE WHICH.OPTION = 'XML.FILE.NAME'
            GOSUB PROCESS.OPTION.XML.FILE.NAME
         CASE WHICH.OPTION = 'XML.FILE.ATTRIBUTE'
            GOSUB PROCESS.OPTION.XML.FILE.ATTRIBUTE
         CASE WHICH.OPTION = 'XML.ROOT.NAME'
            GOSUB PROCESS.OPTION.XML.ROOT.NAME
         CASE WHICH.OPTION = 'XML.ROOT.ATTRIBUTE'
            GOSUB PROCESS.OPTION.XML.ROOT.ATTRIBUTE
         CASE WHICH.OPTION = 'XML.ALLOW.PERIODS'
            GOSUB PROCESS.OPTION.XML.ALLOW.PERIODS
         CASE WHICH.OPTION = 'XML.UPCASE'
            GOSUB PROCESS.OPTION.XML.UPCASE
      END CASE
      RETURN


*
*
* PROCESS OPTION "DISPLAY.COUNT"
*
PROCESS.OPTION.DISPLAY.COUNT: 
      DLMAIN.DISPLAY.COUNT = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "NO.DISPLAY.COUNT"
*
PROCESS.OPTION.NO.DISPLAY.COUNT: 
      DLMAIN.DISPLAY.COUNT = FALSE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "NO.PAGE"
*
PROCESS.OPTION.NO.PAGE: 
      DLMAIN.HAVE.NO.PAGE = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN



*
*
* PROCESS OPTION "PROGRESS.INTERVAL"
*
PROCESS.OPTION.PROGRESS.INTERVAL: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            DLMAIN.PROGRESS.INTERVAL = ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be a number greater than 0'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.PROGRESS.INTERVAL = DEFAULT.PROGRESS.INTERVAL
      END
      RETURN


*
*
* PROCESS OPTION "WRITE.INTERVAL"
*
PROCESS.OPTION.WRITE.INTERVAL: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            DLMAIN.WRITE.INTERVAL = ITEM
            GOSUB GET.NEXT.ITEM
            IF ITEM.TYPE = '' THEN
               IF NUM(ITEM) AND ITEM > -1 THEN
                  DLMAIN.WRITE.SLEEP.TIME = ITEM
               END ELSE
                  DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be a number greater than -1'
               END
            END
         END ELSE
            DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be a number greater than 0'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.WRITE.INTERVAL = DEFAULT.WRITE.INTERVAL
         DLMAIN.WRITE.SLEEP.TIME = DEFAULT.WRITE.SLEEP.TIME
      END
      RETURN


*
*
* PROCESS OPTION "PRINT.ERRORS"
*
PROCESS.OPTION.PRINT.ERRORS: 
      DLMAIN.PRINT.ERRORS = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "NO.PRINT.ERRORS"
*
PROCESS.OPTION.NO.PRINT.ERRORS: 
      DLMAIN.PRINT.ERRORS = FALSE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "LPTR"
*
PROCESS.OPTION.LPTR: 
      DLMAIN.LPTR = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "DEBUG.LEVEL"
*
PROCESS.OPTION.DEBUG.LEVEL: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            DLMAIN.DEBUG.LEVEL = ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be a number greater than 0'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.DEBUG.LEVEL = DEFAULT.DEBUG.LEVEL
      END
      RETURN


*
*
* PROCESS OPTION "XML.ALLOW.PERIODS"
*
PROCESS.OPTION.XML.ALLOW.PERIODS: 
      XML.ALLOW.PERIODS = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "XML.UPCASE"
*
PROCESS.OPTION.XML.UPCASE: 
      XML.UPCASE = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "PRINT.LAYOUT"
*
PROCESS.OPTION.PRINT.LAYOUT: 
      DLMAIN.PRINT.LAYOUT = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "SAMPLE"
*
PROCESS.OPTION.SAMPLE: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            DLMAIN.SAMPLE.SIZE = ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be a number greater than 0'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.SAMPLE.SIZE = DEFAULT.DLMAIN.SAMPLE.SIZE
      END
      RETURN


*
*
* PROCESS OPTION "FROM"
*
PROCESS.OPTION.FROM: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' must be followed by a select list number from '
      TEMP.ERRMSG := '0 to ':DBMS.HIGHEST.SELECT.UNIT
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF ITEM >= 0 AND ITEM <= DBMS.HIGHEST.SELECT.UNIT THEN
            DLMAIN.FROM.UNIT = ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
*
* PROCESS OPTION "DEFAULT"
*
PROCESS.OPTION.DEFAULT: 
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE # 'QUALIFIER' THEN
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be followed by a valid field qualifier, not ':ITEM
         RETURN
      END
      LOCATE WHICH.QUALIFIER IN QUALIFIERS.WITH.NO.DEFAULT<1> SETTING TEMP.POS THEN
         DLMAIN.ERRMSG<-1> = 'There is no default value for ':ITEM
         RETURN
      END
      CHECK.QUALIFIER = WHICH.QUALIFIER
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEMS.DONE THEN
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a value'
         RETURN
      END
      BEGIN CASE
         CASE CHECK.QUALIFIER = 'LINE'
            GOSUB PROCESS.DEFAULT.LINE
         CASE CHECK.QUALIFIER = 'FMT'
            GOSUB PROCESS.DEFAULT.FMT
         CASE CHECK.QUALIFIER = 'CONV'
            GOSUB PROCESS.DEFAULT.CONV
         CASE CHECK.QUALIFIER = 'HTML.START'
            GOSUB PROCESS.DEFAULT.HTML.START
         CASE CHECK.QUALIFIER = 'HTML.END'
            GOSUB PROCESS.DEFAULT.HTML.END
         CASE CHECK.QUALIFIER = 'HTML.CELL'
            GOSUB PROCESS.DEFAULT.HTML.CELL
         CASE CHECK.QUALIFIER = 'HTML.ROW'
            GOSUB PROCESS.DEFAULT.HTML.ROW
         CASE CHECK.QUALIFIER = 'NUM.VALUES'
            GOSUB PROCESS.DEFAULT.NUM.VALUES
         CASE CHECK.QUALIFIER = 'NUM.SUBVALUES'
            GOSUB PROCESS.DEFAULT.NUM.SUBVALUES
         CASE CHECK.QUALIFIER = 'LENGTH'
            GOSUB PROCESS.DEFAULT.LENGTH
         CASE CHECK.QUALIFIER = 'BEG.COL'
            GOSUB PROCESS.DEFAULT.BEG.COL
         CASE CHECK.QUALIFIER = 'MV.ORIENTATION'
            GOSUB PROCESS.DEFAULT.MV.ORIENTATION
         CASE CHECK.QUALIFIER = 'VALUE.SEPARATOR'
            GOSUB PROCESS.DEFAULT.VALUE.SEPARATOR
         CASE CHECK.QUALIFIER = 'SUBVALUE.SEPARATOR'
            GOSUB PROCESS.DEFAULT.SUBVALUE.SEPARATOR
         CASE CHECK.QUALIFIER = 'DEFAULT.VALUE'
            GOSUB PROCESS.DEFAULT.DEFAULT.VALUE
      END CASE
      RETURN
*
* PROCESS "DEFAULT NUM.VALUES"
*
PROCESS.DEFAULT.NUM.VALUES: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a number greater than 0 or "ALL"'
      IF ITEM.TYPE = '' OR (ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.ALL) THEN
         BEGIN CASE
            CASE ITEM.KEYWORD = KEYWORD.ALL
               DEFAULT.NUM.VALUES = 'ALL'
               SET.DEFAULT.NUM.VALUES = TRUE
            CASE NUM(ITEM) AND ITEM > 0
               DEFAULT.NUM.VALUES = ITEM
               SET.DEFAULT.NUM.VALUES = TRUE
            CASE 1
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
* PROCESS "DEFAULT NUM.SUBVALUES"
*
PROCESS.DEFAULT.NUM.SUBVALUES: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a number greater than 0 or "ALL"'
      IF ITEM.TYPE = '' OR (ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.ALL) THEN
         BEGIN CASE
            CASE ITEM.KEYWORD = KEYWORD.ALL
               DEFAULT.NUM.SUBVALUES = 'ALL'
               SET.DEFAULT.NUM.SUBVALUES = TRUE
            CASE NUM(ITEM) AND ITEM > 0
               DEFAULT.NUM.SUBVALUES = ITEM
               SET.DEFAULT.NUM.SUBVALUES = TRUE
            CASE 1
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
* PROCESS "DEFAULT MV.ORIENTATION"
*
PROCESS.DEFAULT.MV.ORIENTATION: 
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' specified must be in this list: "':ORIENTATION.TYPE.LIST:'"'
      CONVERT @FM:@VM:@SM TO '   ' IN TEMP.ERRMSG
      LOCATE ITEM IN ORIENTATION.TYPE.LIST<1> SETTING POS THEN
         DEFAULT.MV.ORIENTATION = ITEM
         ITEM.TYPE = ''
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
* PROCESS "DEFAULT VALUE.SEPARATOR"
*
PROCESS.DEFAULT.VALUE.SEPARATOR: 
      DEFAULT.VALUE.SEPARATOR = ITEM
      SET.DEFAULT.VALUE.SEPARATOR = TRUE
      ITEM.TYPE = ''
      GOSUB GET.NEXT.ITEM
      RETURN


*
* PROCESS "DEFAULT SUBVALUE.SEPARATOR"
*
PROCESS.DEFAULT.SUBVALUE.SEPARATOR: 
      DEFAULT.SUBVALUE.SEPARATOR = ITEM
      SET.DEFAULT.SUBVALUE.SEPARATOR = TRUE
      ITEM.TYPE = ''
      GOSUB GET.NEXT.ITEM
      RETURN


*
* PROCESS "DEFAULT DEFAULT.VALUE"
*
PROCESS.DEFAULT.DEFAULT.VALUE: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a value to use.'
      BEGIN CASE
         CASE ITEM # '' AND ITEM.KEYWORD = ''
            DEFAULT.DEFAULT.VALUE = ITEM
         CASE 1
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN
*
* PROCESS "DEFAULT LINE"
*
PROCESS.DEFAULT.LINE: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a number greater than 0'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE NUM(ITEM) AND ITEM > 0
               DEFAULT.LINE = ITEM
            CASE 1
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
* PROCESS "DEFAULT BEG.COL"
*
PROCESS.DEFAULT.BEG.COL: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a number greater than 0'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE NUM(ITEM) AND ITEM > 0
               DEFAULT.BEG.COL = ITEM
            CASE 1
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
* PROCESS "DEFAULT LENGTH"
*
PROCESS.DEFAULT.LENGTH: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a number greater than 0'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE NUM(ITEM) AND ITEM > 0
               DEFAULT.LENGTH = ITEM
            CASE 1
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
* PROCESS "DEFAULT FMT"
*
PROCESS.DEFAULT.FMT: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a valid FMT code or ""'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE ITEM = ''
               DEFAULT.FMT = NULL.CODE
            CASE 1
               TEST = FMT('',ITEM)
               IF STATUS() THEN
                  DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
               END ELSE
                  DEFAULT.FMT = ITEM
               END
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
* PROCESS "DEFAULT CONV"
*
PROCESS.DEFAULT.CONV: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a valid CONV code or ""'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE ITEM = ''
               DEFAULT.CONV = NULL.CODE
            CASE 1
               TEST = OCONV('',ITEM)
               IF STATUS() THEN
                  DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
               END ELSE
                  DEFAULT.CONV = ITEM
               END
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
* PROCESS "DEFAULT HTML.START"
*
PROCESS.DEFAULT.HTML.START: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by valid HTML code.'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE ITEM = ''
               DEFAULT.HTML.START = NULL.CODE
            CASE 1
               DEFAULT.HTML.START = ITEM
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
* PROCESS "DEFAULT HTML.END"
*
PROCESS.DEFAULT.HTML.END: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by valid HTML code.'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE ITEM = ''
               DEFAULT.HTML.END = NULL.CODE
            CASE 1
               DEFAULT.HTML.END = ITEM
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
* PROCESS "DEFAULT HTML.CELL"
*
PROCESS.DEFAULT.HTML.CELL: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by valid HTML code.'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE ITEM = ''
               DEFAULT.HTML.CELL = NULL.CODE
            CASE 1
               DEFAULT.HTML.CELL = ITEM
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
* PROCESS "DEFAULT HTML.ROW"
*
PROCESS.DEFAULT.HTML.ROW: 
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by valid HTML code.'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE ITEM = ''
               DEFAULT.HTML.ROW = NULL.CODE
            CASE 1
               DEFAULT.HTML.ROW = ITEM
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
*
* PROCESS OPTION "USING"
*
PROCESS.OPTION.USING: 
      DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' may only be specified once on the command line'
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "FORMAT"
*
PROCESS.OPTION.FORMAT: 
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' specified must be in this list: "':FORMAT.TYPE.LIST<1>:'"'
      CONVERT @FM:@VM:@SM TO '   ' IN TEMP.ERRMSG
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEMS.DONE THEN
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         DLMAIN.FATAL.ERROR = TRUE
      END ELSE
         LOCATE ITEM IN FORMAT.TYPE.LIST<1,1> SETTING POS THEN
            DLMAIN.FORMAT = FORMAT.TYPE.LIST<2,POS>
            ITEM.TYPE = ''
            GOSUB GET.NEXT.ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      RETURN


*
*
* PROCESS OPTION "RECORD.ORIENTATION"
*
PROCESS.OPTION.RECORD.ORIENTATION: 
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' specified must be in this list: "':ORIENTATION.TYPE.LIST:'"'
      CONVERT @FM:@VM:@SM TO '   ' IN TEMP.ERRMSG
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEMS.DONE THEN
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         DLMAIN.FATAL.ERROR = TRUE
      END ELSE
         LOCATE ITEM IN ORIENTATION.TYPE.LIST<1> SETTING POS THEN
            DLMAIN.RECORD.ORIENTATION = ITEM
            ITEM.TYPE = ''
            GOSUB GET.NEXT.ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      RETURN


*
*
* PROCESS OPTION "RECORD.LENGTH"
*
PROCESS.OPTION.RECORD.LENGTH: 
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' specified must be a positive number'
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEMS.DONE THEN
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         DLMAIN.FATAL.ERROR = TRUE
      END ELSE
         IF NUM(ITEM) AND ITEM > 0 THEN
            DLMAIN.RECORD.LENGTH = ITEM
            ITEM.TYPE = ''
            GOSUB GET.NEXT.ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      RETURN


*
*
* PROCESS OPTION "NO.LINEFEED"
*
PROCESS.OPTION.NO.LINEFEED: 
      GOSUB GET.NEXT.ITEM
      DLMAIN.NO.LINEFEED = TRUE
      RETURN


*
*
* PROCESS OPTION "FILE"
*
PROCESS.OPTION.FILE: 
      LOOKUP.FIELD.NAME = FALSE
      LOOKUP.FILE.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      TEMP.ERRMSG = 'Invalid syntax "':ORIGINAL.ITEM:' ':ITEM.QUOTED:ITEM:ITEM.QUOTED:'": should be "':ORIGINAL.ITEM:' Type1FileName RecordInFile"'
      IF ITEM.TYPE = 'TYPE1.FILE' OR ITEM.TYPE = 'FILE' THEN
         DLMAIN.TYPE1.FILE.NAME = ITEM
         LOOKUP.FIELD.NAME = FALSE
         GOSUB GET.NEXT.ITEM
         IF ITEMS.DONE THEN
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END ELSE
            DLMAIN.TYPE1.RECORD.NAME = ITEM
            IF DLMAIN.DEBUG.LEVEL GT 0 THEN
               CRT 'Writing to ':DLMAIN.TYPE1.FILE.NAME:' ':DLMAIN.TYPE1.RECORD.NAME
            END
            GOSUB GET.NEXT.ITEM
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
*
* PROCESS OPTION "BY.EXP"
*
PROCESS.OPTION.BY.EXP: 
      IF BY.EXP.FIELD = '' THEN
         GOSUB GET.NEXT.ITEM
         IF ITEM.TYPE = 'FIELD' THEN
            GOSUB PO.BY.EXP.FIELD
         END ELSE
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':ORIGINAL.ITEM:' ':ITEM:'": should be "':ORIGINAL.ITEM:' multi-valuedField"'
         END
      END ELSE
         GOSUB GET.NEXT.ITEM
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' may only be specified once on the command line'
      END
      RETURN


*
*
* PROCESS OPTION 'BY.EXP field' handle a field
*
PO.BY.EXP.FIELD: 
      ITEM.SM = DICT.REC<6>
      IF (ITEM.FIELD.TYPE = 'I' OR ITEM.FIELD.TYPE = 'D') AND ITEM.SM = 'M' THEN
         GOSUB CHECK.ASSOC.NAME
         IF WHEN.ASSOC.NAME.IS.OKAY THEN
            BY.EXP.FIELD = ITEM
            DICT.FIELD.NAME = ITEM
            DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
            GOSUB ADD.DICT.REC
            BY.EXP.DICT.CTR = WHICH.DICT.REC.CTR
            WHEN.ASSOC.CONTROL.DICT.CTR = WHICH.DICT.REC.CTR
         END ELSE
            IF WHEN.ASSOC.NAME.IS.FIELD.NAME THEN
               DLMAIN.ERRMSG<-1> = 'The field "':ITEM:'" and "':WHEN.ASSOC.NAME:'" are not associated'
            END ELSE
               DLMAIN.ERRMSG<-1> = 'The association name "':DICT.REC<7>:'" in "':ORIGINAL.ITEM:' ':ITEM:'"'
               DLMAIN.ERRMSG<-1> = '     does not match the association name "':WHEN.ASSOC.NAME:'" already being used'
            END
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':ORIGINAL.ITEM:' ':ITEM:'": should be "':ORIGINAL.ITEM:' multi-valuedField"'
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* ADD DICT.REC
*
ADD.DICT.REC: 
      LOCATE DICT.FIELD.NAME IN DICT.REC.FIELD.LIST<1> SETTING WHICH.DICT.REC.CTR ELSE
         NUM.DICT.RECS += 1
         IF NUM.DICT.RECS > DLMAX.DICT.RECS THEN
            DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many dictionary items: ':NUM.DICT.RECS
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
         DICT.RECS(NUM.DICT.RECS) = DICT.REC
         DICT.REC.FIELD.LIST<NUM.DICT.RECS> = DICT.FIELD.NAME
         DICT.REC.FILE.NUM(NUM.DICT.RECS) = ITEM.FIELD.FILE.NUM
         WHICH.DICT.REC.CTR = NUM.DICT.RECS
         IF DLMAIN.INFO.FILE.KEY.IS.MULTIVALUE(ITEM.FIELD.FILE.NUM) AND ITEM.FIELD.FILE.NUM # PRIMARY.FILE.NUM THEN
            FILE.KEY.ASSOC = DICT.RECS(DLMAIN.INFO.FILE.KEY.DICT.CTR(ITEM.FIELD.FILE.NUM))<7>
            DICT.RECS(NUM.DICT.RECS)<7> = FILE.KEY.ASSOC
         END
      END
      RETURN


*
*
* CHECK WHEN.ASSOC NAME
*
CHECK.ASSOC.NAME: 
      WHEN.ASSOC.NAME.IS.OKAY = FALSE
      DICT.ASSOC.NAME = DICT.REC<7>
      IF WHEN.ASSOC.NAME = '' THEN
         WHEN.ASSOC.NAME.IS.OKAY = TRUE
         IF DICT.ASSOC.NAME = '' THEN
            WHEN.ASSOC.NAME = ITEM
            WHEN.ASSOC.NAME.IS.FIELD.NAME = TRUE
         END ELSE
            WHEN.ASSOC.NAME = DICT.ASSOC.NAME
            WHEN.ASSOC.NAME.IS.FIELD.NAME = FALSE
         END
      END ELSE
         IF WHEN.ASSOC.NAME.IS.FIELD.NAME THEN
            IF WHEN.ASSOC.NAME = ITEM THEN
               WHEN.ASSOC.NAME.IS.OKAY = TRUE
            END
         END ELSE
            IF WHEN.ASSOC.NAME = DICT.ASSOC.NAME THEN
               WHEN.ASSOC.NAME.IS.OKAY = TRUE
            END
         END
      END
      RETURN


*
*
* PROCESS OPTION "WHEN"
*
PROCESS.OPTION.WHEN: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE # 'FIELD' THEN
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':ORIGINAL.ITEM:' ':ITEM:'": should be "':ORIGINAL.ITEM:' multi-valuedField operator value"'
         DLMAIN.FATAL.ERROR = TRUE
         RETURN
      END
*
      ITEM.SM = DICT.REC<6>
      IF ITEM.SM # 'M' OR (ITEM.FIELD.TYPE # 'I' AND ITEM.FIELD.TYPE # 'D') THEN
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':ORIGINAL.ITEM:' ':ITEM:'": should be "':ORIGINAL.ITEM:' multi-valuedField operator value"'
         DLMAIN.FATAL.ERROR = TRUE
         GOSUB GET.NEXT.ITEM
         RETURN
      END
      GOSUB CHECK.ASSOC.NAME
      IF NOT(WHEN.ASSOC.NAME.IS.OKAY) THEN
         IF WHEN.ASSOC.NAME.IS.FIELD.NAME THEN
            DLMAIN.ERRMSG<-1> = 'The field "':ITEM:'" and "':WHEN.ASSOC.NAME:'" are not associated'
            DLMAIN.FATAL.ERROR = TRUE
         END ELSE
            DLMAIN.ERRMSG<-1> = 'The association name "':DICT.REC<7>:'" in "':ORIGINAL.ITEM:' ':ITEM:'"'
            DLMAIN.ERRMSG<-1> = '     does not match the association name "':WHEN.ASSOC.NAME:'" already being used'
         END
         GOSUB GET.NEXT.ITEM
         RETURN
      END
*
      SAVE.FIELD = ITEM
      SAVE.FILE.NUM = ITEM.FIELD.FILE.NUM
      SAVE.DICT.REC = DICT.REC
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE # 'OPERATOR' THEN
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':ORIGINAL.ITEM:' ':ITEM:'": should be "':ORIGINAL.ITEM:' multi-valuedField operator value"'
         DLMAIN.ERRMSG<-1> = '     "':ITEM:'" is not a valid operator'
         DLMAIN.FATAL.ERROR = TRUE
         RETURN
      END
      SAVE.OPERATOR = WHICH.OPERATOR
      GOSUB GET.NEXT.ITEM
      BEGIN CASE
         CASE ITEM.TYPE = 'FIELD' AND (ITEM.FIELD.TYPE = 'I' OR ITEM.FIELD.TYPE = 'D')
            SAVE.VALUE.IS.FIELD = TRUE
            DICT.FIELD.NAME = ITEM
            DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
            GOSUB ADD.DICT.REC
            SAVE.VALUE.LIST = WHICH.DICT.REC.CTR
            GOSUB GET.NEXT.ITEM
         CASE ITEM.TYPE = ''
            SAVE.VALUE.IS.FIELD = FALSE
            SAVE.VALUE.LIST = ITEM
            LOOP
               GOSUB GET.NEXT.ITEM
            UNTIL ITEM.TYPE # '' OR ITEMS.DONE
               SAVE.VALUE.LIST := @VM:ITEM
            REPEAT
         CASE 1
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':ORIGINAL.ITEM
            DLMAIN.ERRMSG := ' ':SAVE.FIELD:' ':SAVE.OPERATOR:' ':ITEM:'"'
            DLMAIN.ERRMSG := ' should be "':ORIGINAL.ITEM:' multi-valuedField operator value"'
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
      END CASE
*
* ADD TO LIST OF "WHEN" FIELDS
*
      NUM.WHEN.FIELDS += 1
      WHEN.FIELD.LIST<NUM.WHEN.FIELDS> = SAVE.FIELD
      WHEN.OPERATOR.LIST<NUM.WHEN.FIELDS> = SAVE.OPERATOR
      WHEN.CHECK.VALUE.IS.FIELD.LIST<NUM.WHEN.FIELDS> = SAVE.VALUE.IS.FIELD
      WHEN.CHECK.VALUE.LIST<NUM.WHEN.FIELDS> = SAVE.VALUE.LIST
*
      LAST.DICT.REC = DICT.REC
      LAST.DICT.FIELD.NAME = DICT.FIELD.NAME
      LAST.DICT.FILE.NUM = DICT.FILE.NUM
      DICT.REC = SAVE.DICT.REC
      DICT.FIELD.NAME = SAVE.FIELD
      DICT.FILE.NUM = SAVE.FILE.NUM
      GOSUB ADD.DICT.REC
      DICT.REC = LAST.DICT.REC
      DICT.FIELD.NAME = LAST.DICT.FIELD.NAME
      DICT.FILE.NUM = LAST.DICT.FILE.NUM
      WHEN.DICT.CTR.LIST<NUM.WHEN.FIELDS> = WHICH.DICT.REC.CTR
      IF NOT(WHEN.ASSOC.CONTROL.DICT.CTR) THEN
         WHEN.ASSOC.CONTROL.DICT.CTR = WHICH.DICT.REC.CTR
      END
      RETURN


*
*
* PROCESS OPTION "UPCASE"
*
PROCESS.OPTION.UPCASE: 
      DLMAIN.UPCASE = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
* PROCESS OPTION "REMOVE.PUNCTUATION"
*
PROCESS.OPTION.REMOVE.PUNCTUATION: 
      DLMAIN.REMOVE.PUNCTUATION = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "FIELD.GAP"
*
PROCESS.OPTION.FIELD.GAP: 
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' specified must be a non-negative integer.'
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEMS.DONE THEN
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         DLMAIN.FATAL.ERROR = TRUE
      END ELSE
         IF NUM(ITEM) AND (INT(ITEM) EQ ITEM) AND (ITEM GE 0) THEN
            DLMAIN.FIELD.GAP = ITEM
            ITEM.TYPE = ''
            GOSUB GET.NEXT.ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      RETURN


*
*
* PROCESS OPTION "OVERWRITING"
*
PROCESS.OPTION.OVERWRITING: 
      DLMAIN.OVERWRITING = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "APPEND"
*
PROCESS.OPTION.APPEND: 
      DLMAIN.APPEND = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "HEADING"
*
PROCESS.OPTION.HEADING: 
      IF DLMAIN.HEADING.OUT.REC # '' THEN
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' may be specified only once.'
         GOSUB GET.NEXT.ITEM
         RETURN
      END ELSE
         NUM.OUT.RECS += 1
         IF NUM.OUT.RECS > DLMAX.OUT.RECS THEN
            DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many output records: ':NUM.OUT.RECS
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
         CUR.OUT.REC = NUM.OUT.RECS
         DLMAIN.HEADING.OUT.REC = NUM.OUT.RECS
         GOSUB GET.NEXT.ITEM
      END
      RETURN


*
*
* PROCESS OPTION "DETAIL"
*
PROCESS.OPTION.DETAIL: 
      CUR.OUT.REC = DETAIL.OUT.REC
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "HEADING.ON"
*
PROCESS.OPTION.HEADING.ON: 
      GOSUB GET.NEXT.ITEM
      PHRASE.USED = ORIGINAL.ITEM:' ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      TEMP.ERRMSG = 'Invalid syntax "':PHRASE.USED:'" should be "':ORIGINAL.ITEM:' BreakField"'
      HAVE.VALID.HEADING = FALSE
      BEGIN CASE
         CASE ITEM.TYPE = 'FIELD'
            DICT.FIELD.NAME = ITEM
            DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
            GOSUB ADD.DICT.REC
            LOCATE WHICH.DICT.REC.CTR IN DLMAIN.BREAK.DICT.CTR.LIST<1> SETTING BREAK.LIST.CTR THEN
               IF DLMAIN.BREAK.HEADING.OUT.REC.LIST<BREAK.LIST.CTR> # '' THEN
                  TEMP.ERRMSG = PHRASE.USED:' may be specified only once.'
               END ELSE
                  HAVE.VALID.HEADING = TRUE
                  NUM.OUT.RECS += 1
                  IF NUM.OUT.RECS > DLMAX.OUT.RECS THEN
                     DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many output records: ':NUM.OUT.RECS
                     DLMAIN.FATAL.ERROR = TRUE
                     RETURN
                  END
                  CUR.OUT.REC = NUM.OUT.RECS
                  DLMAIN.BREAK.HEADING.OUT.REC.LIST<BREAK.LIST.CTR> = NUM.OUT.RECS
                  GOSUB GET.NEXT.ITEM
               END
            END
      END CASE
      IF NOT(HAVE.VALID.HEADING) THEN
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
*
* PROCESS OPTION "FOOTING"
*
PROCESS.OPTION.FOOTING: 
      IF DLMAIN.FOOTING.OUT.REC # '' THEN
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' may be specified only once.'
      END ELSE
         NUM.OUT.RECS += 1
         IF NUM.OUT.RECS > DLMAX.OUT.RECS THEN
            DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many output records: ':NUM.OUT.RECS
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
         CUR.OUT.REC = NUM.OUT.RECS
         DLMAIN.FOOTING.OUT.REC = NUM.OUT.RECS
         GOSUB GET.NEXT.ITEM
      END
      RETURN


*
*
* PROCESS OPTION "FOOTING.ON"
*
PROCESS.OPTION.FOOTING.ON: 
      GOSUB GET.NEXT.ITEM
      PHRASE.USED = ORIGINAL.ITEM:' ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      BREAK.LIST.CTR = ''
      BEGIN CASE
         CASE ITEM.TYPE = 'FIELD'
            DICT.FIELD.NAME = ITEM
            DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
            GOSUB ADD.DICT.REC
            LOCATE WHICH.DICT.REC.CTR IN DLMAIN.BREAK.DICT.CTR.LIST<1> SETTING BREAK.LIST.CTR ELSE
               BREAK.LIST.CTR = ''
            END
         CASE ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.FINAL
            BREAK.LIST.CTR = 1
            IF DLMAIN.NUM.BREAK.FIELDS = 0 THEN
               DLMAIN.NUM.BREAK.FIELDS += 1
               DLMAIN.BREAK.DICT.CTR.LIST<DLMAIN.NUM.BREAK.FIELDS> = 'ALL'
            END
         CASE ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.ALL
            BREAK.LIST.CTR = 'ALL'
            NUM.OUT.RECS += 1
            IF NUM.OUT.RECS > DLMAX.OUT.RECS THEN
               DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many output records: ':NUM.OUT.RECS
               DLMAIN.FATAL.ERROR = TRUE
               RETURN
            END
            CUR.OUT.REC = NUM.OUT.RECS
            DEFAULT.OUT.REC = NUM.OUT.RECS
      END CASE
      IF NOT(BREAK.LIST.CTR) THEN
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'" should be:'
         DLMAIN.ERRMSG<-1> = '"':ORIGINAL.ITEM:' BreakField | ALL | FINAL" [NONE]'
         RETURN
      END
*
      GOSUB GET.NEXT.ITEM
      IF BREAK.LIST.CTR = 'ALL' THEN
         IF ITEM = KEYWORD.NONE THEN
            DEFAULT.OUT.REC = KEYWORD.NONE
            GOSUB GET.NEXT.ITEM
         END
      END ELSE
         IF DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> # '' THEN
            DLMAIN.ERRMSG<-1> = PHRASE.USED:' may be specified only once.'
         END ELSE
            IF ITEM = KEYWORD.NONE THEN
               DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> = KEYWORD.NONE
               GOSUB GET.NEXT.ITEM
            END ELSE
               NUM.OUT.RECS += 1
               IF NUM.OUT.RECS > DLMAX.OUT.RECS THEN
                  DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many output records: ':NUM.OUT.RECS
                  DLMAIN.FATAL.ERROR = TRUE
                  RETURN
               END
               CUR.OUT.REC = NUM.OUT.RECS
               DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> = NUM.OUT.RECS
            END
         END
      END
      RETURN


*
*
* PROCESS OPTION "DET.SUP"
*
PROCESS.OPTION.DET.SUP: 
      IF DLMAIN.DET.SUP THEN
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' may be specified only once.'
      END ELSE
         DLMAIN.DET.SUP = TRUE
      END
      GOSUB GET.NEXT.ITEM
      RETURN



PROCESS.OPTION.QUOTE.CHAR: 
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      DLMAIN.QUOTE = ITEM[1,1]
      GOSUB GET.NEXT.ITEM
      RETURN



PROCESS.OPTION.COMMA.CHAR: 
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      COUNT.CARATS = COUNT(ITEM,'^')
      DLMAIN.COMMA = FIELD(ITEM,'^',1,1)
      FOR WHICH.CARAT = 2 TO COUNT.CARATS+1
         TEST.VALUE = FIELD(ITEM,'^',WHICH.CARAT,1)
         IF NUM(TEST.VALUE) AND TEST.VALUE # '' THEN
            DLMAIN.COMMA := CHAR(TEST.VALUE)
         END ELSE
            DLMAIN.COMMA := TEST.VALUE
         END
      NEXT WHICH.CARAT
      GOSUB GET.NEXT.ITEM
      RETURN

PROCESS.OPTION.EOR.CHAR: 
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      COUNT.CARATS = COUNT(ITEM,'^')
      DLMAIN.EOR = FIELD(ITEM,'^',1,1)
      FOR WHICH.CARAT = 2 TO COUNT.CARATS+1
         TEST.VALUE = FIELD(ITEM,'^',WHICH.CARAT,1)
         IF NUM(TEST.VALUE) AND TEST.VALUE # '' THEN
            DLMAIN.EOR := CHAR(TEST.VALUE)
         END ELSE
            DLMAIN.EOR := TEST.VALUE
         END
      NEXT WHICH.CARAT
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "HTML.TITLE"
*
PROCESS.OPTION.HTML.TITLE: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            DLMAIN.ERRMSG<-1> = 'Expecting HTML title, found nothing.'
         END ELSE
            DL.OUTR.DOCUMENT.TITLE = ITEM
            GOSUB GET.NEXT.ITEM
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Expecting HTML title, found "':ITEM:'"'
      END
      RETURN


*
*
* PROCESS OPTION "HTML.TOP"
*
PROCESS.OPTION.HTML.TOP: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            DLMAIN.ERRMSG<-1> = 'Expecting HTML top, found nothing.'
         END ELSE
            DL.OUTR.DOCUMENT.TOP = ITEM
            GOSUB GET.NEXT.ITEM
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Expecting HTML top, found "':ITEM:'"'
      END
      RETURN


*
*
* PROCESS OPTION "HTML.BOTTOM"
*
PROCESS.OPTION.HTML.BOTTOM: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            DLMAIN.ERRMSG<-1> = 'Expecting HTML bottom, found nothing.'
         END ELSE
            DL.OUTR.DOCUMENT.BOTTOM = ITEM
            GOSUB GET.NEXT.ITEM
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Expecting HTML bottom, found "':ITEM:'"'
      END
      RETURN


*
*
* PROCESS OPTION "HTML.TABLE"
*
PROCESS.OPTION.HTML.TABLE: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            DLMAIN.ERRMSG<-1> = 'Expecting HTML table, found nothing.'
         END ELSE
            DL.OUTR.DOCUMENT.TABLE = ITEM
            GOSUB GET.NEXT.ITEM
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Expecting HTML table, found "':ITEM:'"'
      END
      RETURN


*
*
* PROCESS OPTION "HTML.BODY"
*
PROCESS.OPTION.HTML.BODY: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            DLMAIN.ERRMSG<-1> = 'Expecting HTML body, found nothing.'
         END ELSE
            DL.OUTR.DOCUMENT.BODY = ITEM
            GOSUB GET.NEXT.ITEM
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Expecting HTML body, found "':ITEM:'"'
      END
      RETURN



*
*
* PROCESS OPTION "XML.FILE.NAME"
*
PROCESS.OPTION.XML.FILE.NAME: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            DLMAIN.ERRMSG<-1> = 'Expecting XML file name, found nothing.'
         END ELSE
            X.ITEM.OUT = ''
            X.DO.LOWER.CASE = FALSE
            CALL DLXMLELEM(X.ITEM.OUT,ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML file name "':ITEM:'" does not generate a valid XML name.'
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               OUT.XML.FILE.NAME = X.ITEM.OUT
            END
            GOSUB GET.NEXT.ITEM
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Expecting XML file name, found "':ITEM:'"'
      END
      RETURN



*
*
* PROCESS OPTION "XML.ROOT.NAME"
*
PROCESS.OPTION.XML.ROOT.NAME: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            DLMAIN.ERRMSG<-1> = 'Expecting XML root name, found nothing.'
         END ELSE
            X.ITEM.OUT = ''
            X.DO.LOWER.CASE = FALSE
            CALL DLXMLELEM(X.ITEM.OUT,ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML root name "':ITEM:'" does not generate a valid XML name.'
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               OUT.XML.ROOT.NAME = X.ITEM.OUT
            END
            GOSUB GET.NEXT.ITEM
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Expecting XML root name, found "':ITEM:'"'
      END
      RETURN


*
*
* PROCESS OPTION "XML.ROOT.ATTRIBUTE"
*
PROCESS.OPTION.XML.ROOT.ATTRIBUTE: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            DLMAIN.ERRMSG<-1> = 'Expecting XML root attribute, found nothing.'
         END ELSE
            OUT.XML.ROOT.ATTRIBUTE = ITEM
            GOSUB GET.NEXT.ITEM
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Expecting XML root attribute, found "':ITEM:'"'
      END
      RETURN


*
*
* PROCESS OPTION "XML.FILE.ATTRIBUTE"
*
PROCESS.OPTION.XML.FILE.ATTRIBUTE: 
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            DLMAIN.ERRMSG<-1> = 'Expecting XML file attribute, found nothing.'
         END ELSE
            OUT.XML.FILE.ATTRIBUTE = ITEM
            GOSUB GET.NEXT.ITEM
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Expecting XML file attribute, found "':ITEM:'"'
      END
      RETURN


*
*
* PROCESS.MISC.FIELD
*
PROCESS.MISC.FIELD: 
      BEGIN CASE
         CASE WHICH.MISC.FIELD = 'LITERAL'
            GOSUB PROCESS.MISC.FIELD.LITERAL
         CASE WHICH.MISC.FIELD = 'SUBR'
            GOSUB PROCESS.MISC.FIELD.SUBR
      END CASE
      RETURN


*
*
* PROCESS MISC.FIELD "LITERAL"
*
PROCESS.MISC.FIELD.LITERAL: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         GOSUB PROCESS.MISC.FIELD.LITERAL.OPTION
         DLMAIN.NUM.LITERAL.VALUES += 1
         DLMAIN.LITERAL.VALUE.LIST<DLMAIN.NUM.LITERAL.VALUES> = ITEM
         NUM.OUT.FIELDS(CUR.OUT.REC) += 1
         CUR.OUT.FIELD.CTR = NUM.OUT.FIELDS(CUR.OUT.REC)
         OUT.FIELD.LIST(CUR.OUT.REC)<NUM.OUT.FIELDS(CUR.OUT.REC)> = 'LITERAL ':ITEM.QUOTED:ITEM:ITEM.QUOTED
         OUT.TYPE.LIST(CUR.OUT.REC)<NUM.OUT.FIELDS(CUR.OUT.REC)> = 'LITERAL'
         OUT.CTR.LIST(CUR.OUT.REC)<NUM.OUT.FIELDS(CUR.OUT.REC)> = DLMAIN.NUM.LITERAL.VALUES
         OUT.FMT.LIST(CUR.OUT.REC)<NUM.OUT.FIELDS(CUR.OUT.REC)> = CALC.ITEM.LEN:'L'
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Not expecting ':ITEM:', ':ORIGINAL.ITEM:' must be followed by a literal value'
      END
      RETURN


PROCESS.MISC.FIELD.LITERAL.OPTION: 
      CALC.ITEM.LEN = LEN(ITEM)
      NUM.ORIG.ITEM.FIELDS = COUNT(ORIG.ITEM,"'")
      IF MOD(NUM.ORIG.ITEM.FIELDS,2) # 0 THEN
         DLMAIN.ERRMSG<-1> = 'Unbalanced quotation marks in LITERAL ':ORIG.ITEM:'.'
         DLMAIN.FATAL.ERROR = TRUE
         RETURN
      END
      ORIG.ITEM.START = 2
      FOR WHICH.ORIG.ITEM = ORIG.ITEM.START TO NUM.ORIG.ITEM.FIELDS STEP 2
         ORIG.ITEM.OPTIONS = FIELD(ORIG.ITEM,"'",WHICH.ORIG.ITEM,1)
         GOSUB PROCESS.ORIG.ITEM.OPTIONS
      NEXT WHICH.ORIG.ITEM
      RETURN



PROCESS.ORIG.ITEM.OPTIONS: 
      NUM.ORIG.ITEM.OPTIONS = LEN(ORIG.ITEM.OPTIONS)
      CALC.ITEM.LEN -= 2   ;* TWO QUOTES
      FOR WHICH.ORIG.ITEM.OPTION = 1 TO NUM.ORIG.ITEM.OPTIONS
         ORIG.ITEM.OPTION = ORIG.ITEM.OPTIONS[WHICH.ORIG.ITEM.OPTION,1]
         BEGIN CASE
            CASE ORIG.ITEM.OPTION = 'D'
               CALC.ITEM.LEN += 7  ;* 8 CHARACTERS REPLACING ONE CODE
            CASE ORIG.ITEM.OPTION = 'T'
               CALC.ITEM.LEN += 19 ;* 20 CHARACTERS REPLACING ONE CODE
            CASE 1
               DLMAIN.ERRMSG<-1> = 'Unsupported LITERAL "quote" option: ':ORIG.ITEM:'.'
               DLMAIN.FATAL.ERROR = TRUE
         END CASE
      NEXT WHICH.ORIG.ITEM.OPTION
      RETURN


*
*
* PROCESS MISC.FIELD "SUBR"
*
PROCESS.MISC.FIELD.SUBR: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.PHRASE = TRUE
      TEMP.ERRMSG = 'Invalid ':PHRASE.USED
      IF ITEM.TYPE = '' AND NOT(ITEM.QUOTED) THEN
         IF ITEM = '(' THEN
            GOSUB PROCESS.SUBR.ARG.LIST
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.MISC.FIELD:', expecting ('
            VALID.PHRASE = FALSE
         END
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER
         VALID.PHRASE = FALSE
      END
      IF VALID.PHRASE THEN
         GOSUB PROCESS.VALID.SUBR
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
*
* PROCESS SUBR ARGUMENT LIST
*
PROCESS.SUBR.ARG.LIST: 
      TEMP.SUBR.NAME = ''
      TEMP.SUBR.NUM.ARGS = 0
      TEMP.SUBR.ARG.TYPE = ''
      TEMP.SUBR.ARG.VALUE = ''
      TEMP.SUBR.ARG.DICT.CTR = ''
      PHRASE.USED := '('
      LOOP
      UNTIL (NOT(ITEM.QUOTED) AND ITEM = ')') OR NOT(VALID.PHRASE)
         GOSUB GET.NEXT.ITEM
         PHRASE.USED := ITEM.QUOTED:ITEM:ITEM.QUOTED
         BEGIN CASE
            CASE TEMP.SUBR.NAME = ''
               TEMP.SUBR.NAME = ITEM
               TEMP.SUBR.NUM.ARGS = 1
            CASE ITEM.TYPE = ''
               TEMP.SUBR.NUM.ARGS += 1
               TEMP.SUBR.ARG.TYPE<1,TEMP.SUBR.NUM.ARGS> = ''
               TEMP.SUBR.ARG.VALUE<1,TEMP.SUBR.NUM.ARGS> = ITEM
            CASE ITEM.TYPE = 'FIELD'
               TEMP.SUBR.NUM.ARGS += 1
               TEMP.SUBR.ARG.TYPE<1,TEMP.SUBR.NUM.ARGS> = 'FIELD'
               TEMP.SUBR.ARG.VALUE<1,TEMP.SUBR.NUM.ARGS> = ITEM
               DICT.FIELD.NAME = ITEM
               DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
               GOSUB ADD.DICT.REC
               TEMP.SUBR.ARG.DICT.CTR<1,TEMP.SUBR.NUM.ARGS> = WHICH.DICT.REC.CTR
         END CASE
         GOSUB GET.NEXT.ITEM
         IF ITEM.QUOTED OR (ITEM # ',' AND ITEM # ')') THEN
            VALID.PHRASE = FALSE
            TEMP.ERRMSG = 'Expecting a comma after ':PHRASE.USED
         END
         PHRASE.USED := ITEM.QUOTED:ITEM:ITEM.QUOTED
      REPEAT
      RETURN


*
*
* PROCESS VALID SUBR ITEM
*
PROCESS.VALID.SUBR: 
      SUBR.NAME = TEMP.SUBR.NAME
      SUBR.NUM.ARGS = TEMP.SUBR.NUM.ARGS
      GOSUB ADD.SUBR.TO.LIST
      IF DLMAIN.FATAL.ERROR THEN
         RETURN
      END
*
      NUM.USE.SUBRS += 1
      USE.SUBR.CTR.LIST<NUM.USE.SUBRS> = WHICH.SUBR.CTR
      USE.SUBR.ARG.TYPE.LIST<NUM.USE.SUBRS> = TEMP.SUBR.ARG.TYPE
      USE.SUBR.ARG.VALUE.LIST<NUM.USE.SUBRS> = TEMP.SUBR.ARG.VALUE
      USE.SUBR.ARG.DICT.CTR.LIST<NUM.USE.SUBRS> = TEMP.SUBR.ARG.DICT.CTR
*
      NUM.OUT.FIELDS(CUR.OUT.REC) += 1
      CUR.OUT.FIELD.CTR = NUM.OUT.FIELDS(CUR.OUT.REC)
      OUT.TYPE.LIST(CUR.OUT.REC)<NUM.OUT.FIELDS(CUR.OUT.REC)> = 'SUBR'
      OUT.FIELD.LIST(CUR.OUT.REC)<NUM.OUT.FIELDS(CUR.OUT.REC)> = 'SUBR(':TEMP.SUBR.NAME:')'
      OUT.CTR.LIST(CUR.OUT.REC)<NUM.OUT.FIELDS(CUR.OUT.REC)> = NUM.USE.SUBRS
      CUR.OUT.FIELD.CTR = NUM.OUT.FIELDS(CUR.OUT.REC)
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* ADD SUBR TO LIST
*
ADD.SUBR.TO.LIST: 
      LOCATE SUBR.NAME IN SUBR.NAME.LIST<1> SETTING WHICH.SUBR.CTR THEN
         IF SUBR.NUM.ARGS # SUBR.NUM.ARGS.LIST(WHICH.SUBR.CTR) THEN
            DLMAIN.ERRMSG<-1> = 'Inconsistent number of arguements listed with SUBR(':SUBR.NAME:')'
            DLMAIN.ERRMSG<-1> = '   listed with ':SUBR.NUM.ARGS.LIST(WHICH.SUBR.CTR):' initially, and then with ':SUBR.NUM.ARGS:' arguements'
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
         IF SUBR.NUM.ARGS > DLMAX.SUBR.ARGS THEN
            DLMAIN.ERRMSG<-1> = 'Too many arguements listed with SUBR(':SUBR.NAME:'), maximum arguements is ':DLMAX.SUBR.ARGS
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
      END ELSE
         NUM.SUBR.NAMES += 1
         IF NUM.SUBR.NAMES > DLMAX.SUBR.NAMES THEN
            DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many SUBR() items: ':NUM.SUBR.NAMES
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
         SUBR.NAMES(NUM.SUBR.NAMES) = SUBR.NAME
         SUBR.NUM.ARGS.LIST(NUM.SUBR.NAMES) = SUBR.NUM.ARGS
         SUBR.NAME.LIST<NUM.SUBR.NAMES> = SUBR.NAME
         WHICH.SUBR.CTR = NUM.SUBR.NAMES
      END
      RETURN

*
*
* PROCESS FIELD PREFIX
*  THE ACTUAL PROCESSING OF THE PREFIX IS DONE WHEN THE FIELD NAME
*  IS ENCOUNTERED
*
PROCESS.PREFIX: 
      PHRASE.USED = ORIGINAL.ITEM
      ACTIVE.PREFIX = WHICH.PREFIX
      GOSUB GET.NEXT.ITEM
      RETURN



*
* PROCESS @ VARIABLE
* TREAT THE AT VARIABLE AS THOUGH IT WERE A LITERAL
* ACTUAL VALUE WILL BE ASSIGNED LATER
*
PROCESS.AT.VARIABLE: 
      DLMAIN.NUM.LITERAL.VALUES += 1
      DLMAIN.LITERAL.VALUE.LIST<DLMAIN.NUM.LITERAL.VALUES> = ITEM
      NUM.OUT.FIELDS(CUR.OUT.REC) += 1
      CUR.OUT.FIELD.CTR = NUM.OUT.FIELDS(CUR.OUT.REC)
      OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = 'AT.VARIABLE ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      OUT.TYPE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = 'AT.VARIABLE'
      OUT.CTR.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = DLMAIN.NUM.LITERAL.VALUES
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS.QUALIFIER
*
PROCESS.QUALIFIER: 
      BEGIN CASE
         CASE WHICH.QUALIFIER = 'LINE'
            GOSUB PROCESS.QUALIFIER.LINE
         CASE WHICH.QUALIFIER = 'LENGTH'
            GOSUB PROCESS.QUALIFIER.LENGTH
         CASE WHICH.QUALIFIER = 'BEG.COL'
            GOSUB PROCESS.QUALIFIER.BEG.COL
         CASE WHICH.QUALIFIER = 'END.COL'
            GOSUB PROCESS.QUALIFIER.END.COL
         CASE WHICH.QUALIFIER = 'COLUMNS'
            GOSUB PROCESS.QUALIFIER.COLUMNS
         CASE WHICH.QUALIFIER = 'FMT'
            GOSUB PROCESS.QUALIFIER.FMT
         CASE WHICH.QUALIFIER = 'CONV'
            GOSUB PROCESS.QUALIFIER.CONV
         CASE WHICH.QUALIFIER = 'HTML.START'
            GOSUB PROCESS.QUALIFIER.HTML.START
         CASE WHICH.QUALIFIER = 'HTML.END'
            GOSUB PROCESS.QUALIFIER.HTML.END
         CASE WHICH.QUALIFIER = 'HTML.CELL'
            GOSUB PROCESS.QUALIFIER.HTML.CELL
         CASE WHICH.QUALIFIER = 'HTML.ROW'
            GOSUB PROCESS.QUALIFIER.HTML.ROW
         CASE WHICH.QUALIFIER = 'XML.ATTRIBUTE'
            GOSUB PROCESS.QUALIFIER.XML.ATTRIBUTE
         CASE WHICH.QUALIFIER = 'XML.ASSOC.NAME'
            GOSUB PROCESS.QUALIFIER.XML.ASSOC.NAME
         CASE WHICH.QUALIFIER = 'XML.SUBASSOC.NAME'
            GOSUB PROCESS.QUALIFIER.XML.SUBASSOC.NAME
         CASE WHICH.QUALIFIER = 'XML.NAME'
            GOSUB PROCESS.QUALIFIER.XML.NAME
         CASE WHICH.QUALIFIER = 'NUM.VALUES'
            GOSUB PROCESS.QUALIFIER.NUM.VALUES
         CASE WHICH.QUALIFIER = 'NUM.SUBVALUES'
            GOSUB PROCESS.QUALIFIER.NUM.SUBVALUES
         CASE WHICH.QUALIFIER = 'MV.ORIENTATION'
            GOSUB PROCESS.QUALIFIER.MV.ORIENTATION
         CASE WHICH.QUALIFIER = 'VALUE.SEPARATOR'
            GOSUB PROCESS.QUALIFIER.VALUE.SEPARATOR
         CASE WHICH.QUALIFIER = 'SUBVALUE.SEPARATOR'
            GOSUB PROCESS.QUALIFIER.SUBVALUE.SEPARATOR
         CASE WHICH.QUALIFIER = 'MULTI.VALUE'
            GOSUB PROCESS.QUALIFIER.MULTI.VALUE
         CASE WHICH.QUALIFIER = 'SINGLE.VALUE'
            GOSUB PROCESS.QUALIFIER.SINGLE.VALUE
         CASE WHICH.QUALIFIER = 'FIELD.NAMES'
            GOSUB PROCESS.QUALIFIER.FIELD.NAMES
         CASE WHICH.QUALIFIER = 'FIELD.LABELS'
            GOSUB PROCESS.QUALIFIER.FIELD.LABELS
         CASE WHICH.QUALIFIER = 'DEFAULT.VALUE'
            GOSUB PROCESS.QUALIFIER.DEFAULT.VALUE
         CASE WHICH.QUALIFIER = 'NO.NULLS'
            GOSUB PROCESS.QUALIFIER.NO.NULLS
      END CASE
      RETURN


*
*
* PROCESS FIELD QUALIFIER "LINE"
*
PROCESS.QUALIFIER.LINE: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            LINE.VALUE = ITEM
            VALID.VALUE = TRUE
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.LINE.VALUE = OUT.LINE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.LINE.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.LINE.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.LINE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = LINE.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "LENGTH"
*  OR ALTERNATELY, A # FOLLOWING A FIELD WITHOUT A QUALIFIER
*
PROCESS.QUALIFIER.LENGTH: 
      PHRASE.USED = ORIGINAL.ITEM
      IF ITEM = 'LENGTH' THEN
         LOOKUP.FIELD.NAME = FALSE
         GOSUB GET.NEXT.ITEM
      END
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            LENGTH.VALUE = ITEM
            VALID.VALUE = TRUE
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:''
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.LENGTH.VALUE = OUT.LENGTH.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.LENGTH.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.LENGTH.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.LENGTH.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = LENGTH.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "BEG.COL"
*
PROCESS.QUALIFIER.BEG.COL: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            BEG.COL.VALUE = ITEM
            VALID.VALUE = TRUE
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:''
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.BEG.COL.VALUE = OUT.BEG.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.BEG.COL.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.BEG.COL.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.BEG.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = BEG.COL.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "END.COL"
*
PROCESS.QUALIFIER.END.COL: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            END.COL.VALUE = ITEM
            VALID.VALUE = TRUE
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:''
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.END.COL.VALUE = OUT.END.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.END.COL.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.END.COL.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.END.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = END.COL.VALUE
         END CASE
      END
      RETURN

*
*
* PROCESS FIELD QUALIFIER "COLUMNS"
*
PROCESS.QUALIFIER.COLUMNS: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            BEG.COL.VALUE = ITEM
* LOOK FOR END COL
            LOOKUP.FIELD.NAME = FALSE
            GOSUB GET.NEXT.ITEM
            IF ITEM.TYPE = '' THEN
               IF NUM(ITEM) AND ITEM > 0 THEN
                  END.COL.VALUE = ITEM
                  VALID.VALUE = TRUE
               END ELSE
                  TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
               END
            END ELSE
               TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:' ':BEG.COL.VALUE
            END
*
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:''
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.BEG.COL.VALUE = OUT.BEG.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         OLD.END.COL.VALUE = OUT.END.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.BEG.COL.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a BEG.COL qualifier "BEG.COL ':BEG.COL.VALUE:'"'
            CASE OLD.END.COL.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a END.COL qualifier "END.COL ':END.COL.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.BEG.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = BEG.COL.VALUE
               OUT.END.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = END.COL.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "FMT"
*
PROCESS.QUALIFIER.FMT: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         TEST.FMT = FMT('',ITEM)
         IF STATUS() = 0 THEN
            IF ITEM = '' THEN
               FMT.VALUE = NULL.CODE
            END ELSE
               FMT.VALUE = ITEM
            END
            VALID.VALUE = TRUE
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:''
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.FMT.VALUE = OUT.FMT.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.FMT.VALUE # '' AND OUT.TYPE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> # 'LITERAL'
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.FMT.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.FMT.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = FMT.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "CONV"
*
PROCESS.QUALIFIER.CONV: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         TEST.CONV.1 = OCONV('',ITEM)
         STATUS.1 = STATUS()
         TEST.CONV.2 = OCONV('1',ITEM)
         STATUS.2 = STATUS()
         IF STATUS.1 = 0 OR STATUS.2 = 0 THEN
            IF ITEM = '' THEN
               CONV.VALUE = NULL.CODE
            END ELSE
               CONV.VALUE = ITEM
            END
            VALID.VALUE = TRUE
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:''
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.CONV.VALUE = OUT.CONV.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.CONV.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.CONV.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.CONV.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = CONV.VALUE
         END CASE
      END
      RETURN



*
*
* PROCESS FIELD QUALIFIER "HTML.START"
*
PROCESS.QUALIFIER.HTML.START: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            HTML.START.VALUE = NULL.CODE
         END ELSE
            HTML.START.VALUE = ITEM
         END
         VALID.VALUE = TRUE
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
      END
      GOSUB GET.NEXT.ITEM
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.HTML.START.VALUE = OUT.HTML.START.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.HTML.START.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.HTML.START.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.HTML.START.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = HTML.START.VALUE
         END CASE
      END
      RETURN



*
*
* PROCESS FIELD QUALIFIER "HTML.END"
*
PROCESS.QUALIFIER.HTML.END: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            HTML.END.VALUE = NULL.CODE
         END ELSE
            HTML.END.VALUE = ITEM
         END
         VALID.VALUE = TRUE
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
      END
      GOSUB GET.NEXT.ITEM
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.HTML.END.VALUE = OUT.HTML.END.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.HTML.END.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.HTML.END.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.HTML.END.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = HTML.END.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "HTML.CELL"
*
PROCESS.QUALIFIER.HTML.CELL: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            HTML.CELL.VALUE = NULL.CODE
         END ELSE
            HTML.CELL.VALUE = ITEM
         END
         VALID.VALUE = TRUE
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
      END
      GOSUB GET.NEXT.ITEM
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.HTML.CELL.VALUE = OUT.HTML.CELL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.HTML.CELL.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.HTML.CELL.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.HTML.CELL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = HTML.CELL.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "HTML.ROW"
*
PROCESS.QUALIFIER.HTML.ROW: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF ITEM = '' THEN
            HTML.ROW.VALUE = NULL.CODE
         END ELSE
            HTML.ROW.VALUE = ITEM
         END
         VALID.VALUE = TRUE
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
      END
      GOSUB GET.NEXT.ITEM
      IF CUR.OUT.FIELD.CTR < 1 AND NOT(CUR.OUT.REC = DLMAIN.HEADING.OUT.REC) THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.HTML.ROW.VALUE = OUT.HTML.ROW.LIST(CUR.OUT.REC)
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.HTML.ROW.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.HTML.ROW.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.HTML.ROW.LIST(CUR.OUT.REC) = HTML.ROW.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "XML.ATTRIBUTE"
*
PROCESS.QUALIFIER.XML.ATTRIBUTE: 
      PHRASE.USED = ORIGINAL.ITEM
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         IF OUT.SM.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = 'M' THEN
            DLMAIN.ERRMSG<-1> = PHRASE.USED:' cannot be used with multi-valued fields.'
         END ELSE
            OUT.XML.ATTRIBUTE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = TRUE
         END
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "XML.ASSOC.NAME"
*
PROCESS.QUALIFIER.XML.ASSOC.NAME: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      BEGIN CASE
         CASE ITEM = ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML association name, found nothing.'
         CASE ITEM.TYPE # ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML association name, found "':ITEM:'"'
         CASE 1
            X.ITEM.OUT = ''
            X.DO.LOWER.CASE = FALSE
            CALL DLXMLELEM(X.ITEM.OUT,ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML association name "':ITEM:'" does not generate a valid XML name.'
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               XML.ASSOC.NAME.VALUE = X.ITEM.OUT
               VALID.VALUE = TRUE
               IF CUR.OUT.FIELD.CTR < 1 THEN
                  DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
               END ELSE
                  OLD.XML.ASSOC.NAME.VALUE = OUT.XML.ASSOC.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  IF OLD.XML.ASSOC.NAME.VALUE = '' THEN
                     OUT.XML.ASSOC.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = XML.ASSOC.NAME.VALUE
                  END ELSE
                     DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.XML.ASSOC.NAME.VALUE:'"'
                  END
               END
            END
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "XML.SUBASSOC.NAME"
*
PROCESS.QUALIFIER.XML.SUBASSOC.NAME: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      BEGIN CASE
         CASE ITEM = ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML subassociation name, found nothing.'
         CASE ITEM.TYPE # ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML subassociation name, found "':ITEM:'"'
         CASE 1
            X.ITEM.OUT = ''
            X.DO.LOWER.CASE = FALSE
            CALL DLXMLELEM(X.ITEM.OUT,ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML subassociation name "':ITEM:'" does not generate a valid XML name.'
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               XML.SUBASSOC.NAME.VALUE = X.ITEM.OUT
               VALID.VALUE = TRUE
               IF CUR.OUT.FIELD.CTR < 1 THEN
                  DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
               END ELSE
                  OLD.XML.SUBASSOC.NAME.VALUE = OUT.XML.SUBASSOC.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  IF OLD.XML.SUBASSOC.NAME.VALUE = '' THEN
                     OUT.XML.SUBASSOC.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = XML.SUBASSOC.NAME.VALUE
                  END ELSE
                     DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.XML.SUBASSOC.NAME.VALUE:'"'
                  END
               END
            END
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "XML.NAME"
*
PROCESS.QUALIFIER.XML.NAME: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      BEGIN CASE
         CASE ITEM = ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML field name, found nothing.'
         CASE ITEM.TYPE # ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML field name, found "':ITEM:'"'
         CASE 1
            X.ITEM.OUT = ''
            X.DO.LOWER.CASE = FALSE
            CALL DLXMLELEM(X.ITEM.OUT,ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML field name "':ITEM:'" does not generate a valid XML name.'
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               XML.NAME.VALUE = X.ITEM.OUT
               VALID.VALUE = TRUE
               IF CUR.OUT.FIELD.CTR < 1 THEN
                  DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
               END ELSE
                  OLD.XML.NAME.VALUE = OUT.XML.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  IF OLD.XML.NAME.VALUE = '' THEN
                     OUT.XML.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = XML.NAME.VALUE
                  END ELSE
                     DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.XML.NAME.VALUE:'"'
                  END
               END
            END
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "NUM.VALUES"
*
PROCESS.QUALIFIER.NUM.VALUES: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' OR (ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.ALL) THEN
         BEGIN CASE
            CASE NUM(ITEM) AND ITEM > 0
               NUM.VALUES.VALUE = ITEM
               VALID.VALUE = TRUE
            CASE ITEM.KEYWORD = KEYWORD.ALL
               NUM.VALUES.VALUE = ITEM
               VALID.VALUE = TRUE
            CASE 1
               TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.NUM.VALUES.VALUE = OUT.NUM.VALUES.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.NUM.VALUES.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.NUM.VALUES.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.NUM.VALUES.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = NUM.VALUES.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "NUM.SUBVALUES"
*
PROCESS.QUALIFIER.NUM.SUBVALUES: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' OR (ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.ALL) THEN
         BEGIN CASE
            CASE NUM(ITEM) AND ITEM > 0
               NUM.SUBVALUES.VALUE = ITEM
               VALID.VALUE = TRUE
            CASE ITEM.KEYWORD = KEYWORD.ALL
               NUM.SUBVALUES.VALUE = ITEM
               VALID.VALUE = TRUE
            CASE 1
               TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.NUM.SUBVALUES.VALUE = OUT.NUM.SUBVALUES.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.NUM.SUBVALUES.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.NUM.SUBVALUES.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.NUM.SUBVALUES.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = NUM.SUBVALUES.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS QUALIFIER "MV.ORIENTATION"
*
PROCESS.QUALIFIER.MV.ORIENTATION: 
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' specified must be in this list: "':ORIENTATION.TYPE.LIST:'"'
      CONVERT @FM:@VM:@SM TO '   ' IN TEMP.ERRMSG
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' OR ITEM.TYPE = 'KEYWORD' THEN
         LOCATE ITEM IN ORIENTATION.TYPE.LIST<1> SETTING POS THEN
            MV.ORIENTATION.VALUE = ITEM
            PHRASE.USED := ' ':ITEM
            ITEM.TYPE = ''
            VALID.VALUE = TRUE
         END ELSE
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.MV.ORIENTATION.VALUE = OUT.MV.ORIENTATION.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.MV.ORIENTATION.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.MV.ORIENTATION.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.MV.ORIENTATION.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = MV.ORIENTATION.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS QUALIFIER "VALUE.SEPARATOR"
*
PROCESS.QUALIFIER.VALUE.SEPARATOR: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         VALUE.SEPARATOR.VALUE = ITEM
         PHRASE.USED := ' ':ITEM
         VALID.VALUE = TRUE
      END ELSE
         TEMP.ERRMSG = 'Expecting ':PHRASE.USED:', but found ':ITEM:'.'
      END
      IF VALID.VALUE = TRUE THEN
         IF CUR.OUT.FIELD.CTR < 1 THEN
            DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
         END ELSE
            OLD.VALUE.SEPARATOR.VALUE = OUT.VALUE.SEPARATOR.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
            FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
            BEGIN CASE
               CASE OLD.VALUE.SEPARATOR.VALUE # ''
                  DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.VALUE.SEPARATOR.VALUE:'"'
               CASE NOT(VALID.VALUE)
                  DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
               CASE 1
                  OUT.VALUE.SEPARATOR.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = VALUE.SEPARATOR.VALUE
                  OUT.VALUE.SEPARATOR.SET(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = TRUE
            END CASE
         END
         GOSUB GET.NEXT.ITEM
      END
      RETURN


*
*
* PROCESS QUALIFIER "SUBVALUE.SEPARATOR"
*
PROCESS.QUALIFIER.SUBVALUE.SEPARATOR: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         SUBVALUE.SEPARATOR.VALUE = ITEM
         PHRASE.USED := ' ':ITEM
         VALID.VALUE = TRUE
      END ELSE
         TEMP.ERRMSG = 'Expecting ':PHRASE.USED:', but found ':ITEM:'.'
      END
      IF VALID.VALUE = TRUE THEN
         IF CUR.OUT.FIELD.CTR < 1 THEN
            DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
         END ELSE
            OLD.SUBVALUE.SEPARATOR.VALUE = OUT.SUBVALUE.SEPARATOR.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
            FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
            BEGIN CASE
               CASE OLD.SUBVALUE.SEPARATOR.VALUE # ''
                  DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.SUBVALUE.SEPARATOR.VALUE:'"'
               CASE NOT(VALID.VALUE)
                  DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
               CASE 1
                  OUT.SUBVALUE.SEPARATOR.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = SUBVALUE.SEPARATOR.VALUE
                  OUT.SUBVALUE.SEPARATOR.SET(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = TRUE
            END CASE
         END
         GOSUB GET.NEXT.ITEM
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "SINGLE.VALUE"
*
PROCESS.QUALIFIER.SINGLE.VALUE: 
      PHRASE.USED = ORIGINAL.ITEM
      SM.VALUE = 'S'
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.SM.VALUE = OUT.SM.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         IF OLD.SM.VALUE # '' THEN
            DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.SM.VALUE:'"'
         END ELSE
            OUT.SM.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = SM.VALUE
         END
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "MULTI.VALUE"
*
PROCESS.QUALIFIER.MULTI.VALUE: 
      PHRASE.USED = ORIGINAL.ITEM
      SM.VALUE = 'M'
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.SM.VALUE = OUT.SM.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         IF OLD.SM.VALUE # '' THEN
            DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.SM.VALUE:'"'
         END ELSE
            OUT.SM.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = SM.VALUE
         END
      END
      GOSUB GET.NEXT.ITEM
      RETURN

*
* PROCESS FIELD QUALIFIER "FIELD.NAMES"
*
PROCESS.QUALIFIER.FIELD.NAMES: 
      PHRASE.USED = ORIGINAL.ITEM
      IF NOT(DLMAIN.HEADING.OUT.REC) THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow the HEADING keyword.'
      END ELSE
         HEADING.OUT.REC.USE.FIELD.NAMES = TRUE
      END
      GOSUB GET.NEXT.ITEM
      RETURN



*
* PROCESS FIELD QUALIFIER "FIELD.LABELS"
*
PROCESS.QUALIFIER.FIELD.LABELS: 
      PHRASE.USED = ORIGINAL.ITEM
      IF NOT(DLMAIN.HEADING.OUT.REC) THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow the HEADING keyword.'
      END ELSE
         HEADING.OUT.REC.USE.FIELD.LABELS = TRUE
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
* PROCESS FIELD QUALIFIER "DEFAULT.VALUE"
*
PROCESS.QUALIFIER.DEFAULT.VALUE: 
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM = '' OR ITEM.TYPE = 'KEYWORD' OR ITEMS.DONE THEN
         TEMP.ERRMSG = WHICH.QUALIFIER:' requires a value to be specified.'
      END ELSE
         DEFAULT.VALUE.VALUE = ITEM
         VALID.VALUE = TRUE
      END
      GOSUB GET.NEXT.ITEM
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.DEFAULT.VALUE.VALUE = OUT.DEFAULT.VALUE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = OUT.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.DEFAULT.VALUE.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.DEFAULT.VALUE.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               OUT.DEFAULT.VALUE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = DEFAULT.VALUE.VALUE
         END CASE
      END
      RETURN


*
*
PROCESS.QUALIFIER.NO.NULLS: 
      PHRASE.USED = ORIGINAL.ITEM
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         FOR WHICH.BREAK.FIELD = 1 TO DLMAIN.NUM.BREAK.FIELDS
            DATA.INCLUDE.NULLS(WHICH.BREAK.FIELD) = FALSE
         NEXT WHICH.BREAK.FIELD
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS.FIELD
*
PROCESS.FIELD: 
      NUM.OUT.FIELDS(CUR.OUT.REC) += 1
      IF ACTIVE.PREFIX = 'BREAK.SUP' THEN
         OUT.TYPE.LIST(CUR.OUT.REC)<NUM.OUT.FIELDS(CUR.OUT.REC)> = 'SUP'
      END ELSE
         OUT.TYPE.LIST(CUR.OUT.REC)<NUM.OUT.FIELDS(CUR.OUT.REC)> = 'FIELD'
      END
      OUT.FIELD.LIST(CUR.OUT.REC)<NUM.OUT.FIELDS(CUR.OUT.REC)> = ITEM
      DICT.FIELD.NAME = ITEM
      DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
      GOSUB ADD.DICT.REC
      IF ACTIVE.PREFIX THEN
         OUT.PREFIX.LIST(CUR.OUT.REC)<NUM.OUT.FIELDS(CUR.OUT.REC)> = ACTIVE.PREFIX
         GOSUB PROCESS.FIELD.PREFIX
      END
      OUT.CTR.LIST(CUR.OUT.REC)<NUM.OUT.FIELDS(CUR.OUT.REC)> = WHICH.DICT.REC.CTR
      CUR.OUT.FIELD.CTR = NUM.OUT.FIELDS(CUR.OUT.REC)
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD PREFIX
*
PROCESS.FIELD.PREFIX: 
      BEGIN CASE
         CASE ACTIVE.PREFIX = 'BREAK.ON' OR ACTIVE.PREFIX = 'BREAK.SUP'
            GOSUB PROCESS.FIELD.PREFIX.BREAK.ON
         CASE ACTIVE.PREFIX = 'TOTAL'
            GOSUB PROCESS.FIELD.PREFIX.TOTAL
         CASE ACTIVE.PREFIX = 'AVERAGE'
            GOSUB PROCESS.FIELD.PREFIX.AVERAGE
         CASE ACTIVE.PREFIX = 'MIN'
            GOSUB PROCESS.FIELD.PREFIX.MIN
         CASE ACTIVE.PREFIX = 'MAX'
            GOSUB PROCESS.FIELD.PREFIX.MAX
      END CASE
      RETURN


*
*
* PROCESS FIELD PREFIX BREAK.ON
*  MARK THE FIRST BREAK FIELD AS #2 (BREAK #1 IS THE FINAL BREAK)
*
PROCESS.FIELD.PREFIX.BREAK.ON: 
      IF DLMAIN.NUM.BREAK.FIELDS = 0 THEN
         DLMAIN.NUM.BREAK.FIELDS += 1
         DLMAIN.BREAK.DICT.CTR.LIST<DLMAIN.NUM.BREAK.FIELDS> = 'ALL'
      END
      DLMAIN.NUM.BREAK.FIELDS += 1
      DLMAIN.BREAK.DICT.CTR.LIST<DLMAIN.NUM.BREAK.FIELDS> = WHICH.DICT.REC.CTR
      RETURN


*
*
* PROCESS FIELD PREFIX TOTAL
*
PROCESS.FIELD.PREFIX.TOTAL: 
      DICT.KEEP.TOTAL(WHICH.DICT.REC.CTR) = TRUE
      RETURN


*
*
* PROCESS FIELD PREFIX AVERAGE
*
PROCESS.FIELD.PREFIX.AVERAGE: 
      DICT.KEEP.AVERAGE(WHICH.DICT.REC.CTR) = TRUE
      RETURN


*
*
* PROCESS FIELD PREFIX MIN
*
PROCESS.FIELD.PREFIX.MIN: 
      DICT.KEEP.MIN(WHICH.DICT.REC.CTR) = TRUE
      RETURN


*
*
* PROCESS FIELD PREFIX MAX
*
PROCESS.FIELD.PREFIX.MAX: 
      DICT.KEEP.MAX(WHICH.DICT.REC.CTR) = TRUE
      RETURN


*
*
* GET NEXT ITEM
*
GET.NEXT.ITEM: 
      ITEM.CTR += 1
      LOOP
         ITEM.EXPANDED = FALSE
         ITEM = ITEM.LIST<ITEM.CTR>
         ORIG.ITEM = ITEM
         ITEM.QUOTED = ITEM.QUOTED.LIST<ITEM.CTR>
         ITEM.USED = ITEM.USED.LIST<ITEM.CTR>
         IF ITEM.CTR > NUM.ITEMS THEN
            ITEMS.DONE = TRUE
            ITEM = '** End of line **'
            ITEM.TYPE = 'END.OF.ITEMS'
         END ELSE
            GOSUB DETERMINE.ITEM.TYPE
         END
      UNTIL NOT(ITEM.EXPANDED)
      REPEAT
      RETURN


*
*
* DETERMINE ITEM TYPE
*   THE VARIABLE 'LOOKUP.FIELD.NAME' IS USED TO DECIDE IF THE
*   DICTIONARY & VOC SHOULD BE READ.  IT IS INITIALLY SET TO TRUE,
*   AND RESET TO TRUE AT THE END OF THIS SUBROUTINE.
*   IF A FIELD NAME IS NOT ALLOWED (EG. AFTER AN OPTION SUCH AS
*   NUM.VALUES, AS IN 'NUM.VALUES ALL') THEN BEFORE THE 'GET.NEXT.ITEM'
*   OR 'DETERMINE.ITEM.TYPE' SUBROUTINES ARE CALLED, THE FLAG
*   SHOULD BE SET TO FALSE.
*
DETERMINE.ITEM.TYPE: 
      PASSED.LOOKUP.FIELD.NAME = LOOKUP.FIELD.NAME
      LOOKUP.FIELD.NAME = TRUE
      ITEM.TYPE = ''
      ITEM.KEYWORD = ''
      ITEM.FIELD.FILE.NUM = ''
      IF ITEM = '' THEN
         RETURN
      END
      IF ITEM.QUOTED THEN
         RETURN
      END
      GOSUB CHECK.FOR.SYNONYMS
      IF ITEM.TYPE = '' THEN
         GOSUB CHECK.VOC.FOR.NONFIELD
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN PREPROCESS.LIST<1> SETTING PREPROCESS.POS THEN
            WHICH.PREPROCESS = ITEM
            ITEM.TYPE = 'PREPROCESS'
            ITEM.KEYWORD = PREPROCESS.KEYWORD.LIST<PREPROCESS.POS>
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN OPTION.LIST<1> SETTING OPTION.POS THEN
            WHICH.OPTION = ITEM
            ITEM.TYPE = 'OPTION'
            ITEM.KEYWORD = OPTION.KEYWORD.LIST<OPTION.POS>
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN PREFIX.LIST<1> SETTING PREFIX.POS THEN
            WHICH.PREFIX = ITEM
            ITEM.TYPE = 'PREFIX'
            ITEM.KEYWORD = PREFIX.KEYWORD.LIST<PREFIX.POS>
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN AT.VARIABLE.LIST<1> SETTING AT.VARIABLE.POS THEN
            WHICH.AT.VARIABLE = ITEM
            ITEM.TYPE = 'AT.VARIABLE'
            ITEM.KEYWORD = ITEM
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN QUALIFIER.LIST<1> SETTING QUALIFIER.POS THEN
            WHICH.QUALIFIER = ITEM
            ITEM.TYPE = 'QUALIFIER'
            ITEM.KEYWORD = QUALIFIER.KEYWORD.LIST<QUALIFIER.POS>
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN MISC.FIELD.LIST<1> SETTING MISC.FIELD.POS THEN
            WHICH.MISC.FIELD = ITEM
            ITEM.TYPE = 'MISC.FIELD'
            ITEM.KEYWORD = MISC.FIELD.KEYWORD.LIST<MISC.FIELD.POS>
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN OPERATOR.LIST<1,1> SETTING OPERATOR.POS THEN
            WHICH.OPERATOR = OPERATOR.LIST<2,OPERATOR.POS>
            ITEM.TYPE = 'OPERATOR'
            ITEM.KEYWORD = OPERATOR.KEYWORD.LIST<2,OPERATOR.POS>
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN MISC.KEYWORD.LIST<1> SETTING MISC.KEYWORD.POS THEN
            WHICH.MISC.KEYWORD = ITEM
            ITEM.TYPE = 'KEYWORD'
            ITEM.KEYWORD = MISC.KEYWORD.KEYWORD.LIST<MISC.KEYWORD.POS>
         END
      END
      IF PASSED.LOOKUP.FIELD.NAME THEN
         IF ITEM.TYPE = '' THEN
            GOSUB CHECK.DICT.FOR.ITEM
         END
         IF ITEM.TYPE = '' THEN
            GOSUB CHECK.VOC.FOR.FIELD
         END
      END
      RETURN


*
*
* CHECK DICT FOR ITEM
*
CHECK.DICT.FOR.ITEM: 
      ITEM.FIELD.TYPE = ''
      IF ITEM.QUOTED THEN
         RETURN
      END
      IF NOT(PRIMARY.DICT.OPENED) THEN
         RETURN
      END
      TEMP.POS = INDEX(ITEM, SECONDARY.FIELD.FLAG, 1)
      IF TEMP.POS = 0 THEN
         FILE.NAME = ''
         FILE.NUM = PRIMARY.FILE.NUM
         FIELD.NAME = ITEM
      END ELSE
         FILE.NAME = ITEM[1,TEMP.POS-1]
         FIELD.NAME = ITEM[TEMP.POS+LEN.SECONDARY.FIELD.FLAG,999]
         LOCATE FILE.NAME IN DLMAIN.INFO.FILE.ALIAS.LIST<1> SETTING FILE.NUM ELSE
            DLMAIN.ERRMSG<-1> = '"':ITEM:'" does not include a valid file name or alias name'
            DLMAIN.FATAL.ERROR = TRUE
            FILE.NUM = ''
         END
      END
      IF FILE.NUM THEN
         READ DICT.REC FROM F.DICT.FILE(FILE.NUM), FIELD.NAME THEN
            ITEM.TYPE = 'FIELD'
            ITEM.FIELD.FILE.NUM = FILE.NUM
            IF DICT.REC<1>[1,2] = 'PH' THEN
               PHRASE.TO.EXPAND = DICT.REC<2>
               GOSUB EXPAND.PHRASE
            END ELSE
               ITEM.FIELD.TYPE = DICT.REC<1>[1,1]
            END
         END
      END
      RETURN


*
* EXPAND PHRASES FROM THE DICTIONARY OR VOC ON THE FLY AS THEY ARE
* ENCOUNTERED.  (THIS KEEPS THE PROCESSING FROM EXPANDING ITEMS
* THAT ARE KEYWORDS TO THE PROGRAM AS WELL AS PHRASES SOMEWHERE
* IN SITUATIONS WHERE IT SHOULD NOT BE CHECKING FOR FIELD NAMES, ETC.)
* EG.  DEFAULT NUM.VALUES ALL,  IF 'ALL' IS DEFINED AS A PHRASE IN THE
*      DICT, THEN THIS PHRASE USED TO CHOKE.
*
EXPAND.PHRASE: 
      CALL PARSECL(PHRASE.TO.EXPAND, PHRASE.LIST, PHRASE.QUOTED.LIST, NUM.PHRASE.ITEMS, OTHER.SEPARATORS)
      IF NUM.PHRASE.ITEMS < 1 THEN
         ITEM.TYPE = ''
         ITEM = ''
         ITEM.FIELD.TYPE = ''
         ITEM.FIELD.FILE.NUM = ''
         RETURN
      END
*
      ITEM.LIST.PART.1 = FIELD(ITEM.LIST,@FM,1,ITEM.CTR-1)
      ITEM.QUOTED.LIST.PART.1 = FIELD(ITEM.QUOTED.LIST,@FM,1,ITEM.CTR-1)
      ITEM.USED.LIST.PART.1 = FIELD(ITEM.USED.LIST,@FM,1,ITEM.CTR-1)
      ITEM.LIST.PART.2 = FIELD(ITEM.LIST,@FM,ITEM.CTR+1,NUM.ITEMS)
      ITEM.QUOTED.LIST.PART.2 = FIELD(ITEM.QUOTED.LIST,@FM,ITEM.CTR+1,NUM.ITEMS)
      ITEM.USED.LIST.PART.2 = FIELD(ITEM.USED.LIST,@FM,ITEM.CTR+1,NUM.ITEMS)
*
      ITEM.LIST = ITEM.LIST.PART.1
      ITEM.QUOTED.LIST = ITEM.QUOTED.LIST.PART.1
      ITEM.USED.LIST = ITEM.USED.LIST.PART.1
      ITEM.LIST<ITEM.CTR> = PHRASE.LIST
      ITEM.QUOTED.LIST<ITEM.CTR> = PHRASE.QUOTED.LIST
      ITEM.USED.LIST<ITEM.CTR> = ''
      ITEM.LIST<ITEM.CTR+NUM.PHRASE.ITEMS> = ITEM.LIST.PART.2
      ITEM.QUOTED.LIST<ITEM.CTR+NUM.PHRASE.ITEMS> = ITEM.QUOTED.LIST.PART.2
      ITEM.USED.LIST<ITEM.CTR+NUM.PHRASE.ITEMS> = ITEM.USED.LIST.PART.2
      NUM.ITEMS += NUM.PHRASE.ITEMS
      ITEM.EXPANDED = TRUE
      RETURN


*
*
* CHECK ITEM FOR NONFIELD
*
CHECK.VOC.FOR.NONFIELD: 
      IF DLMAIN.DEBUG.LEVEL GT 0 THEN
         CRT 'CHECK.VOC.FOR.NONFIELD with ITEM ':ITEM
         CRT 'ITEM.QUOTED is ':ITEM.QUOTED
         CRT 'LOOKUP.FILE.NAME is ':LOOKUP.FILE.NAME
      END
      PASSED.LOOKUP.FILE.NAME = LOOKUP.FILE.NAME
      LOOKUP.FILE.NAME = FALSE
      ITEM.TYPE = ''
      ITEM.KEYWORD = ''
      ITEM.FIELD.TYPE = ''
      IF ITEM.QUOTED THEN
         RETURN
      END
      IF PASSED.LOOKUP.FILE.NAME THEN
         TEMP.ITEM = FIELD(ITEM,OP.SYS.PATH.DELIM,1)
      END ELSE
         TEMP.ITEM = ITEM
      END
      IF DLMAIN.DEBUG.LEVEL GT 0 THEN
         CRT 'Reading VOC for ':TEMP.ITEM
      END
      READ VOC.REC FROM DLMAIN.F.VOC, TEMP.ITEM ELSE
         RETURN
      END
      IF DLMAIN.DEBUG.LEVEL GT 0 THEN
         CRT 'Found VOC item ':TEMP.ITEM
         CRT '001: ':VOC.REC<1>
         CRT '002: ':VOC.REC<2>
         CRT '003: ':VOC.REC<3>
      END
      IF TEMP.ITEM # ITEM THEN
         VOC.REC<2> := OP.SYS.PATH.DELIM:FIELD(ITEM,OP.SYS.PATH.DELIM,2,999)
         WRITE VOC.REC ON DLMAIN.F.VOC, ITEM
         DLMAIN.VOC.DELETE.LIST<1,-1> = ITEM
      END
      VOC.ITEM.TYPE = ''
      FOR NUM.CHARS=3 TO 1 STEP -1 UNTIL VOC.ITEM.TYPE # ''
         CHECK.TYPE = VOC.REC<1>[1,NUM.CHARS]
         LOCATE CHECK.TYPE IN DBMS.VOC.ITEM.TYPE.LIST<1> SETTING POS THEN
            VOC.ITEM.TYPE = CHECK.TYPE
         END
      NEXT NUM.CHARS
      VOC.KEYWORD = VOC.REC<2>
      BEGIN CASE
         CASE (VOC.ITEM.TYPE = 'F' OR VOC.ITEM.TYPE = 'DIR') AND PASSED.LOOKUP.FILE.NAME
            IF DLMAIN.DEBUG.LEVEL GT 0 THEN
               CRT 'Opening ':ITEM
            END
            OPEN '', ITEM TO F.TEST THEN
               IF DLMAIN.DEBUG.LEVEL GT 0 THEN
                  CRT 'Open was successful.'
               END
               GOSUB OP.SYS.FILE.TYPE
               *UNIDATA               IF ITEM.TYPE = 'TYPE1.FILE' OR ITEM.TYPE = 'FILE' THEN
               *UNIDATA                  DLMAIN.TYPE1.FILE.PATH.NAME = VOC.REC<2>
               *UNIDATA                  IF DLMAIN.TYPE1.FILE.PATH.NAME[1,1] EQ '@' THEN
               *UNIDATA                     X.TEMP = GETENV(DLMAIN.TYPE1.FILE.PATH.NAME[2,LEN(DLMAIN.TYPE1.FILE.PATH.NAME)])
               *UNIDATA                     IF DLMAIN.DEBUG.LEVEL GT 0 THEN
               *UNIDATA                        CRT 'Checking for file specified by environment variable ':X.TEMP
               *UNIDATA                     END
               *UNIDATA                     IF X.TEMP NE '' THEN
               *UNIDATA                        DLMAIN.TYPE1.FILE.PATH.NAME = X.TEMP
               *UNIDATA                     END
               *UNIDATA                  END
               *UNIDATA               END
               CLOSE F.TEST
            END ELSE
               IF DLMAIN.DEBUG.LEVEL GT 0 THEN
                  CRT 'Open was not successful.'
               END
            END
         CASE VOC.ITEM.TYPE = 'K' AND VOC.KEYWORD # THROWAWAY.KEYWORD
            GOSUB CHECK.VOC.KEYWORD
         CASE VOC.ITEM.TYPE = 'X'
            LOCATE PROGRAM.NAME IN VOC.REC<2,1> SETTING POS THEN
               VOC.KEYWORD = VOC.REC<3,POS>
               GOSUB CHECK.VOC.KEYWORD
            END
      END CASE
      RETURN


*
*
* CHECK ITEM VOC TYPE
*
CHECK.VOC.FOR.FIELD: 
      ITEM.TYPE = ''
      ITEM.KEYWORD = ''
      ITEM.FIELD.TYPE = ''
      IF ITEM.QUOTED THEN
         RETURN
      END
      READ VOC.REC FROM DLMAIN.F.VOC, ITEM ELSE
         RETURN
      END
      VOC.ITEM.TYPE = ''
      FOR NUM.CHARS=3 TO 1 STEP -1 UNTIL VOC.ITEM.TYPE # ''
         CHECK.TYPE = VOC.REC<1>[1,NUM.CHARS]
         LOCATE CHECK.TYPE IN DBMS.VOC.ITEM.TYPE.LIST<1> SETTING POS THEN
            VOC.ITEM.TYPE = CHECK.TYPE
         END
      NEXT NUM.CHARS
      VOC.KEYWORD = VOC.REC<2>
      BEGIN CASE
         CASE VOC.ITEM.TYPE = 'I' OR VOC.ITEM.TYPE = 'D'
            ITEM.TYPE = 'FIELD'
            ITEM.FIELD.TYPE = VOC.ITEM.TYPE
            ITEM.FIELD.FILE.NUM = PRIMARY.FILE.NUM
            DICT.REC = VOC.REC
         CASE VOC.ITEM.TYPE = 'PH'
            PHRASE.TO.EXPAND = VOC.REC<2>
            GOSUB EXPAND.PHRASE
      END CASE
      RETURN


*
*
* CHECK VOC KEYWORD RECORD
*
CHECK.VOC.KEYWORD: 
      ITEM.TYPE = '*KEYWORD*'
      ITEM.KEYWORD = VOC.KEYWORD
      LOCATE ITEM.KEYWORD IN PREPROCESS.KEYWORD.LIST<1> SETTING PREPROCESS.POS THEN
         WHICH.PREPROCESS = PREPROCESS.LIST<PREPROCESS.POS>
         ITEM.TYPE = 'PREPROCESS'
      END
      LOCATE ITEM IN XL.IGNORE.OPTION<1,1> SETTING X.POS ELSE
         LOCATE ITEM.KEYWORD IN OPTION.KEYWORD.LIST<1> SETTING OPTION.POS THEN
            WHICH.OPTION = OPTION.LIST<OPTION.POS>
            ITEM.TYPE = 'OPTION'
         END
      END
      IF ITEM.TYPE = '*KEYWORD*' THEN
         LOCATE ITEM.KEYWORD IN PREFIX.KEYWORD.LIST<1> SETTING PREFIX.POS THEN
            WHICH.PREFIX = PREFIX.LIST<PREFIX.POS>
            ITEM.TYPE = 'PREFIX'
         END
      END
      IF ITEM.TYPE = '*KEYWORD*' THEN
         LOCATE ITEM.KEYWORD IN QUALIFIER.KEYWORD.LIST<1> SETTING QUALIFIER.POS THEN
            WHICH.QUALIFIER = QUALIFIER.LIST<QUALIFIER.POS>
            ITEM.TYPE = 'QUALIFIER'
         END
      END
      IF ITEM.TYPE = '*KEYWORD*' THEN
         LOCATE ITEM.KEYWORD IN OPERATOR.KEYWORD.LIST<2,1> SETTING OPERATOR.POS THEN
            WHICH.OPERATOR = OPERATOR.LIST<2,OPERATOR.POS>
            ITEM.TYPE = 'OPERATOR'
         END
      END
      IF ITEM.TYPE = '*KEYWORD*' THEN
         LOCATE ITEM.KEYWORD IN MISC.FIELD.KEYWORD.LIST<1> SETTING MISC.FIELD.POS THEN
            WHICH.MISC.FIELD = MISC.FIELD.LIST<MISC.FIELD.POS>
            ITEM.TYPE = 'MISC.FIELD'
         END
      END
      IF ITEM.TYPE = '*KEYWORD*' THEN
         LOCATE ITEM.KEYWORD IN MISC.KEYWORD.KEYWORD.LIST<1> SETTING MISC.KEYWORD.POS THEN
            WHICH.MISC.KEYWORD = MISC.KEYWORD.LIST<MISC.KEYWORD.POS>
            ITEM.TYPE = 'KEYWORD'
         END
      END
      IF ITEM.TYPE = '*KEYWORD*' THEN
         ITEM.TYPE = 'KEYWORD'
      END
      RETURN




*******************************************************************************
**
**   FINISH UP COMMAND LINE ITEMS: CHECK FOR CONSISTENCY, COMPLETENESS
**
*******************************************************************************
FINISH.ITEMS: 
      GOSUB FINISH.COMPILE.IDESC
      GOSUB FINISH.DLMAIN.PRINT.METHOD
      GOSUB FINISH.FILE.DICT.ITEMS
      GOSUB FINISH.OPTIONS
      IF DLMAIN.FATAL.ERROR THEN
         RETURN
      END
      GOSUB FINISH.EOR.CHAR
      GOSUB FINISH.COMMA.CHAR
      GOSUB FINISH.QUOTE.CHAR
      FOR OUT.REC.CTR=1 TO NUM.OUT.RECS
         GOSUB FINISH.OUTPUT.FIELDS
      NEXT OUT.REC.CTR
      IF DLMAIN.HEADING.OUT.REC # '' THEN
         GOSUB FINISH.HEADING
      END
      GOSUB FINISH.CHECK.LITERAL
      FOR BREAK.LIST.CTR=1 TO DLMAIN.NUM.BREAK.FIELDS
         GOSUB FINISH.BREAK.FIELDS
      NEXT BREAK.LIST.CTR
      IF DLMAIN.FATAL.ERROR THEN
         RETURN
      END
      RETURN


FINISH.CHECK.LITERAL: 
      IF DLMAIN.NUM.LITERAL.VALUES > DLMAX.LITERAL.VALUES THEN
         DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many literal items: ':DLMAIN.NUM.LITERAL.VALUES
         DLMAIN.FATAL.ERROR = TRUE
         RETURN
      END
      MATPARSE DLMAIN.LITERAL.VALUES FROM DLMAIN.LITERAL.VALUE.LIST, @FM
      RETURN

*
* COMPILE ALL I-DESC'S THAT NEED IT
*
FINISH.COMPILE.IDESC: 
      FOR DICT.FIELD.CTR=1 TO NUM.DICT.RECS
         IF DICT.RECS(DICT.FIELD.CTR)<1>[1,1] = 'I' AND DICT.RECS(DICT.FIELD.CTR)<DBMS.DICT.FIELD.TO.CHECK> = '' THEN
            FILE.NUM = DICT.REC.FILE.NUM(DICT.FIELD.CTR)
            FILE.NAME = DLMAIN.INFO.FILE.NAME.PART.2(FILE.NUM)
            IF PRIMARY.DICT.PART.1 = 'DICT' OR FILE.NUM # PRIMARY.FILE.NUM THEN
               FIELD.NAME = DICT.REC.FIELD.LIST<DICT.FIELD.CTR>
               CD.COMMAND = 'COMPILE.DICT ':FILE.NAME:' ':FIELD.NAME
               EXECUTE CD.COMMAND
               READ DICT.RECS(DICT.FIELD.CTR) FROM F.DICT.FILE(FILE.NUM), FIELD.NAME ELSE
                  DLMAIN.ERRMSG<-1> = 'Can not read "':FIELD.NAME:'" from "DICT" "':FILE.NAME:'"'
                  DLMAIN.FATAL.ERROR = TRUE
               END
            END
         END
      NEXT DICT.FIELD.CTR
      RETURN

*
* CHECK WHICH METHOD TO PRINT LINES
*
FINISH.DLMAIN.PRINT.METHOD: 
      BEGIN CASE
         CASE DLMAIN.TYPE1.FILE.NAME = ''
            DLMAIN.PRINT.METHOD = 'CRT'
         CASE DLMAIN.FORMAT = 'WP50'
            DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS'
         CASE DLMAIN.FORMAT = 'WP51'
            DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS'
         CASE DLMAIN.FORMAT = 'FIXED' AND DLMAIN.NO.LINEFEED
            DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS'
         CASE DLMAIN.FORMAT = 'DBF'
            DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS'
         CASE 1
            DLMAIN.PRINT.METHOD = 'WRITESEQ'
      END CASE
      RETURN


*
*
* MAKE DICT ITEMS FROM SECONDARY FIELDS MV IF KEY TO FILE IS MV
*
FINISH.FILE.DICT.ITEMS: 
      FOR DICT.FIELD.CTR=1 TO NUM.DICT.RECS
         FILE.NUM = DICT.REC.FILE.NUM(DICT.FIELD.CTR)
         IF DLMAIN.INFO.FILE.KEY.IS.MULTIVALUE(FILE.NUM) THEN
            DICT.RECS(DICT.FIELD.CTR)<6> = 'M'
         END
      NEXT DICT.FIELD.CTR
      RETURN


*
*
* FINISH OPTIONS
*
FINISH.OPTIONS: 
      GOSUB FO.CONSISTENCY.CHECK
      GOSUB FO.FILL.IN.MISSING
      RETURN

*
* FINISH.OPTIONS CONSISTENCY CHECK
*
FO.CONSISTENCY.CHECK: 
      IF DEFAULT.NUM.VALUES = 'ALL' THEN
         OKAY.LIST = 'WP50 WP51 COMMA QUOTE DIF HTML TAB XML'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            IF DLMAIN.FORMAT = 'FIXED' AND DEFAULT.MV.ORIENTATION = 'VERTICAL' THEN
               NULL
            END ELSE
               DLMAIN.ERRMSG<-1> = 'DEFAULT NUM.VALUES ALL is only valid with formats ':OKAY.LIST.DISPLAY
               DLMAIN.ERRMSG<-1> = '   or FORMAT FIXED DEFAULT MV.ORIENTATION VERTICAL.'
               DLMAIN.FATAL.ERROR = TRUE
            END
         END
      END
      IF DEFAULT.NUM.SUBVALUES = 'ALL' THEN
         OKAY.LIST = 'WP50 WP51 COMMA QUOTE DIF HTML TAB XML'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            IF DLMAIN.FORMAT = 'FIXED' AND DEFAULT.MV.ORIENTATION = 'VERTICAL' THEN
               NULL
            END ELSE
               DLMAIN.ERRMSG<-1> = 'DEFAULT NUM.SUBVALUES ALL is only valid with formats ':OKAY.LIST.DISPLAY
               DLMAIN.ERRMSG<-1> = '   or FORMAT FIXED DEFAULT MV.ORIENTATION VERTICAL.'
               DLMAIN.FATAL.ERROR = TRUE
            END
         END
      END
      IF DEFAULT.MV.ORIENTATION # '' THEN
         OKAY.LIST = 'COMMA QUOTE DIF HTML'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            DLMAIN.ERRMSG<-1> = 'DEFAULT MV.ORIENTATION is not a valid option with FORMAT ':DLMAIN.FORMAT
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      IF DLMAIN.RECORD.LENGTH # '' AND DLMAIN.FORMAT # 'FIXED' THEN
         DLMAIN.ERRMSG<-1> = 'RECORD.LENGTH is only valid with FORMAT FIXED'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DLMAIN.FIELD.GAP # '' THEN
         OKAY.LIST = 'FIXED XML'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            DLMAIN.ERRMSG<-1> = 'FIELD.GAP is only valid with format ':OKAY.LIST.DISPLAY:'.'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      IF DLMAIN.NO.LINEFEED AND DLMAIN.FORMAT # 'FIXED' THEN
         DLMAIN.ERRMSG<-1> = 'NO.LINEFEED is only valid with FORMAT FIXED'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DL.OUTR.DOCUMENT.TITLE # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.TITLE option is only valid for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DL.OUTR.DOCUMENT.TOP # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.TOP option is only valid for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DL.OUTR.DOCUMENT.BOTTOM # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.BOTTOM option is only valid for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DL.OUTR.DOCUMENT.TABLE # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.TABLE option is only valid for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DL.OUTR.DOCUMENT.BODY # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.BODY option is only valid for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DLMAIN.APPEND THEN
         OKAY.LIST = 'COMMA QUOTE TAB XML FIXED'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            DLMAIN.ERRMSG<-1> = 'APPEND option is only valid for formats ':OKAY.LIST.DISPLAY:'.'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      RETURN

*
* FINISH.OPTIONS FILL.IN.MISSING
*
FO.FILL.IN.MISSING: 
      IF DLMAIN.DISPLAY.COUNT = '' THEN
         IF DLMAIN.PRINT.METHOD = 'CRT' THEN
            DLMAIN.DISPLAY.COUNT = FALSE
         END ELSE
            DLMAIN.DISPLAY.COUNT = TRUE
         END
      END
      IF DEFAULT.MV.ORIENTATION = '' AND DLMAIN.FORMAT # 'WP50' AND DLMAIN.FORMAT # 'WP51' THEN
         DEFAULT.MV.ORIENTATION = DLMAIN.RECORD.ORIENTATION
      END
      IF NOT(SET.DEFAULT.NUM.VALUES) THEN
         IF DLMAIN.FORMAT = 'WP50' OR DLMAIN.FORMAT = 'WP51' THEN
            DEFAULT.NUM.VALUES = 'ALL'
         END
      END
      IF NOT(SET.DEFAULT.NUM.SUBVALUES) THEN
         IF DLMAIN.FORMAT = 'WP50' OR DLMAIN.FORMAT = 'WP51' THEN
            DEFAULT.NUM.SUBVALUES = 'ALL'
         END
      END
      IF DLMAIN.FORMAT = 'XML' THEN
         IF XML.UPCASE THEN
            OUT.XML.ROOT.NAME = OCONV(OUT.XML.ROOT.NAME,'MCU')
         END
         IF OUT.XML.FILE.NAME = '' THEN
            X.ITEM.OUT = ''
            X.DO.LOWER.CASE = TRUE
            X.ITEM = DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM)
            CALL DLXMLELEM(X.ITEM.OUT,X.ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'Cannot generate legal XML element name for file ':X.ITEM
               DLMAIN.FATAL.ERROR = TRUE
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               OUT.XML.FILE.NAME = X.ITEM.OUT
            END
         END
         IF DLMAIN.FIELD.GAP = '' THEN
            DLMAIN.FIELD.GAP = 2
         END
      END
      RETURN



FINISH.EOR.CHAR: 
      IF DLMAIN.FORMAT = 'DBF' THEN
         DLMAIN.EOR = SPACE(1)
      END
      RETURN


FINISH.QUOTE.CHAR: 
      IF DLMAIN.FORMAT = 'TAB' THEN
         DLMAIN.QUOTE = ''
      END
      RETURN


FINISH.COMMA.CHAR: 
      IF DLMAIN.FORMAT = 'TAB' THEN
         DLMAIN.COMMA = CHAR(9)
      END
      RETURN


*
*
* FINISH DOWNLOAD FIELDS
*  (PARSE DICT RECORDS, CHECK FOR CONSISTENCY AMONG QUALIFIERS)
*
FINISH.OUTPUT.FIELDS: 
      LAST.LINE.VALUE = DEFAULT.LINE
      FOR FIELD.CTR = 1 TO NUM.OUT.FIELDS(OUT.REC.CTR)
         GOSUB FOF.GET.VALUES
         GOSUB FOF.CONSISTENCY.CHECK
         GOSUB FOF.FILL.IN.MISSING
         GOSUB FOF.PUT.VALUES
      NEXT FIELD.CTR
      IF DLMAIN.FATAL.ERROR THEN
         RETURN
      END
*
* SECOND PASS
*   ASSIGN DEFAULT NUM VALUES FOR ASSOCIATED ITEMS
*   CHECK LINE/COL BEING USED
*
      LAST.LINE.VALUE = DEFAULT.LINE
      CUR.LINE = ''
      LAST.COL.USED.LIST = ''
      FOR FIELD.CTR=1 TO NUM.OUT.FIELDS(OUT.REC.CTR)
         GOSUB FOF.GET.VALUES
         GOSUB FOF.ASSOC.NUM.VALUES
         GOSUB FOF.CHECK.LINE.VALUE
         IF DLMAIN.FORMAT = 'FIXED' OR DLMAIN.FORMAT = 'DBF' THEN
            GOSUB FOF.CHECK.COLUMN.VALUES
         END
         GOSUB FOF.DETERMINE.NUMERIC
         GOSUB FOF.PUT.VALUES
      NEXT FIELD.CTR
      RETURN


*
*
* FINISH DOWNLOAD FIELDS GET VALUES FROM ARRAYS
*
FOF.GET.VALUES: 
      FIELD.NAME = OUT.FIELD.LIST(OUT.REC.CTR)<FIELD.CTR>
      OUT.REC = OUT.CTR.LIST(OUT.REC.CTR)<FIELD.CTR>
      OUT.TYPE = OUT.TYPE.LIST(OUT.REC.CTR)<FIELD.CTR>
      BEGIN CASE
         CASE OUT.TYPE = 'FIELD' OR OUT.TYPE = 'SUP'
            FIELD.CONV = DICT.RECS(OUT.REC)<3>
            FIELD.FMT = DICT.RECS(OUT.REC)<5>
            FIELD.SM = DICT.RECS(OUT.REC)<6>
            FIELD.ASSOC = DICT.RECS(OUT.REC)<7>
         CASE OUT.TYPE = 'SUBR'
            FIELD.CONV = ''
            FIELD.FMT = DEFAULT.FIELD.FMT
            FIELD.SM = 'S'
            FIELD.ASSOC = ''
         CASE OUT.TYPE = 'LITERAL'
            FIELD.CONV = ''
            FIELD.FMT = LEN(DLMAIN.LITERAL.VALUE.LIST<OUT.REC>):'L'
            FIELD.SM = 'S'
            FIELD.ASSOC = ''
         CASE OUT.TYPE = 'AT.VARIABLE'
            AT.VARIABLE.NAME = FIELD(FIELD.NAME,' ',2,1)
            GOSUB GET.AT.VARIABLE.VALUE
            FIELD.CONV = ''
            FIELD.FMT = LEN(AT.VARIABLE.VALUE):'L'
            FIELD.SM = 'S'
            FIELD.ASSOC = ''
            DLMAIN.LITERAL.VALUE.LIST<OUT.REC> = AT.VARIABLE.VALUE
            OUT.TYPE.LIST(OUT.REC.CTR)<FIELD.CTR> = 'LITERAL'
      END CASE
      LINE.VALUE = OUT.LINE.LIST(OUT.REC.CTR)<FIELD.CTR>
      LENGTH.VALUE = OUT.LENGTH.LIST(OUT.REC.CTR)<FIELD.CTR>
      BEG.COL.VALUE = OUT.BEG.COL.LIST(OUT.REC.CTR)<FIELD.CTR>
      END.COL.VALUE = OUT.END.COL.LIST(OUT.REC.CTR)<FIELD.CTR>
      FMT.VALUE = OUT.FMT.LIST(OUT.REC.CTR)<FIELD.CTR>
      CONV.VALUE = OUT.CONV.LIST(OUT.REC.CTR)<FIELD.CTR>
      HTML.START.VALUE = OUT.HTML.START.LIST(OUT.REC.CTR)<FIELD.CTR>
      HTML.END.VALUE = OUT.HTML.END.LIST(OUT.REC.CTR)<FIELD.CTR>
      HTML.CELL.VALUE = OUT.HTML.CELL.LIST(OUT.REC.CTR)<FIELD.CTR>
      HTML.ROW.VALUE = OUT.HTML.ROW.LIST(OUT.REC.CTR)
      OUT.XML.ATTRIBUTE = OUT.XML.ATTRIBUTE.LIST(OUT.REC.CTR)<FIELD.CTR>
      OUT.XML.NAME = OUT.XML.NAME.LIST(OUT.REC.CTR)<FIELD.CTR>
      OUT.XML.ASSOC.NAME = OUT.XML.ASSOC.NAME.LIST(OUT.REC.CTR)<FIELD.CTR>
      OUT.XML.SUBASSOC.NAME = OUT.XML.SUBASSOC.NAME.LIST(OUT.REC.CTR)<FIELD.CTR>
      SM.VALUE = OUT.SM.LIST(OUT.REC.CTR)<FIELD.CTR>
      NUM.VALUES.VALUE = OUT.NUM.VALUES.LIST(OUT.REC.CTR)<FIELD.CTR>
      NUM.SUBVALUES.VALUE = OUT.NUM.SUBVALUES.LIST(OUT.REC.CTR)<FIELD.CTR>
      MV.ORIENTATION.VALUE = OUT.MV.ORIENTATION.LIST(OUT.REC.CTR)<FIELD.CTR>
      VALUE.SEPARATOR.VALUE = OUT.VALUE.SEPARATOR.LIST(OUT.REC.CTR)<FIELD.CTR>
      VALUE.SEPARATOR.SET.VALUE = OUT.VALUE.SEPARATOR.SET(OUT.REC.CTR)<FIELD.CTR>
      SUBVALUE.SEPARATOR.VALUE = OUT.SUBVALUE.SEPARATOR.LIST(OUT.REC.CTR)<FIELD.CTR>
      SUBVALUE.SEPARATOR.SET.VALUE = OUT.SUBVALUE.SEPARATOR.SET(OUT.REC.CTR)<FIELD.CTR>
      PART.OF.ASSOC.VALUE = OUT.PART.OF.ASSOC.LIST(OUT.REC.CTR)<FIELD.CTR>
      NUMERIC.FLAG.VALUE = OUT.NUMERIC.FLAG.LIST(OUT.REC.CTR)<FIELD.CTR>
      DEFAULT.VALUE.VALUE = OUT.DEFAULT.VALUE.LIST(OUT.REC.CTR)<FIELD.CTR>
      IF LINE.VALUE # '' THEN
         LAST.LINE.VALUE = LINE.VALUE
      END
      RETURN


GET.AT.VARIABLE.VALUE: 
      BEGIN CASE
         CASE AT.VARIABLE.NAME = '@ACCOUNT'
            AT.VARIABLE.VALUE = @ACCOUNT
         CASE AT.VARIABLE.NAME = '@DATE'
            AT.VARIABLE.VALUE = @DATE
         CASE AT.VARIABLE.NAME = '@DAY'
            AT.VARIABLE.VALUE = @DAY
         CASE AT.VARIABLE.NAME = '@LOGNAME'
            AT.VARIABLE.VALUE = @LOGNAME
         CASE AT.VARIABLE.NAME = '@MONTH'
            AT.VARIABLE.VALUE = @MONTH
         CASE AT.VARIABLE.NAME = '@PATH'
            AT.VARIABLE.VALUE = @PATH
         CASE AT.VARIABLE.NAME = '@SYSTEM.RETURN.CODE'
            AT.VARIABLE.VALUE = @SYSTEM.RETURN.CODE
         CASE AT.VARIABLE.NAME = '@TIME'
            AT.VARIABLE.VALUE = @TIME
         CASE AT.VARIABLE.NAME = '@YEAR'
            AT.VARIABLE.VALUE = @YEAR
         CASE 1
            AT.VARIABLE.VALUE = AT.VARIABLE.NAME
      END CASE
      RETURN



*
*
* FINISH DOWNLOAD FIELDS PUT VALUES BACK IN ARRAYS & LISTS
*
FOF.PUT.VALUES: 
      OUT.LINE.LIST(OUT.REC.CTR)<FIELD.CTR> = LINE.VALUE
      OUT.LENGTH.LIST(OUT.REC.CTR)<FIELD.CTR> = LENGTH.VALUE
      OUT.BEG.COL.LIST(OUT.REC.CTR)<FIELD.CTR> = BEG.COL.VALUE
      OUT.END.COL.LIST(OUT.REC.CTR)<FIELD.CTR> = END.COL.VALUE
      OUT.FMT.LIST(OUT.REC.CTR)<FIELD.CTR> = FMT.VALUE
      OUT.FIELD.FMT.LIST(OUT.REC.CTR)<FIELD.CTR> = FIELD.FMT
      OUT.CONV.LIST(OUT.REC.CTR)<FIELD.CTR> = CONV.VALUE
      OUT.HTML.START.LIST(OUT.REC.CTR)<FIELD.CTR> = HTML.START.VALUE
      OUT.HTML.END.LIST(OUT.REC.CTR)<FIELD.CTR> = HTML.END.VALUE
      OUT.HTML.CELL.LIST(OUT.REC.CTR)<FIELD.CTR> = HTML.CELL.VALUE
      OUT.HTML.ROW.LIST(OUT.REC.CTR) = HTML.ROW.VALUE
      OUT.XML.NAME.LIST(OUT.REC.CTR)<FIELD.CTR> = OUT.XML.NAME
      OUT.XML.ASSOC.NAME.LIST(OUT.REC.CTR)<FIELD.CTR> = OUT.XML.ASSOC.NAME
      OUT.XML.SUBASSOC.NAME.LIST(OUT.REC.CTR)<FIELD.CTR> = OUT.XML.SUBASSOC.NAME
      OUT.SM.LIST(OUT.REC.CTR)<FIELD.CTR> = SM.VALUE
      OUT.FIELD.CONV.LIST(OUT.REC.CTR)<FIELD.CTR> = FIELD.CONV
      OUT.NUM.VALUES.LIST(OUT.REC.CTR)<FIELD.CTR> = NUM.VALUES.VALUE
      OUT.NUM.SUBVALUES.LIST(OUT.REC.CTR)<FIELD.CTR> = NUM.SUBVALUES.VALUE
      OUT.MV.ORIENTATION.LIST(OUT.REC.CTR)<FIELD.CTR> = MV.ORIENTATION.VALUE
      OUT.VALUE.SEPARATOR.LIST(OUT.REC.CTR)<FIELD.CTR> = VALUE.SEPARATOR.VALUE
      OUT.VALUE.SEPARATOR.SET(OUT.REC.CTR)<FIELD.CTR> = VALUE.SEPARATOR.SET.VALUE
      OUT.SUBVALUE.SEPARATOR.LIST(OUT.REC.CTR)<FIELD.CTR> = SUBVALUE.SEPARATOR.VALUE
      OUT.SUBVALUE.SEPARATOR.SET(OUT.REC.CTR)<FIELD.CTR> = SUBVALUE.SEPARATOR.SET.VALUE
      OUT.PART.OF.ASSOC.LIST(OUT.REC.CTR)<FIELD.CTR> = PART.OF.ASSOC.VALUE
      WHICH.DICT.REC.CTR = OUT.CTR.LIST(OUT.REC.CTR)<FIELD.CTR>
      IF WHICH.DICT.REC.CTR AND (OUT.TYPE = 'FIELD' OR OUT.TYPE = 'SUP') THEN
         DICT.PART.OF.ASSOC.LIST(WHICH.DICT.REC.CTR) = PART.OF.ASSOC.VALUE
      END
      OUT.NUMERIC.FLAG.LIST(OUT.REC.CTR)<FIELD.CTR> = NUMERIC.FLAG.VALUE
      OUT.DEFAULT.VALUE.LIST(OUT.REC.CTR)<FIELD.CTR> = DEFAULT.VALUE.VALUE
      RETURN


*
*
* FINISH DOWNLOAD FIELDS CONSISTENCY CHECK
*
FOF.CONSISTENCY.CHECK: 
      IF SUBVALUE.SEPARATOR.SET.VALUE THEN
         IF VALUE.SEPARATOR.SET.VALUE AND (SUBVALUE.SEPARATOR.VALUE EQ DLMAIN.COMMA) THEN
            DLMAIN.ERRMSG<-1> = 'If you specify the VALUE.SEPARATOR, then either omit the SUBVALUE.SEPARATOR qualifier or specify a SUBVALUE.SEPARATOR different than the field separator (comma character).'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      IF LINE.VALUE # '' THEN
         OKAY.LIST = 'FIXED COMMA QUOTE TAB'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': LINE ':LINE.VALUE:' can only be used with formats ':OKAY.LIST.DISPLAY:'.'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      IF HTML.CELL.VALUE # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.CELL qualifier is valid only for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF HTML.ROW.VALUE # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.ROW qualifier is valid only for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF HTML.START.VALUE # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.START qualifier is valid only for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF HTML.END.VALUE # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.END qualifier is valid only for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF BEG.COL.VALUE # '' AND DLMAIN.FORMAT # 'FIXED' THEN
         DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': BEG.COL ':BEG.COL.VALUE:' can only be used with FORMAT FIXED'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF END.COL.VALUE # '' AND DLMAIN.FORMAT # 'FIXED' THEN
         DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': END.COL ':END.COL.VALUE:' can only be used with FORMAT FIXED'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF LENGTH.VALUE # '' AND END.COL.VALUE # '' THEN
         DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': LENGTH ':LENGTH.VALUE:' and END.COL ':END.COL.VALUE:' are incompatible'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF BEG.COL.VALUE # '' AND END.COL.VALUE # '' AND BEG.COL.VALUE > END.COL.VALUE THEN
         DLMAIN.ERRMSG<-1> = 'Invalid qualifiers for ':FIELD.NAME:': BEG.COL ':BEG.COL.VALUE:' is greater than END.COL ':END.COL.VALUE
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF MV.ORIENTATION.VALUE # '' AND (DLMAIN.FORMAT = 'WP50' OR DLMAIN.FORMAT = 'WP51') THEN
         DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': MV.ORIENTATION is not valid with FORMAT WP50 or WP51'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF NUM.VALUES.VALUE = 'ALL' THEN
         OKAY.LIST = 'WP50 WP51 COMMA QUOTE TAB DIF HTML XML'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            BEGIN CASE
               CASE MV.ORIENTATION.VALUE = 'VERTICAL' AND DLMAIN.FORMAT = 'FIXED'
                  NULL
               CASE DEFAULT.MV.ORIENTATION = 'VERTICAL' AND MV.ORIENTATION.VALUE = '' AND DLMAIN.FORMAT = 'FIXED'
                  NULL
               CASE 1
                  DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': NUM.VALUES ALL is only valid with formats ':OKAY.LIST.DISPLAY
                  DLMAIN.ERRMSG<-1> = '   or FORMAT FIXED with option MV.ORIENTATION VERTICAL.'
                  DLMAIN.FATAL.ERROR = TRUE
            END CASE
         END
      END
      IF NUM.SUBVALUES.VALUE = 'ALL' THEN
         OKAY.LIST = 'FIXED COMMA QUOTE TAB WP50 WP51 DIF XML'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            BEGIN CASE
               CASE MV.ORIENTATION.VALUE = 'VERTICAL' AND DLMAIN.FORMAT = 'FIXED'
                  NULL
               CASE DEFAULT.MV.ORIENTATION = 'VERTICAL' AND MV.ORIENTATION.VALUE = '' AND DLMAIN.FORMAT = 'FIXED'
                  NULL
               CASE 1
                  DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': NUM.SUBVALUES ALL is only valid with formats ':OKAY.LIST.DISPLAY
                  DLMAIN.ERRMSG<-1> = '   or FORMAT FIXED with option MV.ORIENTATION VERTICAL.'
                  DLMAIN.FATAL.ERROR = TRUE
            END CASE
         END
      END
      IF OUT.XML.ATTRIBUTE = TRUE AND FIELD.SM = 'M' THEN
         DLMAIN.ERRMSG<-1> = 'XML.ATTRIBUTE cannot be used with multi-valued fields.'
      END
      RETURN


*
*
* FINISH DOWNLOAD FIELDS FILL IN MISSING INFORMATION
*
FOF.FILL.IN.MISSING: 
      IF FMT.VALUE = '' THEN
         FMT.VALUE = DEFAULT.FMT
      END
      IF CONV.VALUE = '' THEN
         CONV.VALUE = DEFAULT.CONV
      END
      IF HTML.START.VALUE = '' THEN
         HTML.START.VALUE = DEFAULT.HTML.START
      END
      IF HTML.END.VALUE = '' THEN
         HTML.END.VALUE = DEFAULT.HTML.END
      END
      IF HTML.CELL.VALUE = '' THEN
         HTML.CELL.VALUE = DEFAULT.HTML.CELL
      END
      IF HTML.ROW.VALUE = '' THEN
         HTML.ROW.VALUE = DEFAULT.HTML.ROW
      END
      IF LENGTH.VALUE = '' THEN
         LENGTH.VALUE = DEFAULT.LENGTH
      END
      IF SM.VALUE = '' THEN
         IF FIELD.SM = '' THEN
            SM.VALUE = DEFAULT.SM
         END ELSE
            SM.VALUE = FIELD.SM
         END
      END
      IF MV.ORIENTATION.VALUE = '' THEN
         MV.ORIENTATION.VALUE = DEFAULT.MV.ORIENTATION
      END
      IF VALUE.SEPARATOR.VALUE = '' THEN
         IF SET.DEFAULT.VALUE.SEPARATOR THEN
            VALUE.SEPARATOR.VALUE = DEFAULT.VALUE.SEPARATOR
            VALUE.SEPARATOR.SET.VALUE = TRUE
         END
      END
      IF SUBVALUE.SEPARATOR.VALUE = '' THEN
         IF SET.DEFAULT.SUBVALUE.SEPARATOR THEN
            SUBVALUE.SEPARATOR.VALUE = VALUE.SEPARATOR.VALUE
            SUBVALUE.SEPARATOR.SET.VALUE = TRUE
         END
      END
      IF DEFAULT.VALUE.VALUE = '' THEN
         DEFAULT.VALUE.VALUE = DEFAULT.DEFAULT.VALUE
      END
      IF DLMAIN.FORMAT = 'XML' THEN
         IF OUT.XML.NAME = '' THEN
            X.ITEM.OUT = ''
            X.ITEM = FIELD.NAME
            X.DO.LOWER.CASE = TRUE
            CALL DLXMLELEM(X.ITEM.OUT,X.ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML field name "':X.ITEM:'" does not generate a valid XML name.'
               DLMAIN.FATAL.ERROR = TRUE
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               OUT.XML.NAME = X.ITEM.OUT
            END
         END
         IF FIELD.SM = 'M' AND OUT.XML.ASSOC.NAME = '' THEN
            X.ITEM.OUT = ''
            X.ITEM = FIELD.ASSOC
            X.DO.LOWER.CASE = TRUE
            CALL DLXMLELEM(X.ITEM.OUT,X.ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML association name "':X.ITEM:'" (field "':FIELD.NAME:'") does not generate a valid XML name.'
               DLMAIN.FATAL.ERROR = TRUE
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               OUT.XML.ASSOC.NAME = X.ITEM.OUT
            END
         END
      END
*
* DETERMINE WHICH CODES WILL BE USED (TO CHECK OUTPUT LENGTHS, ETC.)
*
      GOSUB FOF.USE.FMT.CONV
*
* DETERMINE IS THIS FIELD IS PART OF THE "WHEN" ASSOCIATION
*
      IF SM.VALUE = 'M' THEN
         GOSUB FOF.CHECK.FOR.MATCHING.ASSOC.NAME
         IF WHEN.ASSOC.NAME.MATCHES THEN
            PART.OF.ASSOC.VALUE = TRUE
         END
      END
*
* FINISHING THE FIELDS IS A 2-PASS OPERATION,
*   SO ASSOCIATED FIELDS THAT DO NOT HAVE AN EXPLICIT
*   NUM.VALUES CLAUSE ARE NOT HANDLED HERE, BUT
*   IN FOF.ASSOC.NUM.VALUES
*
      IF NUM.VALUES.VALUE = '' THEN
         IF SM.VALUE # 'M' THEN
            NUM.VALUES.VALUE = 1
         END ELSE
            IF FIELD.ASSOC = '' THEN
               NUM.VALUES.VALUE = DEFAULT.NUM.VALUES
            END
         END
      END ELSE
         IF FIELD.ASSOC # '' THEN
            LOCATE FIELD.ASSOC IN ASSOC.NAME.LIST<1> SETTING ASSOC.NAME.POS ELSE
               ASSOC.NAME.LIST<ASSOC.NAME.POS> = FIELD.ASSOC
            END
            IF ASSOC.NUM.VALUES.LIST<ASSOC.NAME.POS> = '' THEN
               ASSOC.NUM.VALUES.LIST<ASSOC.NAME.POS> = NUM.VALUES.VALUE
            END
         END
      END
      IF NUM.SUBVALUES.VALUE = '' THEN
         IF SM.VALUE # 'M' THEN
            NUM.SUBVALUES.VALUE = 1
         END ELSE
            IF FIELD.ASSOC = '' THEN
               NUM.SUBVALUES.VALUE = DEFAULT.NUM.SUBVALUES
            END
         END
      END ELSE
         IF FIELD.ASSOC # '' THEN
            LOCATE FIELD.ASSOC IN ASSOC.NAME.LIST<1> SETTING ASSOC.NAME.POS ELSE
               ASSOC.NAME.LIST<ASSOC.NAME.POS> = FIELD.ASSOC
            END
            IF ASSOC.NUM.SUBVALUES.LIST<ASSOC.NAME.POS> = '' THEN
               ASSOC.NUM.SUBVALUES.LIST<ASSOC.NAME.POS> = NUM.SUBVALUES.VALUE
            END
         END
      END
      RETURN


*
*
* CHECK FOR A MATCH WITH THE WHEN.ASSOC NAME
*
FOF.CHECK.FOR.MATCHING.ASSOC.NAME: 
      WHEN.ASSOC.NAME.MATCHES = FALSE
      IF WHEN.ASSOC.NAME.IS.FIELD.NAME THEN
         IF WHEN.ASSOC.NAME = FIELD.NAME THEN
            WHEN.ASSOC.NAME.MATCHES = TRUE
         END
      END ELSE
         IF WHEN.ASSOC.NAME # '' AND WHEN.ASSOC.NAME = FIELD.ASSOC THEN
            WHEN.ASSOC.NAME.MATCHES = TRUE
         END
      END
      RETURN


*
*
* CREATE USE.FMT & USE.CONV
*
FOF.USE.FMT.CONV: 
      BEGIN CASE
         CASE FMT.VALUE = NULL.CODE
            USE.FMT.VALUE = ''
         CASE FMT.VALUE = ''
            USE.FMT.VALUE = FIELD.FMT
         CASE 1
            USE.FMT.VALUE = FMT.VALUE
      END CASE
      BEGIN CASE
         CASE CONV.VALUE = NULL.CODE
            USE.CONV.VALUE = ''
         CASE CONV.VALUE = ''
            USE.CONV.VALUE = FIELD.CONV
         CASE 1
            USE.CONV.VALUE = CONV.VALUE
      END CASE
      RETURN


*
*
* FINISH DOWNLOAD FIELDS CHECK LINE VALUE
*   MAKE SURE WE HAVE A LINE #
*   FOR FIXED FORMAT, MAKE SURE WE HAVE A BEG.COL & LENGTH
*
FOF.CHECK.LINE.VALUE: 
      IF LINE.VALUE = '' THEN
         IF CUR.LINE = '' THEN
            LINE.VALUE = DEFAULT.LINE
         END ELSE
            IF DLMAIN.RECORD.ORIENTATION = 'HORIZONTAL' THEN
               LINE.VALUE = LAST.LINE.VALUE
            END ELSE
               LINE.VALUE = CUR.LINE + 1
            END
         END
      END
      IF NUM.VALUES.VALUE # '' AND NUM(NUM.VALUES.VALUE) AND (MV.ORIENTATION.VALUE = 'VERTICAL' OR DLMAIN.RECORD.ORIENTATION = 'VERTICAL') THEN
         IF NUM.SUBVALUES.VALUE # '' AND NUM(NUM.SUBVALUES.VALUE) THEN
            CUR.LINE = LINE.VALUE + NUM.VALUES.VALUE*NUM.SUBVALUES.VALUE - 1
         END ELSE
            CUR.LINE = LINE.VALUE + NUM.VALUES.VALUE - 1
         END
      END ELSE
         CUR.LINE = LINE.VALUE
      END
      RETURN


*
*
* FINISH DOWNLOAD FIELDS CHECK COLUMN VALUES
*   FOR FIXED FORMAT, MAKE SURE WE HAVE A BEG.COL & LENGTH
*
FOF.CHECK.COLUMN.VALUES: 
      GOSUB FOF.USE.FMT.CONV
      IF LAST.COL.USED.LIST<LINE.VALUE> = '' THEN
         CUR.COL = DEFAULT.BEG.COL
         LAST.COL.USED.LIST<LINE.VALUE> = CUR.COL - 1
      END ELSE
         CUR.COL = LAST.COL.USED.LIST<LINE.VALUE> + 1 + DLMAIN.FIELD.GAP
      END
      IF BEG.COL.VALUE = '' THEN
         BEG.COL.VALUE = CUR.COL
      END
      IF END.COL.VALUE = '' THEN
         IF LENGTH.VALUE = '' THEN
            LENGTH.VALUE = LEN(FMT('',USE.FMT.VALUE))
         END
         IF MV.ORIENTATION.VALUE = 'HORIZONTAL' THEN
            VALUE.MULTIPLIER = NUM.VALUES.VALUE * NUM.SUBVALUES.VALUE
         END ELSE
            VALUE.MULTIPLIER = 1
         END
         END.COL.VALUE = BEG.COL.VALUE + LENGTH.VALUE*VALUE.MULTIPLIER - 1
      END ELSE
         IF MV.ORIENTATION.VALUE = 'HORIZONTAL' THEN
            VALUE.DIVISOR = NUM.VALUES.VALUE * NUM.SUBVALUES.VALUE
         END ELSE
            VALUE.DIVISOR = 1
         END
         LENGTH.VALUE = INT(END.COL.VALUE - BEG.COL.VALUE + 1) / VALUE.DIVISOR
      END
      IF END.COL.VALUE > LAST.COL.USED.LIST<LINE.VALUE> THEN
         LAST.COL.USED.LIST<LINE.VALUE> = END.COL.VALUE
      END
      RETURN


*
*
* FINISH DOWNLOAD FIELDS ASSOC NUM.VALUES
*
FOF.ASSOC.NUM.VALUES: 
      IF FIELD.ASSOC # '' AND NUM.VALUES.VALUE = '' THEN
         LOCATE FIELD.ASSOC IN ASSOC.NAME.LIST<1> SETTING ASSOC.NAME.POS THEN
            NUM.VALUES.VALUE = ASSOC.NUM.VALUES.LIST<ASSOC.NAME.POS>
         END
      END
      IF NUM.VALUES.VALUE = '' THEN
         NUM.VALUES.VALUE = DEFAULT.NUM.VALUES
      END
      IF FIELD.ASSOC # '' AND NUM.SUBVALUES.VALUE = '' THEN
         LOCATE FIELD.ASSOC IN ASSOC.NAME.LIST<1> SETTING ASSOC.NAME.POS THEN
            NUM.SUBVALUES.VALUE = ASSOC.NUM.SUBVALUES.LIST<ASSOC.NAME.POS>
         END
      END
      IF NUM.SUBVALUES.VALUE = '' THEN
         NUM.SUBVALUES.VALUE = DEFAULT.NUM.SUBVALUES
      END
      RETURN


*
*
* FINISH DOWNLOAD FIELDS, DETERMINE IF A FIELD IS NUMERIC (USED
*      IN COMMA & DIF FORMATS)
*  IF THERE IS A NUMERIC (MD...) CONVERION FLAG, THEN ASSUME FIELD
*    IS NUMERIC.  IF THERE IS NO CONVERSION FLAG, THEN IF IT IS RIGHT
*    JUSTIFIED, ASSUME IT IS NUMERIC
*
FOF.DETERMINE.NUMERIC: 
      BEGIN CASE
         CASE CONV.VALUE = NULL.CODE
            NULL
         CASE CONV.VALUE[1,2] = 'MD'
            NUMERIC.FLAG.VALUE = TRUE
         CASE CONV.VALUE # ''
            NULL
         CASE FIELD.CONV[1,2] = 'MD'
            NUMERIC.FLAG.VALUE = TRUE
         CASE FIELD.CONV # ''
            NULL
         CASE FMT.VALUE = NULL.CODE
            NULL
         CASE INDEX(FMT.VALUE,'R',1) > 0
            NUMERIC.FLAG.VALUE = TRUE
         CASE FMT.VALUE # ''
            NULL
         CASE INDEX(FIELD.FMT,'R',1) > 0
            NUMERIC.FLAG.VALUE = TRUE
      END CASE
      RETURN


*
*
* FINISH BREAK FIELDS
*
FINISH.BREAK.FIELDS: 
      IF DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> = '' THEN
         DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> = DEFAULT.OUT.REC
      END
      IF DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> = KEYWORD.NONE THEN
         DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> = ''
      END
      RETURN




*******************************************************************************
**
**   POST-ITEM PROCESSING (DO THESE THINGS AFTER PROCESSING ITEMS, BUT BEFORE
**       PROCESSING DATA RECORD
**
*******************************************************************************
POST.ITEMS.PROCESSING: 
      BEGIN CASE
         CASE DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS'
            GOSUB OP.SYS.OPENFILE
         CASE DLMAIN.PRINT.METHOD = 'WRITESEQ'
            GOSUB OPEN.TYPE1.FILE
      END CASE
      RETURN

*
*
* OPEN TYPE1 FILE
*
OPEN.TYPE1.FILE: 
      IF DLMAIN.DEBUG.LEVEL GT 0 THEN
         CRT 'Opening ':DLMAIN.TYPE1.RECORD.NAME
      END
      OPENSEQ DLMAIN.TYPE1.FILE.NAME, DLMAIN.TYPE1.RECORD.NAME TO DLMAIN.F.TYPE1.FILE THEN
         IF DLMAIN.OVERWRITING THEN
            WEOFSEQ DLMAIN.F.TYPE1.FILE
         END ELSE
            IF DLMAIN.APPEND THEN
               NULL
            END ELSE
               DLMAIN.ERRMSG<-1> = '"':DLMAIN.TYPE1.FILE.NAME:'" "':DLMAIN.TYPE1.RECORD.NAME:'" already exists'
               DLMAIN.FATAL.ERROR = TRUE
            END
         END
      END
      RETURN


DISPLAY.DICT.FIELD.LIST: 
      CRT
      CRT 'NUM.DICT.RECS = ':NUM.DICT.RECS
      FOR DICT.CTR=1 TO NUM.DICT.RECS
         CRT FMT(DICT.CTR,'2R'):' ':
         CRT FMT(DICT.REC.FIELD.LIST<DICT.CTR>[1,15],'16L'):
         CRT FMT(DICT.REC.FILE.NUM(DICT.CTR),'3R'):' ':
         CRT FMT(DICT.RECS(DICT.CTR)<7>[1,15],'16L'):
         CRT '"':DICT.PART.OF.ASSOC.LIST(DICT.CTR):'"'
      NEXT DICT.CTR
      INPUT CRT.PAUSE
      RETURN


PRINT.HELP: 
      READ VOC.HELP.REC FROM DLMAIN.F.VOC, 'DOWNLOAD.HELP' THEN
         VOC.TYPE = FIELD(VOC.HELP.REC<1>,' ',1,1)
         IF VOC.TYPE = 'S' OR VOC.TYPE = 'PA' OR VOC.TYPE = 'C' THEN
            EXECUTE 'DOWNLOAD.HELP'
            STOP
         END
      END
      CRT
      CRT 'DOWNLOAD.HELP is not available.  Contact your system administrator.'
      RETURN


FINISH.HEADING: 
      IF NOT(DETAIL.OUT.REC) THEN
         RETURN
      END
      IF NOT(HEADING.OUT.REC.USE.FIELD.NAMES) AND NOT(HEADING.OUT.REC.USE.FIELD.LABELS) THEN
         RETURN
      END
      HEADING.CTR = 0
      FOR FIELD.CTR = 1 TO NUM.OUT.FIELDS(DETAIL.OUT.REC)
         X.ORIG.ITEM = OUT.FIELD.LIST(DETAIL.OUT.REC)<FIELD.CTR>
         X.OUT.MV.ORIENTATION = OUT.MV.ORIENTATION.LIST(DETAIL.OUT.REC)<FIELD.CTR>
         IF HEADING.OUT.REC.USE.FIELD.LABELS THEN
            LOCATE X.ORIG.ITEM IN DICT.REC.FIELD.LIST<1> SETTING WHICH.DICT.REC.CTR THEN
               X.ORIG.ITEM = DICT.RECS(WHICH.DICT.REC.CTR)<4>
               CONVERT @VM TO ' ' IN X.ORIG.ITEM
            END
         END
         X.NUM.VALUES.VALUE = OUT.NUM.VALUES.LIST(DETAIL.OUT.REC)<FIELD.CTR>
         IF NUM(X.NUM.VALUES.VALUE) THEN
            IF X.NUM.VALUES.VALUE LT 1 THEN
               X.NUM.VALUES.VALUE = 1
            END
            IF (X.OUT.MV.ORIENTATION = 'VERTICAL') AND (DLMAIN.RECORD.ORIENTATION = 'HORIZONTAL') THEN
               X.NUM.VALUES.VALUE = 1
            END
            IF DLMAIN.FORMAT = 'HTML' THEN
               X.NUM.VALUES.VALUE = 1
            END
         END ELSE
            X.NUM.VALUES.VALUE = 1
         END
         FOR WHICH.NUM.VALUES.VALUE = 1 TO X.NUM.VALUES.VALUE
            IF X.NUM.VALUES.VALUE GT 1 THEN
               ITEM = X.ORIG.ITEM:'_':WHICH.NUM.VALUES.VALUE
            END ELSE
               ITEM = X.ORIG.ITEM
            END
            CALC.ITEM.LEN = LEN(ITEM)
            DLMAIN.NUM.LITERAL.VALUES += 1
            DLMAIN.LITERAL.VALUE.LIST<DLMAIN.NUM.LITERAL.VALUES> = ITEM
            HEADING.CTR += 1
            OUT.FIELD.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = 'LITERAL ':ITEM.QUOTED:ITEM:ITEM.QUOTED
            OUT.TYPE.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = 'LITERAL'
            OUT.CTR.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = DLMAIN.NUM.LITERAL.VALUES
            IF DLMAIN.FORMAT = 'FIXED' OR DLMAIN.FORMAT = 'DBF' THEN
               OUT.FMT.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = OUT.LENGTH.LIST(DETAIL.OUT.REC)<FIELD.CTR>:'L'
               OUT.LENGTH.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = OUT.LENGTH.LIST(DETAIL.OUT.REC)<FIELD.CTR>
               OUT.BEG.COL.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = OUT.BEG.COL.LIST(DETAIL.OUT.REC)<FIELD.CTR>
               OUT.END.COL.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = OUT.END.COL.LIST(DETAIL.OUT.REC)<FIELD.CTR>
            END ELSE
               OUT.FMT.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = CALC.ITEM.LEN:'L'
               OUT.LENGTH.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = CALC.ITEM.LEN
               IF DLMAIN.RECORD.ORIENTATION = 'HORIZONTAL' THEN
                  OUT.LINE.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = 1
               END ELSE
                  OUT.LINE.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = HEADING.CTR
               END
            END
         NEXT WHICH.NUM.VALUES.VALUE
      NEXT FIELD.CTR
      NUM.OUT.FIELDS(DLMAIN.HEADING.OUT.REC) = HEADING.CTR
      RETURN


CHECK.VARIABLE.FILE.NAME: 
      ITEM = ITEM.LIST<FILE.POS+1>
      IF ITEM # '' THEN
         GOSUB CHECK.AT.VARIABLE.SUBSTRING
         ITEM.LIST<FILE.POS+1> = ITEM
         ITEM = ITEM.LIST<FILE.POS+2>
         IF ITEM # '' THEN
            GOSUB CHECK.AT.VARIABLE.SUBSTRING
            ITEM.LIST<FILE.POS+2> = ITEM
         END
      END
      RETURN


CHECK.AT.VARIABLE.SUBSTRING: 
      FOR WHICH.NUM.AT.VARIABLES = 1 TO NUM.AT.VARIABLES UNTIL INDEX(ITEM,'@',1) = 0
         AT.VARIABLE.ITEM = AT.VARIABLE.LIST<WHICH.NUM.AT.VARIABLES>
         AT.ITEM.INDEX = INDEX(ITEM,AT.VARIABLE.ITEM,1)
         IF AT.ITEM.INDEX GT 0 THEN
            AT.VARIABLE.NAME = AT.VARIABLE.ITEM
            LEN.AT.VARIABLE.NAME = LEN(AT.VARIABLE.NAME)
            GOSUB GET.AT.VARIABLE.VALUE
            BEGIN CASE
               CASE AT.ITEM.INDEX = 1
                  ITEM = AT.VARIABLE.VALUE:ITEM[LEN.AT.VARIABLE.NAME+1,LEN(ITEM)]
               CASE AT.ITEM.INDEX + LEN.AT.VARIABLE.NAME - 1 = LEN(ITEM)
                  ITEM = ITEM[1,AT.ITEM.INDEX-1]:AT.VARIABLE.VALUE
               CASE 1
                  ITEM = ITEM[1,AT.ITEM.INDEX-1]:AT.VARIABLE.VALUE:ITEM[AT.ITEM.INDEX+LEN.AT.VARIABLE.NAME,LEN(ITEM)]
            END CASE
         END
      NEXT WHICH.NUM.AT.VARIABLES
      RETURN


CHECK.FOR.SYNONYMS: 
      LOCATE ITEM IN SYNONYM.LIST<1> SETTING SYNONYM.POS THEN
         ITEM = SYNONYM.VALUE.LIST<SYNONYM.POS>
      END
      RETURN



*
   END
