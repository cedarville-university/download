      SUBROUTINE DOWNLOAD.PARSE
*
* INFO/BASIC SUBROUTINE
* 11/27/90
* DWS
* TITLE ----- DOWNLOAD.PARSE
*
*
* PURPOSE: PARSE COMMAND LINE/INPUT LINES INTO APPROPRIATE VARIABLES/VALUES
*
*
*************************************************************************
* Stamped: p4 rotmand, /usr/local/collive, user #4051, 06 Sep 03, 03:15PM.
* Version 7.00
*
*
*
*
*
*
*

      $INCLUDE IDLMAX
      $INCLUDE IDLMAIN
      $INCLUDE IDLDATA
      $INCLUDE IDLDBMS
      $INCLUDE IDLOPSYS
      $INCLUDE IWHICHDBMS
      $INCLUDE IWHICHOPSYS
      $INCLUDE IDLOUTREC
      $INCLUDE IDLWHEN
      $INCLUDE IDLSUBR
      $INCLUDE IDBF

      DIM F.DICT.FILE(DLMAX.FILES)
      DIM ALIAS.SET(DLMAX.FILES)
      DIM X.FILE.NUM.VALUES(DLMAX.FILES)
      MAT X.FILE.NUM.VALUES = ''

      DEBUG1OR2
      CRT 'INSIDE DOWNLOAD.PARSE'
      END

      GOSUB SET.UP
      IF NOT(DLMAIN.FATAL.ERROR) THEN
         GOSUB PRE.ITEMS.PROCESSING
      END
      IF NOT(DLMAIN.FATAL.ERROR) THEN
         GOSUB PROCESS.REGULAR.ITEMS
      END
      IF NOT(DLMAIN.FATAL.ERROR) THEN
         GOSUB FINISH.ITEMS
      END
      IF NOT(DLMAIN.FATAL.ERROR) THEN
         GOSUB POST.ITEMS.PROCESSING
      END
      RETURN


*******************************************************************************
**
**   SET UP ROUTINES
**
*******************************************************************************
SET.UP: 
      GOSUB SET.UP.MISC
      GOSUB SET.UP.OPTION.LISTS
      GOSUB SET.UP.KEYWORD.VALUES
      GOSUB SET.UP.AT.VARIABLE.LIST
      GOSUB DBMS.SET.UP
      GOSUB OP.SYS.SET.UP
      RETURN

SET.UP.MISC: 
      PRIMARY.DICT.OPENED = FALSE
      DOWNLOAD.PROMPT = 'DL> '
      OPEN '', 'VOC' TO DLMAIN.F.VOC ELSE
         DLMAIN.ERRMSG<-1> = 'Can not open "VOC"'
         DLMAIN.FATAL.ERROR = TRUE
      END
      X.PRIMARY.LIST.NAME = ''
      PROMPT ''
      CUR.OUT.REC = DL.OUTR.DETAIL.OUT.REC
      MAT DL.OUTR.DEFAULT.VALUE.LIST = ''
      DL.DATA.SECONDARY.FIELD.FLAG = '->'
      LEN.SECONDARY.FIELD.FLAG = LEN(DL.DATA.SECONDARY.FIELD.FLAG)
      LOOKUP.FIELD.NAME = TRUE
      LOOKUP.FILE.NAME = FALSE
      HEADING.OUT.REC.USE.FIELD.NAMES = FALSE
      HEADING.OUT.REC.USE.FIELD.LABELS = FALSE
      XML.UPCASE = FALSE
      XML.ALLOW.PERIODS = FALSE
      RETURN


SET.UP.OPTION.LISTS: 
      FORMAT.TYPE.LIST = ''
      FORMAT.TYPE.LIST<1,1> = 'FIXED'
      FORMAT.TYPE.LIST<2,1> = 'FIXED'
      FORMAT.TYPE.LIST<1,2> = 'QUOTE'
      FORMAT.TYPE.LIST<2,2> = 'QUOTE'
      FORMAT.TYPE.LIST<1,3> = 'WORDPERFECT.5.0'
      FORMAT.TYPE.LIST<2,3> = 'WP50'
      FORMAT.TYPE.LIST<1,4> = 'WORDPERFECT50'
      FORMAT.TYPE.LIST<2,4> = 'WP50'
      FORMAT.TYPE.LIST<1,5> = 'WP50'
      FORMAT.TYPE.LIST<2,5> = 'WP50'
      FORMAT.TYPE.LIST<1,6> = 'WORDPERFECT.5.1'
      FORMAT.TYPE.LIST<2,6> = 'WP51'
      FORMAT.TYPE.LIST<1,7> = 'WORDPERFECT51'
      FORMAT.TYPE.LIST<2,7> = 'WP51'
      FORMAT.TYPE.LIST<1,8> = 'WP51'
      FORMAT.TYPE.LIST<2,8> = 'WP51'
      FORMAT.TYPE.LIST<1,9> = 'WORDPERFECT'
      FORMAT.TYPE.LIST<2,9> = 'WP50'
      FORMAT.TYPE.LIST<1,10> = 'COMMA'
      FORMAT.TYPE.LIST<2,10> = 'COMMA'
      FORMAT.TYPE.LIST<1,11> = 'DIF'
      FORMAT.TYPE.LIST<2,11> = 'DIF'
      FORMAT.TYPE.LIST<1,12> = 'DBF'
      FORMAT.TYPE.LIST<2,12> = 'DBF'
      FORMAT.TYPE.LIST<1,13> = 'DBASE'
      FORMAT.TYPE.LIST<2,13> = 'DBF'
      FORMAT.TYPE.LIST<1,14> = 'HTML'
      FORMAT.TYPE.LIST<2,14> = 'HTML'
      FORMAT.TYPE.LIST<1,15> = 'TAB'
      FORMAT.TYPE.LIST<2,15> = 'TAB'
      FORMAT.TYPE.LIST<1,16> = 'XML'
      FORMAT.TYPE.LIST<2,16> = 'XML'
*
      ORIENTATION.TYPE.LIST = 'HORIZONTAL'
      ORIENTATION.TYPE.LIST := @FM:'VERTICAL'
*
      OPTION.LIST = 'DISPLAY.COUNT'
      OPTION.LIST := @FM:'NO.DISPLAY.COUNT'
      OPTION.LIST := @FM:'PROGRESS.INTERVAL'
      OPTION.LIST := @FM:'WRITE.INTERVAL'
      OPTION.LIST := @FM:'NO.PAGE'
      OPTION.LIST := @FM:'NOPAGE'
      OPTION.LIST := @FM:'PRINT.ERRORS'
      OPTION.LIST := @FM:'NO.PRINT.ERRORS'
      OPTION.LIST := @FM:'PRINT.LAYOUT'
      OPTION.LIST := @FM:'LPTR'
      OPTION.LIST := @FM:'DEBUG.LEVEL'
      OPTION.LIST := @FM:'SAMPLE'
      OPTION.LIST := @FM:'FROM'
      OPTION.LIST := @FM:'DEFAULT'
      OPTION.LIST := @FM:'FORMAT'
      OPTION.LIST := @FM:'FILE'
      OPTION.LIST := @FM:'BY.EXP'
      OPTION.LIST := @FM:'WHEN'
      OPTION.LIST := @FM:'RECORD.ORIENTATION'
      OPTION.LIST := @FM:'RECORD.LENGTH'
      OPTION.LIST := @FM:'NO.LINEFEED'
      OPTION.LIST := @FM:'OVERWRITING'
      OPTION.LIST := @FM:'APPEND'
      OPTION.LIST := @FM:'HEADING'
      OPTION.LIST := @FM:'DETAIL'
      OPTION.LIST := @FM:'HEADING.ON'
      OPTION.LIST := @FM:'FOOTING'
      OPTION.LIST := @FM:'FOOTING.ON'
      OPTION.LIST := @FM:'DET.SUP'
      OPTION.LIST := @FM:'BEGIN'
      OPTION.LIST := @FM:'END'
      OPTION.LIST := @FM:'QUOTE.CHAR'
      OPTION.LIST := @FM:'COMMA.CHAR'
      OPTION.LIST := @FM:'EOR.CHAR'
      OPTION.LIST := @FM:'UPCASE'
      OPTION.LIST := @FM:'REMOVE.PUNCTUATION'
      OPTION.LIST := @FM:'FIELD.GAP'
      OPTION.LIST := @FM:'HTML.TITLE'
      OPTION.LIST := @FM:'HTML.TOP'
      OPTION.LIST := @FM:'HTML.BOTTOM'
      OPTION.LIST := @FM:'HTML.TABLE'
      OPTION.LIST := @FM:'HTML.BODY'
      OPTION.LIST := @FM:'XML.FILE.NAME'
      OPTION.LIST := @FM:'XML.FILE.ATTRIBUTE'
      OPTION.LIST := @FM:'XML.ROOT.NAME'
      OPTION.LIST := @FM:'XML.ROOT.ATTRIBUTE'
      OPTION.LIST := @FM:'XML.ALLOW.PERIODS'
      OPTION.LIST := @FM:'XML.UPCASE'
      OPTION.LIST := @FM:'XML.VERSION'
*
      AT.VARIABLE.LIST = '@ACCOUNT'
      AT.VARIABLE.LIST := @FM:'@DATE'
      AT.VARIABLE.LIST := @FM:'@DAY'
      AT.VARIABLE.LIST := @FM:'@LOGNAME'
      AT.VARIABLE.LIST := @FM:'@MONTH'
      AT.VARIABLE.LIST := @FM:'@PATH'
      AT.VARIABLE.LIST := @FM:'@SYSTEM.RETURN.CODE'
      AT.VARIABLE.LIST := @FM:'@TIME'
      AT.VARIABLE.LIST := @FM:'@YEAR'
*
      MISC.KEYWORD.LIST = 'ALL'
      MISC.KEYWORD.LIST := @FM:'NONE'
      MISC.KEYWORD.LIST := @FM:'FINAL'
      MISC.KEYWORD.LIST := @FM:'DICT'
*
      MISC.FIELD.LIST = 'SUBR'
      MISC.FIELD.LIST := @FM:'LITERAL'
      MISC.FIELD.LIST := @FM:'EVAL'
*
      PREFIX.LIST = 'TOTAL'
      PREFIX.LIST := @FM:'AVERAGE'
      PREFIX.LIST := @FM:'MIN'
      PREFIX.LIST := @FM:'MAX'
      PREFIX.LIST := @FM:'BREAK.ON'
      PREFIX.LIST := @FM:'BREAK.SUP'
*
      QUALIFIER.LIST = 'LINE'
      QUALIFIER.LIST := @FM:'LENGTH'
      QUALIFIER.LIST := @FM:'BEG.COL'
      QUALIFIER.LIST := @FM:'END.COL'
      QUALIFIER.LIST := @FM:'COLUMNS'
      QUALIFIER.LIST := @FM:'FMT'
      QUALIFIER.LIST := @FM:'CONV'
      QUALIFIER.LIST := @FM:'COL.HDG'
      QUALIFIER.LIST := @FM:'HTML.START'
      QUALIFIER.LIST := @FM:'HTML.END'
      QUALIFIER.LIST := @FM:'HTML.CELL'
      QUALIFIER.LIST := @FM:'HTML.ROW'
      QUALIFIER.LIST := @FM:'XML.ATTRIBUTE'
      QUALIFIER.LIST := @FM:'XML.GROUP.NAME'
      QUALIFIER.LIST := @FM:'XML.ASSOC.NAME'
      QUALIFIER.LIST := @FM:'XML.SUBASSOC.NAME'
      QUALIFIER.LIST := @FM:'XML.NAME'
      QUALIFIER.LIST := @FM:'NUM.VALUES'
      QUALIFIER.LIST := @FM:'NUM.SUBVALUES'
      QUALIFIER.LIST := @FM:'MV.ORIENTATION'
      QUALIFIER.LIST := @FM:'VALUE.SEPARATOR'
      QUALIFIER.LIST := @FM:'SUBVALUE.SEPARATOR'
      QUALIFIER.LIST := @FM:'SINGLE.VALUE'
      QUALIFIER.LIST := @FM:'MULTI.VALUE'
      QUALIFIER.LIST := @FM:'FIELD.NAMES'
      QUALIFIER.LIST := @FM:'FIELD.LABELS'
      QUALIFIER.LIST := @FM:'DEFAULT.VALUE'
      QUALIFIER.LIST := @FM:'NO.NULLS'
*
      QUALIFIERS.WITH.NO.DEFAULT = 'END.COL'
      QUALIFIERS.WITH.NO.DEFAULT := @FM:'COLUMNS'
      QUALIFIERS.WITH.NO.DEFAULT := @FM:'MULTI.VALUE'
      QUALIFIERS.WITH.NO.DEFAULT := @FM:'SINGLE.VALUE'
*
      OPERATOR.LIST = ''
      OPERATOR.LIST<1,1> = 'EQ'
      OPERATOR.LIST<2,1> = 'EQ'
      OPERATOR.LIST<1,2> = '='
      OPERATOR.LIST<2,2> = 'EQ'
      OPERATOR.LIST<1,3> = 'NE'
      OPERATOR.LIST<2,3> = 'NE'
      OPERATOR.LIST<1,4> = '<>'
      OPERATOR.LIST<2,4> = 'NE'
      OPERATOR.LIST<1,5> = '#'
      OPERATOR.LIST<2,5> = 'NE'
      OPERATOR.LIST<1,6> = 'GE'
      OPERATOR.LIST<2,6> = 'GE'
      OPERATOR.LIST<1,7> = '>='
      OPERATOR.LIST<2,7> = 'GE'
      OPERATOR.LIST<1,8> = '=>'
      OPERATOR.LIST<2,8> = 'GE'
      OPERATOR.LIST<1,9> = 'GT'
      OPERATOR.LIST<2,9> = 'GT'
      OPERATOR.LIST<1,10> = '>'
      OPERATOR.LIST<2,10> = 'GT'
      OPERATOR.LIST<1,11> = 'LE'
      OPERATOR.LIST<2,11> = 'LE'
      OPERATOR.LIST<1,12> = '<='
      OPERATOR.LIST<2,12> = 'LE'
      OPERATOR.LIST<1,13> = '=<'
      OPERATOR.LIST<2,13> = 'LE'
      OPERATOR.LIST<1,14> = 'LT'
      OPERATOR.LIST<2,14> = 'LT'
      OPERATOR.LIST<1,15> = '<'
      OPERATOR.LIST<1,15> = 'LT'
      OPERATOR.LIST<1,16> = 'LIKE'
      OPERATOR.LIST<2,16> = 'LIKE'
      OPERATOR.LIST<1,17> = 'MATCHES'
      OPERATOR.LIST<2,17> = 'LIKE'
      OPERATOR.LIST<1,18> = 'UNLIKE'
      OPERATOR.LIST<2,18> = 'UNLIKE'
*
      PREPROCESS.LIST = 'USING'
      PREPROCESS.LIST := @FM:'SECONDARY.FILE'
      PREPROCESS.LIST := @FM:'KEY'
      PREPROCESS.LIST := @FM:'ALIAS'

      SYNONYM.LIST = 'LIT'
      SYNONYM.LIST := @FM:'CNV'
      SYNONYM.VALUE.LIST = 'LITERAL'
      SYNONYM.VALUE.LIST := @FM:'CONV'

      RETURN


*
* SET UP @ VARIABLES
*
SET.UP.AT.VARIABLE.LIST: 
      NUM.AT.VARIABLES = COUNT(AT.VARIABLE.LIST,@FM) + 1
      RETURN




*
* LOOK UP KEYWORDS (IF ANY) FOR OPTIONS, QUALIFIERS, & OPERATORS
*
SET.UP.KEYWORD.VALUES: 
      THROWAWAY.KEYWORD = ''
      CALL GETKEYWORD(THROWAWAY.KEYWORD, 'A')
*
      NUM.MISC.KEYWORDS = COUNT(MISC.KEYWORD.LIST,@FM) + 1
      MISC.KEYWORD.KEYWORD.LIST = ''
      FOR MISC.KEYWORD.CTR=1 TO NUM.MISC.KEYWORDS
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, MISC.KEYWORD.LIST<MISC.KEYWORD.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            MISC.KEYWORD.KEYWORD.LIST<MISC.KEYWORD.CTR> = KEYWORD.VALUE
         END ELSE
            MISC.KEYWORD.KEYWORD.LIST<MISC.KEYWORD.CTR> = MISC.KEYWORD.LIST<MISC.KEYWORD.CTR>
         END
      NEXT MISC.KEYWORD.CTR
      LOCATE 'ALL' IN MISC.KEYWORD.LIST<1> SETTING KEYWORD.POS THEN
         KEYWORD.ALL = MISC.KEYWORD.KEYWORD.LIST<KEYWORD.POS>
      END ELSE
         KEYWORD.ALL = 'ALL'
      END
      LOCATE 'NONE' IN MISC.KEYWORD.LIST<1> SETTING KEYWORD.POS THEN
         KEYWORD.NONE = MISC.KEYWORD.KEYWORD.LIST<KEYWORD.POS>
      END ELSE
         KEYWORD.NONE = 'NONE'
      END
      LOCATE 'FINAL' IN MISC.KEYWORD.LIST<1> SETTING KEYWORD.POS THEN
         KEYWORD.FINAL = MISC.KEYWORD.KEYWORD.LIST<KEYWORD.POS>
      END ELSE
         KEYWORD.FINAL = 'FINAL'
      END
      LOCATE 'DICT' IN MISC.KEYWORD.LIST<1> SETTING KEYWORD.POS THEN
         KEYWORD.DICT = MISC.KEYWORD.KEYWORD.LIST<KEYWORD.POS>
      END ELSE
         KEYWORD.DICT = 'DICT'
      END
*
      NUM.PREPROCESS = COUNT(PREPROCESS.LIST,@FM) + 1
      PREPROCESS.KEYWORD.LIST = ''
      FOR PREPROCESS.CTR=1 TO NUM.PREPROCESS
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, PREPROCESS.LIST<PREPROCESS.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            PREPROCESS.KEYWORD.LIST<PREPROCESS.CTR> = KEYWORD.VALUE
         END ELSE
            PREPROCESS.KEYWORD.LIST<PREPROCESS.CTR> = PREPROCESS.LIST<PREPROCESS.CTR>
         END
      NEXT PREPROCESS.CTR
*
      NUM.OPTIONS = COUNT(OPTION.LIST,@FM) + 1
      OPTION.KEYWORD.LIST = ''
      FOR OPTION.CTR=1 TO NUM.OPTIONS
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, OPTION.LIST<OPTION.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            OPTION.KEYWORD.LIST<OPTION.CTR> = KEYWORD.VALUE
         END ELSE
            OPTION.KEYWORD.LIST<OPTION.CTR> = OPTION.LIST<OPTION.CTR>
         END
      NEXT OPTION.CTR
      LOCATE 'BEGIN' IN OPTION.LIST<1> SETTING KEYWORD.POS THEN
         KEYWORD.BEGIN = OPTION.KEYWORD.LIST<KEYWORD.POS>
      END ELSE
         KEYWORD.BEGIN = 'BEGIN'
      END
      LOCATE 'END' IN OPTION.LIST<1> SETTING KEYWORD.POS THEN
         KEYWORD.END = OPTION.KEYWORD.LIST<KEYWORD.POS>
      END ELSE
         KEYWORD.END = 'END'
      END
*
      NUM.MISC.FIELDS = COUNT(MISC.FIELD.LIST,@FM) + 1
      MISC.FIELD.KEYWORD.LIST = ''
      FOR MISC.FIELD.CTR=1 TO NUM.MISC.FIELDS
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, MISC.FIELD.LIST<MISC.FIELD.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            MISC.FIELD.KEYWORD.LIST<MISC.FIELD.CTR> = KEYWORD.VALUE
         END ELSE
            MISC.FIELD.KEYWORD.LIST<MISC.FIELD.CTR> = MISC.FIELD.LIST<MISC.FIELD.CTR>
         END
      NEXT MISC.FIELD.CTR
*
      NUM.PREFIXES = COUNT(PREFIX.LIST,@FM) + 1
      PREFIX.KEYWORD.LIST = ''
      FOR PREFIX.CTR=1 TO NUM.PREFIXES
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, PREFIX.LIST<PREFIX.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            PREFIX.KEYWORD.LIST<PREFIX.CTR> = KEYWORD.VALUE
         END ELSE
            PREFIX.KEYWORD.LIST<PREFIX.CTR> = PREFIX.LIST<PREFIX.CTR>
         END
      NEXT PREFIX.CTR
*
      NUM.QUALIFIERS = COUNT(QUALIFIER.LIST,@FM) + 1
      QUALIFIER.KEYWORD.LIST = ''
      FOR QUALIFIER.CTR=1 TO NUM.QUALIFIERS
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, QUALIFIER.LIST<QUALIFIER.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            QUALIFIER.KEYWORD.LIST<QUALIFIER.CTR> = KEYWORD.VALUE
         END ELSE
            QUALIFIER.KEYWORD.LIST<QUALIFIER.CTR> = QUALIFIER.LIST<QUALIFIER.CTR>
         END
      NEXT QUALIFIER.CTR
*
      NUM.OPERATORS = COUNT(OPERATOR.LIST<1>,@VM) + 1
      OPERATOR.KEYWORD.LIST = ''
      FOR OPERATOR.CTR=1 TO NUM.OPERATORS
         KEYWORD.VALUE = ''
         CALL GETKEYWORD(KEYWORD.VALUE, OPERATOR.LIST<2,OPERATOR.CTR>)
         IF KEYWORD.VALUE AND KEYWORD.VALUE # THROWAWAY.KEYWORD THEN
            OPERATOR.KEYWORD.LIST<2,OPERATOR.CTR> = KEYWORD.VALUE
         END ELSE
            OPERATOR.KEYWORD.LIST<2,OPERATOR.CTR> = OPERATOR.LIST<2,OPERATOR.CTR>
         END
      NEXT OPERATOR.CTR
      RETURN


*******************************************************************************
**
**   OPERATING-SYSTEM SPECIFIC SUBROUTINES
**      AN ATTEMPT HAS BEEN MADE TO ISOLATE ALL OPERATING SYSTEM SPECIFIC
**      CHANGES TO THE FOLLOWING SET OF SUBROUTINES
**
*******************************************************************************
DBMS.SET.UP: 
      XL.IGNORE.OPTION = ''
      BEGIN CASE
         CASE DBMS.NAME = 'INFORMATION'
            GOSUB DBMS.INFORMATION.SET.UP
         CASE DBMS.NAME = 'UNIDATA'
            GOSUB DBMS.UNIDATA.SET.UP
         CASE DBMS.NAME = 'UNIVERSE'
            GOSUB DBMS.UNIVERSE.SET.UP
      END CASE
      RETURN

DBMS.INFORMATION.SET.UP: 
      DBMS.COMMAND.LINE = @SENTENCE
      DBMS.COMMAND.LINE.ITEMS.TO.SKIP = 3
      DBMS.ACCOUNT.PATH.NAME = @PATH
      DBMS.DICT.FIELD.TO.CHECK = 17
      DBMS.PATH.DELIM = '>'
      DBMS.HIGHEST.SELECT.UNIT = 10
      DBMS.VOC.ITEM.TYPE.LIST = 'D,I,X,F,K,PH'
      CONVERT ',' TO @FM IN DBMS.VOC.ITEM.TYPE.LIST
      RETURN

DBMS.UNIDATA.SET.UP: 
      DBMS.COMMAND.LINE = @SENTENCE
      DBMS.COMMAND.LINE.ITEMS.TO.SKIP = 1
      DBMS.ACCOUNT.PATH.NAME = @ACCOUNT
      DBMS.DICT.FIELD.TO.CHECK = 8
      DBMS.PATH.DELIM = '/'
      DBMS.HIGHEST.SELECT.UNIT = 9
      DBMS.VOC.ITEM.TYPE.LIST = 'DIR,D,I,X,F,K,PH'
      CONVERT ',' TO @FM IN DBMS.VOC.ITEM.TYPE.LIST
      RETURN


DBMS.UNIVERSE.SET.UP: 
      DBMS.COMMAND.LINE = @SENTENCE
      DBMS.COMMAND.LINE.ITEMS.TO.SKIP = 1
      DBMS.ACCOUNT.PATH.NAME = @ACCOUNT
      DBMS.DICT.FIELD.TO.CHECK = 17
      DBMS.PATH.DELIM = '/'
      DBMS.HIGHEST.SELECT.UNIT = 9
      DBMS.VOC.ITEM.TYPE.LIST = 'DIR,D,I,X,F,K,PH'
      CONVERT ',' TO @FM IN DBMS.VOC.ITEM.TYPE.LIST
      XL.IGNORE.OPTION = 'FMT'
      CONVERT ' ' TO @VM IN XL.IGNORE.OPTION
      RETURN


OP.SYS.SET.UP: 
      BEGIN CASE
         CASE OP.SYS.NAME = 'PRIMOS'
            GOSUB OP.SYS.PRIMOS.SET.UP
         CASE OP.SYS.NAME = 'UNIX'
            GOSUB OP.SYS.UNIX.SET.UP
         CASE OP.SYS.NAME = 'WINDOWS'
            GOSUB OP.SYS.WINDOWS.SET.UP
      END CASE
      RETURN

OP.SYS.PRIMOS.SET.UP: 
      OP.SYS.PATH.DELIM = '>'
      RETURN

OP.SYS.UNIX.SET.UP: 
      OP.SYS.PATH.DELIM = '/'
      RETURN


OP.SYS.WINDOWS.SET.UP: 
      OP.SYS.PATH.DELIM = '\'
      RETURN


*
* OPERATING SYSTEM DEPENDENT FILE I/O
*
OP.SYS.OPENFILE: 
      DEBUG2
      CRT 'GOSUB OP.SYS.OPENFILE'
      END
      BEGIN CASE
         CASE OP.SYS.NAME = 'PRIMOS'
            GOSUB OP.SYS.POPEN
         CASE OP.SYS.NAME = 'UNIX'
            GOSUB OP.SYS.UNIX.OPENFILE
         CASE OP.SYS.NAME = 'WINDOWS'
            GOSUB OP.SYS.WINDOWS.OPENFILE
      END CASE
      RETURN

*
* PRIMOS FILE I/O/ ROUTINES
*
*
* OPEN A PRIMOS FILE FOR WRITING
*
OP.SYS.POPEN: 
      OP.SYS.BUFFER = ''
      OP.SYS.BUFFER.SIZE = 256
      OP.SYS.FILE.FUNIT = ''
      IF INDEX(DLMAIN.OUTPUT.FILE.PATH.NAME,OP.SYS.PATH.DELIM,1) > 0 THEN
         OP.SYS.FILE.PATH.NAME = DLMAIN.OUTPUT.FILE.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.OUTPUT.RECORD.NAME
      END ELSE
         OP.SYS.FILE.PATH.NAME = DBMS.ACCOUNT.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.OUTPUT.FILE.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.OUTPUT.RECORD.NAME
      END
      ACTION = 'WRITE'
      OPEN.ERRMSG = ''
      DEBUG2
      CRT 'Calling POPEN for file ':OP.SYS.FILE.PATH.NAME
      END
      CALL POPEN(OP.SYS.FILE.FUNIT, OP.SYS.FILE.PATH.NAME, ACTION, DLMAIN.OVERWRITING, OPEN.ERRMSG)
      IF OPEN.ERRMSG THEN
         DLMAIN.ERRMSG<-1> = 'Error in opening "':OP.SYS.FILE.PATH.NAME:'" for direct write'
         DLMAIN.ERRMSG<-1> = '   ':OPEN.ERRMSG
         DLMAIN.FATAL.ERROR = TRUE
      END
      RETURN

OP.SYS.UNIX.OPENFILE: 
      IF INDEX(DLMAIN.OUTPUT.FILE.PATH.NAME,OP.SYS.PATH.DELIM,1) > 0 THEN
         OP.SYS.FILE.PATH.NAME =DLMAIN.OUTPUT.FILE.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.OUTPUT.RECORD.NAME
      END ELSE
         OP.SYS.FILE.PATH.NAME = DBMS.ACCOUNT.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.OUTPUT.FILE.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.OUTPUT.RECORD.NAME
      END
      OP.SYS.FILE.EXISTS = TRUE
      DEBUG2
      CRT 'About to open Unix file ':OP.SYS.FILE.PATH.NAME
      END
      *INFORMATION      OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE
      *INFORMATION         OP.SYS.FILE.EXISTS = FALSE
      *INFORMATION      END
      *UNIDATA          OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE
      *UNIDATA             OP.SYS.FILE.EXISTS = FALSE
      *UNIDATA          END
               OPENSEQ DLMAIN.OUTPUT.FILE.NAME,DLMAIN.OUTPUT.RECORD.NAME TO OP.SYS.FILE.FUNIT ELSE
                  OP.SYS.FILE.EXISTS = FALSE
               END
      OP.SYS.BUFFER.SIZE = 0
      OSOPEN.STATUS = STATUS()
      BEGIN CASE
         CASE OSOPEN.STATUS # 0 AND OSOPEN.STATUS # 4
            DLMAIN.ERRMSG<-1> = 'Error in opening "':OP.SYS.FILE.PATH.NAME:'" for direct write'
            DLMAIN.FATAL.ERROR = TRUE
         CASE OP.SYS.FILE.EXISTS AND NOT(DLMAIN.OVERWRITING)
            DLMAIN.ERRMSG<-1> = '"':OP.SYS.FILE.PATH.NAME:'" already exists'
            DLMAIN.FATAL.ERROR = TRUE
         CASE 1
            *INFORMATION            OSWRITE '' ON OP.SYS.FILE.PATH.NAME
            *INFORMATION            OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE NULL
            *UNIDATA            OSWRITE '' ON OP.SYS.FILE.PATH.NAME
            *UNIDATA            OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE NULL
             WEOFSEQ OP.SYS.FILE.FUNIT
      END CASE
      RETURN

OP.SYS.WINDOWS.OPENFILE: 
      IF INDEX(DLMAIN.OUTPUT.FILE.PATH.NAME,OP.SYS.PATH.DELIM,1) > 0 THEN
         OP.SYS.FILE.PATH.NAME =DLMAIN.OUTPUT.FILE.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.OUTPUT.RECORD.NAME
      END ELSE
         OP.SYS.FILE.PATH.NAME = DBMS.ACCOUNT.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.OUTPUT.FILE.PATH.NAME:OP.SYS.PATH.DELIM:DLMAIN.OUTPUT.RECORD.NAME
      END
      OP.SYS.FILE.EXISTS = TRUE
      DEBUG2
      CRT 'About to open Windows file ':OP.SYS.FILE.PATH.NAME
      END
      *INFORMATION      OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE
      *INFORMATION         OP.SYS.FILE.EXISTS = FALSE
      *INFORMATION      END
      *UNIDATA          OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE
      *UNIDATA             OP.SYS.FILE.EXISTS = FALSE
      *UNIDATA          END
               OPENSEQ DLMAIN.OUTPUT.FILE.NAME,DLMAIN.OUTPUT.RECORD.NAME TO OP.SYS.FILE.FUNIT ELSE
                  OP.SYS.FILE.EXISTS = FALSE
               END
      OP.SYS.BUFFER.SIZE = 0
      OSOPEN.STATUS = STATUS()
      BEGIN CASE
         CASE OSOPEN.STATUS # 0 AND OSOPEN.STATUS # 4
            DLMAIN.ERRMSG<-1> = 'Error in opening "':OP.SYS.FILE.PATH.NAME:'" for direct write'
            DLMAIN.FATAL.ERROR = TRUE
         CASE OP.SYS.FILE.EXISTS AND NOT(DLMAIN.OVERWRITING)
            DLMAIN.ERRMSG<-1> = '"':OP.SYS.FILE.PATH.NAME:'" already exists'
            DLMAIN.FATAL.ERROR = TRUE
         CASE 1
            *INFORMATION            OSWRITE '' ON OP.SYS.FILE.PATH.NAME
            *INFORMATION            OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE NULL
            *UNIDATA            OSWRITE '' ON OP.SYS.FILE.PATH.NAME
            CRT 'WRITING ':OP.SYS.FILE.PATH.NAME
            *UNIDATA            OSOPEN OP.SYS.FILE.PATH.NAME TO OP.SYS.FILE.FUNIT ELSE NULL
             WEOFSEQ OP.SYS.FILE.FUNIT
      END CASE
      RETURN


*
* DETERMINE FILE TYPE (TYPE1 OR INFO)
*
OP.SYS.FILE.TYPE: 
      DEBUG2
      CRT 'GOSUB OP.SYS.FILE.TYPE'
      END
      BEGIN CASE
         CASE DBMS.NAME = 'INFORMATION'
            GOSUB OP.SYS.INFORMATION.FILE.TYPE
         CASE DBMS.NAME = 'UNIDATA'
            GOSUB OP.SYS.UNIDATA.FILE.TYPE
         CASE DBMS.NAME = 'UNIVERSE'
            GOSUB OP.SYS.UNIVERSE.FILE.TYPE
      END CASE
      RETURN

*
* FINFO$TYPE IS DETERMINED FROM THE INSERT FILE "SYSCOM>FILEINFO.INS.IBAS"
*
OP.SYS.INFORMATION.FILE.TYPE: 
      FILE.TYPE = ''
      FINFO$TYPE = 3
      *INFORMATION       FILE.TYPE = FILEINFO(F.TEST,FINFO$TYPE)
      IF FILE.TYPE = 4 THEN
         ITEM.TYPE = 'DIR'
      END ELSE
         ITEM.TYPE = 'INFO.FILE'
      END
      RETURN

OP.SYS.UNIDATA.FILE.TYPE: 
      DEBUG2
      CRT 'Checking file type ':VOC.ITEM.TYPE
      END
      IF VOC.ITEM.TYPE = 'DIR' THEN
         ITEM.TYPE = 'DIR'
      END ELSE
         FINFO$TYPE = 3
         *UNIDATA       FILE.TYPE = FILEINFO(F.TEST,FINFO$TYPE)
         IF FILE.TYPE = 4 THEN
            ITEM.TYPE = 'DIR'
         END ELSE
            ITEM.TYPE = 'FILE'
         END
      END
      RETURN

OP.SYS.UNIVERSE.FILE.TYPE: 
      DEBUG2
      CRT 'Checking file type ':VOC.ITEM.TYPE
      END
      IF VOC.ITEM.TYPE = 'DIR' THEN
         ITEM.TYPE = 'DIR'
      END ELSE
         FINFO$TYPE = 3
                FILE.TYPE = FILEINFO(F.TEST,FINFO$TYPE)
         IF FILE.TYPE = 4 THEN
            ITEM.TYPE = 'DIR'
         END ELSE
            ITEM.TYPE = 'FILE'
         END
      END
      RETURN



*******************************************************************************
**
**   PRE-ITEM PROCESSING (DO THESE THINGS BEFORE PROCESSING ITEMS
**
*******************************************************************************
PRE.ITEMS.PROCESSING: 
      DLMAIN.FORMAT = 'COMMA'
      GOSUB PARSE.INITIAL.LINE
      DEBUG1OR2
      CRT 'INSIDE DOWNLOAD.PARSE'
      END
      GOSUB CHECK.FOR.INFO.FILE
      GOSUB SET.UP.OPTION.DEFAULTS
      IF NOT(DLMAIN.FATAL.ERROR) THEN
         GOSUB OPEN.PRIMARY.DICT
      END
      IF NOT(DLMAIN.FATAL.ERROR) THEN
         GOSUB PROCESS.PREPROCESS.ITEMS
      END
      ITEM.CTR = 0
      ITEMS.DONE = FALSE
      RETURN


*
*
* PARSE THE COMMAND LINE (DO NOT CHECK DICTIONARY OR VOC FOR PHRASES YET)
*
PARSE.INITIAL.LINE: 
      PCL.DICT.FILE.NAME = ''
      EXPAND.VOC.PHRASES = FALSE
      OTHER.SEPARATORS = '(':@FM:')':@FM:','
      ITEMS.DONE = FALSE
      ITEM.CTR = 0
*
      PARAM.LIST = ''
      PARAM.QUOTED.LIST = ''
      NUM.PARAMS = 0
      CALL PARSECL(DBMS.COMMAND.LINE, PARAM.LIST, PARAM.QUOTED.LIST, NUM.PARAMS, OTHER.SEPARATORS)
*
* SKIP BEGINNING ITEMS ON COMMAND LINE
*
      NUM.ITEMS = NUM.PARAMS - DBMS.COMMAND.LINE.ITEMS.TO.SKIP
      BEG.ITEM.NUM = DBMS.COMMAND.LINE.ITEMS.TO.SKIP + 1
      ITEM.LIST = FIELD(PARAM.LIST,@FM,BEG.ITEM.NUM,NUM.ITEMS)
      ITEM.QUOTED.LIST = FIELD(PARAM.QUOTED.LIST,@FM,BEG.ITEM.NUM,NUM.ITEMS)
      ITEM.USED.LIST = ''
      IF NUM.ITEMS = 0 THEN
         GOSUB PRINT.HELP
         STOP
      END
*
* CHECK FOR KEYWORD "BEGIN" AT END OF FIRST LINE, IF IT IS THERE, CONTINUE
* READING LINES FROM THE TERMINAL UNTIL THE KEYWORD "END" IS AT THE END OF
* A LINE
*
      ITEM = ITEM.LIST<NUM.ITEMS>
      ITEM.QUOTED = ITEM.QUOTED.LIST<NUM.ITEMS>
      GOSUB DETERMINE.ITEM.TYPE
      FOUND.KEYWORD.BEGIN = FALSE
      IF ITEM.TYPE = 'OPTION' AND ITEM.KEYWORD = KEYWORD.BEGIN THEN
         FOUND.KEYWORD.BEGIN = TRUE
         DEL ITEM.LIST<NUM.ITEMS>
         DEL ITEM.QUOTED.LIST<NUM.ITEMS>
         DEL ITEM.USED.LIST<NUM.ITEMS>
         NUM.ITEMS -= 1
      END
      IF FOUND.KEYWORD.BEGIN THEN
         LOOP
            LOOP
               X.LINE = ''
               CALL PROMPTSTACK(DOWNLOAD.PROMPT, PROGRAM.NAME, X.LINE)
               CHECK.FLAG = TRIM(X.LINE)[1,1]
            UNTIL CHECK.FLAG # '*' AND CHECK.FLAG # ''
            REPEAT
            TEST.QUIT = OCONV(TRIM(X.LINE),'MCU')
            IF TEST.QUIT = 'QUIT' THEN
               CRT 'Download aborted!'
               STOP
            END
            GOSUB PARSE.INITIAL.X.LINE
         UNTIL FOUND.KEYWORD.END
         REPEAT
      END
      LOCATE 'HELP' IN ITEM.LIST<1> SETTING HELP.POS THEN
         GOSUB PRINT.HELP
         STOP
      END
      LOCATE 'DEBUG.LEVEL' IN ITEM.LIST<1> SETTING DEBUG.POS THEN
         ITEM.CTR = DEBUG.POS
         GOSUB PROCESS.OPTION.DEBUG.LEVEL
         ITEMS.DONE = FALSE
      END
      LOCATE 'FORMAT' IN ITEM.LIST<1> SETTING FORMAT.POS THEN
         ITEM.CTR = FORMAT.POS
         ORIGINAL.ITEM = ITEM.LIST<FORMAT.POS>
         GOSUB PROCESS.PREPROCESS.FORMAT
         ITEMS.DONE = FALSE
      END
      LOCATE 'FILE' IN ITEM.LIST<1> SETTING FILE.POS THEN
         GOSUB CHECK.VARIABLE.FILE.NAME
         ITEMS.DONE = FALSE
      END
      LOCATE 'XML.ALLOW.PERIODS' IN ITEM.LIST<1> SETTING XML.POS THEN
         ITEM.CTR = XML.POS
         GOSUB PROCESS.OPTION.XML.ALLOW.PERIODS
         ITEMS.DONE = FALSE
      END
      LOCATE 'XML.UPCASE' IN ITEM.LIST<1> SETTING XML.POS THEN
         ITEM.CTR = XML.POS
         GOSUB PROCESS.OPTION.XML.UPCASE
         ITEMS.DONE = FALSE
      END
      RETURN


*
*
* PARSE THE EXTRA LINES ENTERED UNTIL KEYWORD 'END' IS FOUND
*
PARSE.INITIAL.X.LINE: 
      FOUND.KEYWORD.END = FALSE
      X.ITEM.LIST = ''
      X.ITEM.QUOTED.LIST = ''
      NUM.X.ITEMS = 0
      CALL PARSECL(X.LINE, X.ITEM.LIST, X.ITEM.QUOTED.LIST, NUM.X.ITEMS, OTHER.SEPARATORS)
      X.ITEM.USED.LIST = ''
      CALL EXPAND.ITEMS(X.ITEM.LIST,X.ITEM.QUOTED.LIST,X.ITEM.USED.LIST,NUM.X.ITEMS,PCL.DICT.FILE.NAME,EXPAND.VOC.PHRASES, OTHER.SEPARATORS)
      ITEM.LIST<NUM.ITEMS+1> = X.ITEM.LIST
      ITEM.QUOTED.LIST<NUM.ITEMS+1> = X.ITEM.QUOTED.LIST
      ITEM.USED.LIST<NUM.ITEMS+1> = X.ITEM.USED.LIST
      NUM.ITEMS += NUM.X.ITEMS
      ITEM = ITEM.LIST<NUM.ITEMS>
      ITEM.QUOTED = ITEM.QUOTED.LIST<NUM.ITEMS>
      GOSUB DETERMINE.ITEM.TYPE
      IF ITEM.TYPE = 'OPTION' AND ITEM.KEYWORD = KEYWORD.END THEN
         FOUND.KEYWORD.END = TRUE
         DEL ITEM.LIST<NUM.ITEMS>
         DEL ITEM.QUOTED.LIST<NUM.ITEMS>
         DEL ITEM.USED.LIST<NUM.ITEMS>
         NUM.ITEMS -= 1
      END
      RETURN


*
*
* CHECK FOR AN INFORMATION FILE NAME ON THE COMMAND LINE
* (GET NAME OF FILE TO BE DOWNLOADED)
* FILE NAME MUST BE FIRST PARAMETER
*
CHECK.FOR.INFO.FILE: 
      ITEM.CTR = 1
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      ITEM = ITEM.LIST<ITEM.CTR>
      ITEM.QUOTED = ITEM.QUOTED.LIST<ITEM.CTR>
      LOOKUP.FILE.NAME = TRUE
      GOSUB CHECK.VOC.FOR.NONFIELD
      PHRASE.USED = ''
      DLMAIN.NUM.FILES = PRIMARY.FILE.NUM
      DLMAIN.INFO.FILE.KEY.DICT.CTR(PRIMARY.FILE.NUM) = ''
      DLMAIN.INFO.FILE.ALIAS.LIST<PRIMARY.FILE.NUM> = ''
      DLMAIN.INFO.FILE.NAME.PART.1(PRIMARY.FILE.NUM) = ''
      IF ITEM.KEYWORD = KEYWORD.DICT THEN
         PHRASE.USED = 'DICT '
         DLMAIN.INFO.FILE.NAME.PART.1(PRIMARY.FILE.NUM) = 'DICT'
         ITEM.CTR += 1
         ITEM.USED.LIST<ITEM.CTR> = TRUE
         ITEM = ITEM.LIST<ITEM.CTR>
         ITEM.QUOTED = ITEM.QUOTED.LIST<ITEM.CTR>
         LOOKUP.FILE.NAME = TRUE
         GOSUB CHECK.VOC.FOR.NONFIELD
      END
      PHRASE.USED := ITEM.QUOTED:ITEM:ITEM.QUOTED
      DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM) = ''
      IF ITEM.TYPE = 'INFO.FILE' OR ITEM.TYPE = 'FILE' OR ITEM.TYPE = 'DIR' THEN
         DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM) = ITEM
         OPEN DLMAIN.INFO.FILE.NAME.PART.1(PRIMARY.FILE.NUM), DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM) TO DLMAIN.F.INFO.FILE(PRIMARY.FILE.NUM) ELSE
            DLMAIN.ERRMSG<-1> = 'Can not open "':PHRASE.USED:'"'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PROGRAM.NAME:' ':PHRASE.USED:'": should be "':PROGRAM.NAME:' [DICT] InfoFileName"'
         DLMAIN.ERRMSG<-1> = 'Could not find file ':PHRASE.USED:' in VOC.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      DLMAIN.INFO.FILE.ALIAS.LIST<PRIMARY.FILE.NUM> = DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM)
      RETURN


*
*
* SET UP OPTION DEFAULTS
*
SET.UP.OPTION.DEFAULTS: 
      IF DLMAIN.INFO.FILE.NAME.PART.1(PRIMARY.FILE.NUM) = 'DICT' THEN
         PRIMARY.DICT.PART.1 = 'DICT'
         PRIMARY.DICT.PART.2 = 'DICT'
      END ELSE
         PRIMARY.DICT.PART.1 = 'DICT'
         PRIMARY.DICT.PART.2 = DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM)
      END
*
* DECIDE ON DLMAIN.DISPLAY.COUNT AFTER DLMAIN.PRINT.METHOD IS DETERMINED
*   IF PRINTING TO CRT, THEN DEFAULT IS FALSE
*
      DLMAIN.DISPLAY.COUNT = ''
      DLMAIN.HAVE.NO.PAGE = FALSE
      DEFAULT.PROGRESS.INTERVAL = 10
      DLMAIN.PROGRESS.INTERVAL = DEFAULT.PROGRESS.INTERVAL
      DEFAULT.WRITE.INTERVAL = 10
      DLMAIN.WRITE.INTERVAL = DEFAULT.WRITE.INTERVAL
      DEFAULT.WRITE.SLEEP.TIME = 0
      DLMAIN.WRITE.SLEEP.TIME = DEFAULT.WRITE.SLEEP.TIME
      DLMAIN.PRINT.ERRORS = TRUE
      DLMAIN.LPTR = FALSE
      DLMAIN.PRINT.LAYOUT = FALSE
      DLMAIN.SAMPLE.SIZE = ''
      DEFAULT.DLMAIN.SAMPLE.SIZE = 10
      DEFAULT.DEBUG.LEVEL = FALSE
      DLMAIN.RECORD.ORIENTATION = 'HORIZONTAL'
      DLMAIN.NO.LINEFEED = FALSE
      DLMAIN.RECORD.LENGTH = ''
      DLMAIN.PRINT.METHOD = ''
      DLMAIN.OUTPUT.FILE.NAME = ''
      DLMAIN.OUTPUT.RECORD.NAME = ''
      DLMAIN.FROM.UNIT = 0
      DLMAIN.OVERWRITING = FALSE
      DLMAIN.APPEND = FALSE
      DLMAIN.DET.SUP = FALSE
      DEFAULT.OUT.REC = DL.OUTR.DETAIL.OUT.REC
*
* THESE DEFAULTS ARE USED FOR FIELDS ENTERED ON THE COMMAND LINE FOR
* EVERY FIELD THAT DOES NOT INCLUDE THE CORRESPONDING FIELD QUALIFIER
* WITH THE EXCEPTION OF 'FMT' & 'CONV'
* THESE 2 QUALIFIERS FOLLOW THESE RULES:
*   1. IF THERE IS A SPECIFIC 'FMT' OR 'CONV' QUALIFIER FOR A PARTICULAR
*      FIELD ON THE COMMAND LINE, THEN IT IS USED
*   2. IF THERE IS NOT A SPECIFIC 'FMT' OR 'CONV', BUT 'DEFAULT FMT' OR
*      'DEFAULT CONV' IS SPECIFIED, THEN THE 'DEFAULT ...' CODE IS USED
*   3. IF NEITHER THE 'FMT'/'CONV' OR 'DEFAULT FMT'/'DEFAULT CONV' IS
*      USED, THEN IT CHECKS THE DICTIONARY RECORD FOR THE FMT OR CONV
*      CODE TO USE
*
* THE DEFAULT VALUE FOR ALL FIELD QUALIFIERS CAN BE CHANGED (WITH THE
* EXCEPTION OF 'END.COL' & 'COLUMNS') ON THE COMMAND LINE BY SPECIFYING
* 'DEFAULT qualifier value'
* EG. TO CHANGE THE DEFAULT FOR THE NUM.VALUES FROM '1' TO 'ALL' FOR
*     ALL FIELDS BEING DOWNLOADED, USE THE PHRASE 'DEFAULT NUM.VALUES ALL'
* CHANGING THE DEFAULT VALUE FOR A PARTICULAR QUALIFIER DOES NOT AFFECT
* THOSE FIELDS WHICH HAVE AN EXPLICIT FIELD QUALIFIER SPECIFIED
*
      DEFAULT.NUM.VALUES = 1
      SET.DEFAULT.NUM.VALUES = FALSE
      DEFAULT.NUM.SUBVALUES = 1
      SET.DEFAULT.NUM.SUBVALUES = FALSE
      DEFAULT.MV.ORIENTATION = ''
      DEFAULT.VALUE.SEPARATOR = ''
      DEFAULT.SUBVALUE.SEPARATOR = ''
      SET.DEFAULT.VALUE.SEPARATOR = FALSE
      SET.DEFAULT.SUBVALUE.SEPARATOR = FALSE
      DEFAULT.LINE = 1
      DEFAULT.FMT = ''
      DEFAULT.FIELD.FMT = '30L'
      DEFAULT.CONV = ''
      DEFAULT.HTML.START = ''
      DEFAULT.HTML.END = ''
      DEFAULT.HTML.CELL = ''
      DEFAULT.HTML.ROW = ''
      DEFAULT.SM = 'S'
      DEFAULT.LENGTH = ''
      DEFAULT.BEG.COL = 1
      DEFAULT.DEFAULT.VALUE = ''
      RETURN


*
*
* OPEN PRIMARY DICT
*
OPEN.PRIMARY.DICT: 
      PRIMARY.DICT.OPENED = TRUE
      IF PRIMARY.DICT.PART.2 = 'DICT' THEN
         OPEN '', 'DICT.DICT' TO F.DICT.FILE(PRIMARY.FILE.NUM) ELSE
            DLMAIN.ERRMSG<-1> = 'Can not open "':PRIMARY.DICT.PART.1:'" "':PRIMARY.DICT.PART.2:'"'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END ELSE
         OPEN PRIMARY.DICT.PART.1, PRIMARY.DICT.PART.2 TO F.DICT.FILE(PRIMARY.FILE.NUM) ELSE
            DLMAIN.ERRMSG<-1> = 'Can not open "':PRIMARY.DICT.PART.1:'" "':PRIMARY.DICT.PART.2:'"'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      RETURN


*******************************************************************************
**
**   PROCESS COMMAND LINE ITEMS (OPTIONS, QUALIFIERS, RECORD KEYS, FIELDS)
**       AND BUILD APPROPRIATE LISTS, RECORDS, ETC. USED IN PROCESSING
**       OF DATA RECORDS & I-DESCRIPTORS
**
*******************************************************************************
PROCESS.PREPROCESS.ITEMS: 
      SUB.NAME = 'PREPROCESS'
      PREV.ITEM.TYPE = ''
      GOSUB GET.NEXT.ITEM
      CUR.FILE.NUM = ''
      LOOP
*
* SKIP ITEMS ALREADY USED (IN A PREVIOUS PASS THROUGH THE ITEMS)
* AS LONG AS THEY ARE BETWEEN OPTIONS & THE ITEMS THEY NEED
* (EG. "FROM 3 useditem useditem useditem SAMPLE 5"
*  but not "FROM 3 SAMPLE useditem useditem 5")
*
         LOOP
         UNTIL NOT(ITEM.USED) OR ITEMS.DONE
            GOSUB GET.NEXT.ITEM
         REPEAT
      UNTIL ITEMS.DONE
         ORIGINAL.ITEM = ITEM
         PREV.ITEM.TYPE = ITEM.TYPE
         BEGIN CASE
            CASE ITEM.TYPE = 'PREPROCESS'
               GOSUB PROCESS.PREPROCESS
            CASE 1
               CUR.FILE.NUM = ''
               GOSUB GET.NEXT.ITEM
         END CASE
         IF DLMAIN.FATAL.ERROR THEN
            RETURN
         END
      REPEAT
*
      FOR FILE.CTR=2 TO DLMAIN.NUM.FILES
         IF DLMAIN.INFO.FILE.ALIAS.LIST<FILE.CTR> = '' THEN
            DLMAIN.INFO.FILE.ALIAS.LIST<FILE.CTR> = DLMAIN.INFO.FILE.NAME.PART.2(FILE.CTR)
         END
         IF DLMAIN.INFO.FILE.KEY.DICT.CTR(FILE.CTR) = '' THEN
            DICT.FIELD.NAME = '@ID'
            DICT.FILE.NUM = PRIMARY.FILE.NUM
            ITEM.FIELD.FILE.NUM = PRIMARY.FILE.NUM
            DICT.REC = 'D':@FM:'0'
            GOSUB ADD.DICT.REC
            DLMAIN.INFO.FILE.KEY.DICT.CTR(FILE.CTR) = WHICH.DICT.REC.CTR
            DLMAIN.INFO.FILE.KEY.IS.MULTIVALUE(FILE.CTR) = FALSE
         END
      NEXT FILE.CTR
      RETURN


PROCESS.REGULAR.ITEMS: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.REGULAR.ITEMS'
      END
      SUB.NAME = 'REGULAR'
      PREV.ITEM.TYPE = ''
      ACTIVE.PREFIX = ''
      CUR.OUT.FIELD.CTR = ''
      GOSUB GET.NEXT.ITEM
      LOOP
*
* SKIP ITEMS ALREADY USED (IN A PREVIOUS THROUGH THE ITEMS)
* AS LONG AS THEY ARE BETWEEN OPTIONS & THE ITEMS THEY NEED
* (EG. "FROM 3 useditem useditem useditem SAMPLE 5"
*  but not "FROM 3 SAMPLE useditem useditem 5")
*
         LOOP
         UNTIL NOT(ITEM.USED) OR ITEMS.DONE
            GOSUB GET.NEXT.ITEM
         REPEAT
      UNTIL ITEMS.DONE
         ORIGINAL.ITEM = ITEM
         PREV.ITEM.TYPE = ITEM.TYPE
         DEBUG3OR4
         CRT 'ITEM: ':ITEM
         CRT 'ITEM.TYPE: ':ITEM.TYPE
      END
      BEGIN CASE
         CASE ITEM.TYPE = ''
            IF NUM(ITEM) AND ITEM > 0 AND CUR.OUT.FIELD.CTR THEN
               GOSUB PROCESS.QUALIFIER.LENGTH
            END ELSE
               GOSUB PROCESS.ITEM.AS.RECORD.KEY
               CUR.OUT.FIELD.CTR = ''
            END
         CASE ITEM.TYPE = 'OPTION'
            GOSUB PROCESS.OPTION
            CUR.OUT.FIELD.CTR = ''
         CASE ITEM.TYPE = 'MISC.FIELD'
            GOSUB PROCESS.MISC.FIELD
         CASE ITEM.TYPE = 'AT.VARIABLE'
            GOSUB PROCESS.AT.VARIABLE
         CASE ITEM.TYPE = 'PREFIX'
            GOSUB PROCESS.PREFIX
         CASE ITEM.TYPE = 'QUALIFIER'
            GOSUB PROCESS.QUALIFIER
         CASE ITEM.TYPE = 'FIELD'
            GOSUB PROCESS.FIELD
         CASE 1
            GOSUB PROCESS.ITEM.AS.ERROR
            CUR.OUT.FIELD.CTR = ''
      END CASE
      IF PREV.ITEM.TYPE # 'PREFIX' THEN
         ACTIVE.PREFIX = ''
      END
      IF DLMAIN.FATAL.ERROR THEN
         RETURN
      END
      REPEAT
      RETURN



*
*
* SAVE ITEM AS RECORD.KEY
*
PROCESS.ITEM.AS.RECORD.KEY: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.ITEM.AS.RECORD.KEY'
      END
      DLMAIN.RECORD.KEY.LIST<-1> = ITEM
      GOSUB GET.NEXT.ITEM
      RETURN



*
*
* TREAT THIS ITEM AS ERROR
*
PROCESS.ITEM.AS.ERROR: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.ITEM.AS.ERROR'
      END
      DLMAIN.ERRMSG<-1> = 'Not expecting "':ITEM:'" here'
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS.PREPROCESS
*
PROCESS.PREPROCESS: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.PREPROCESS'
      END
      BEGIN CASE
         CASE WHICH.PREPROCESS = 'USING'
            GOSUB PROCESS.PREPROCESS.USING
         CASE WHICH.PREPROCESS = 'SECONDARY.FILE'
            GOSUB PROCESS.PREPROCESS.SECONDARY.FILE
         CASE WHICH.PREPROCESS = 'KEY'
            GOSUB PROCESS.PREPROCESS.KEY
         CASE WHICH.PREPROCESS = 'ALIAS'
            GOSUB PROCESS.PREPROCESS.ALIAS
      END CASE
      RETURN


PROCESS.PREPROCESS.USING: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.PREPROCESS.USING'
      END
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      LOOKUP.FIELD.NAME = FALSE
      LOOKUP.FILE.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      TEMP.NAME.PART.1 = ''
      IF ITEM.KEYWORD = KEYWORD.DICT THEN
         PHRASE.USED = 'USING'
         PHRASE.USED := ' DICT'
         TEMP.NAME.PART.1 = 'DICT'
         ITEM.USED.LIST<ITEM.CTR> = TRUE
         LOOKUP.FIELD.NAME = FALSE
         LOOKUP.FILE.NAME = TRUE
         GOSUB GET.NEXT.ITEM
      END
      PHRASE.USED := ' ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      TEMP.NAME.PART.2 = ''
      IF ITEM.TYPE = 'INFO.FILE' OR ITEM.TYPE = 'FILE' THEN
         TEMP.NAME.PART.2 = ITEM
         ITEM.USED.LIST<ITEM.CTR> = TRUE
      END
      IF TEMP.NAME.PART.2 # '' THEN
         PRIMARY.DICT.PART.1 = TEMP.NAME.PART.1
         PRIMARY.DICT.PART.2 = TEMP.NAME.PART.2
         GOSUB OPEN.PRIMARY.DICT
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": should be "USING [DICT] InfoFileName"'
         DLMAIN.FATAL.ERROR = TRUE
      END
      GOSUB GET.NEXT.ITEM
      RETURN


PROCESS.PREPROCESS.SECONDARY.FILE: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.PREPROCESS.SECONDARY.FILE'
      END
      PHRASE.USED = ORIGINAL.ITEM
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      LOOKUP.FIELD.NAME = FALSE
      LOOKUP.FILE.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      PHRASE.USED := ' ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      IF ITEM.TYPE = 'INFO.FILE' OR ITEM.TYPE = 'FILE' THEN
         DLMAIN.NUM.FILES += 1
         CUR.FILE.NUM = DLMAIN.NUM.FILES
         DLMAIN.INFO.FILE.KEY.DICT.CTR(CUR.FILE.NUM) = ''
         DLMAIN.INFO.FILE.ALIAS.LIST<CUR.FILE.NUM> = ITEM
         ALIAS.SET(CUR.FILE.NUM) = FALSE
         DLMAIN.INFO.FILE.NAME.PART.1(CUR.FILE.NUM) = ''
         DLMAIN.INFO.FILE.NAME.PART.2(CUR.FILE.NUM) = ITEM
         OPEN 'DICT', ITEM TO F.DICT.FILE(CUR.FILE.NUM) ELSE
            DLMAIN.ERRMSG<-1> = 'Can not open "DICT" "':ITEM:'"'
            DLMAIN.FATAL.ERROR = TRUE
         END
         OPEN '', ITEM TO DLMAIN.F.INFO.FILE(CUR.FILE.NUM) ELSE
            DLMAIN.ERRMSG<-1> = 'Can not open "':ITEM:'"'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": should be "SECONDARY.FILE InfoFileName"'
         DLMAIN.FATAL.ERROR = TRUE
      END
      GOSUB GET.NEXT.ITEM
      RETURN


PROCESS.PREPROCESS.KEY: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.PREPROCESS.KEY'
      END
      PHRASE.USED = ORIGINAL.ITEM
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      GOSUB GET.NEXT.ITEM
      PHRASE.USED := ' ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      X.NEED.NEXT.ITEM = TRUE
      BEGIN CASE
         CASE CUR.FILE.NUM = ''
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": should follow a SECONDARY.FILE clause'
         CASE DLMAIN.INFO.FILE.KEY.DICT.CTR(CUR.FILE.NUM) # ''
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": only one KEY clause allowed per relate'
         CASE ITEM.TYPE # 'FIELD' OR (ITEM.FIELD.TYPE # 'I' AND ITEM.FIELD.TYPE # 'D')
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": should be "KEY fieldName"'
         CASE ITEM.FIELD.FILE.NUM # PRIMARY.FILE.NUM
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": field must be a field in the primary file'
         CASE 1
            DICT.FIELD.NAME = ITEM
            DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
            GOSUB ADD.DICT.REC
            DLMAIN.INFO.FILE.KEY.DICT.CTR(CUR.FILE.NUM) = WHICH.DICT.REC.CTR
            FILE.KEY.SM = DL.DATA.DICT.RECS(WHICH.DICT.REC.CTR)<6>
            IF FILE.KEY.SM = 'M' THEN
               DLMAIN.INFO.FILE.KEY.IS.MULTIVALUE(CUR.FILE.NUM) = TRUE
               FILE.KEY.ASSOC = DL.DATA.DICT.RECS(WHICH.DICT.REC.CTR)<7>
               IF FILE.KEY.ASSOC = '' THEN
                  DL.DATA.DICT.RECS(WHICH.DICT.REC.CTR)<7> = DLMAIN.INFO.FILE.NAME.PART.2(CUR.FILE.NUM):'*':DICT.FIELD.NAME
               END
            END ELSE
               DLMAIN.INFO.FILE.KEY.IS.MULTIVALUE(CUR.FILE.NUM) = FALSE
            END
            GOSUB GET.NEXT.ITEM
            X.NEED.NEXT.ITEM = FALSE
            IF (ITEM.TYPE = 'QUALIFIER') AND (ITEM.KEYWORD = 'NUM.VALUES') THEN
               ITEM.USED.LIST<ITEM.CTR> = TRUE
               GOSUB GET.NEXT.ITEM
               VALID.VALUE = FALSE
               IF ITEM.TYPE = '' OR (ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.ALL) THEN
                  BEGIN CASE
                     CASE NUM(ITEM) AND ITEM > 0
                        NUM.VALUES.VALUE = ITEM
                        VALID.VALUE = TRUE
                     CASE ITEM.KEYWORD = KEYWORD.ALL
                        NUM.VALUES.VALUE = ITEM
                        VALID.VALUE = TRUE
                     CASE 1
                        TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid NUM.VALUES value'
                  END CASE
                  IF VALID.VALUE THEN
                     X.FILE.NUM.VALUES(CUR.FILE.NUM) = NUM.VALUES.VALUE
                     ITEM.USED.LIST<ITEM.CTR> = TRUE
                     GOSUB GET.NEXT.ITEM
                  END ELSE
                     DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
                  END
               END ELSE
                  TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER
               END
            END
      END CASE
      IF X.NEED.NEXT.ITEM THEN
         GOSUB GET.NEXT.ITEM
      END
      RETURN


PROCESS.PREPROCESS.ALIAS: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.PREPROCESS.ALIAS'
      END
      PHRASE.USED = ORIGINAL.ITEM
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      PHRASE.USED := ' ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      BEGIN CASE
         CASE CUR.FILE.NUM = ''
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": should follow a SECONDARY.FILE clause'
         CASE ALIAS.SET(CUR.FILE.NUM)
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": only one ALIAS clause allowed per relate'
         CASE 1
            FOUND.ALIAS = FALSE
            FOR TEMP.CTR=1 TO DLMAIN.NUM.FILES UNTIL FOUND.ALIAS
               BEGIN CASE
                  CASE CUR.FILE.NUM = TEMP.CTR
                     NULL
                  CASE DLMAIN.INFO.FILE.ALIAS.LIST<TEMP.CTR> = ITEM
                     FOUND.ALIAS = TRUE
                  CASE DLMAIN.INFO.FILE.ALIAS.LIST<TEMP.CTR> # ''
                     NULL
                  CASE DLMAIN.INFO.FILE.NAME.PART.2(TEMP.CTR) = ITEM
                     FOUND.ALIAS = TRUE
               END CASE
            NEXT TEMP.CTR
            IF FOUND.ALIAS THEN
               DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'": alias already used'
            END ELSE
               DLMAIN.INFO.FILE.ALIAS.LIST<CUR.FILE.NUM> = ITEM
               ALIAS.SET(CUR.FILE.NUM) = TRUE
            END
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN


PROCESS.PREPROCESS.FORMAT: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.PREPROCESS.FORMAT'
      END
      PHRASE.USED = ORIGINAL.ITEM
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' specified must be in this list: "':FORMAT.TYPE.LIST<1>:'"'
      CONVERT @FM:@VM:@SM TO '   ' IN TEMP.ERRMSG
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEMS.DONE THEN
         CRT 'ITEMS.DONEXXXX'
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         DLMAIN.FATAL.ERROR = TRUE
      END ELSE
         LOCATE ITEM IN FORMAT.TYPE.LIST<1,1> SETTING POS THEN
            DLMAIN.FORMAT = FORMAT.TYPE.LIST<2,POS>
            ITEM.USED.LIST<ITEM.CTR> = TRUE
            ITEM.TYPE = ''
            GOSUB GET.NEXT.ITEM
         END ELSE
            CRT 'CANNOT LOCATE ':ITEM
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      TEMP.ERRMSG = ''
      RETURN


*
*
* PROCESS.OPTION
*
PROCESS.OPTION: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.OPTION'
      CRT 'WHICH.OPTION: ':WHICH.OPTION
      END
      X.CURRENT.TYPE = WHICH.OPTION
      BEGIN CASE
         CASE WHICH.OPTION = 'DISPLAY.COUNT'
            GOSUB PROCESS.OPTION.DISPLAY.COUNT
         CASE WHICH.OPTION = 'NO.DISPLAY.COUNT'
            GOSUB PROCESS.OPTION.NO.DISPLAY.COUNT
         CASE WHICH.OPTION = 'NO.PAGE' OR WHICH.OPTION = 'NOPAGE'
            GOSUB PROCESS.OPTION.NO.PAGE
         CASE WHICH.OPTION = 'PROGRESS.INTERVAL'
            GOSUB PROCESS.OPTION.PROGRESS.INTERVAL
         CASE WHICH.OPTION = 'WRITE.INTERVAL'
            GOSUB PROCESS.OPTION.WRITE.INTERVAL
         CASE WHICH.OPTION = 'PRINT.ERRORS'
            GOSUB PROCESS.OPTION.PRINT.ERRORS
         CASE WHICH.OPTION = 'NO.PRINT.ERRORS'
            GOSUB PROCESS.OPTION.NO.PRINT.ERRORS
         CASE WHICH.OPTION = 'LPTR'
            GOSUB PROCESS.OPTION.LPTR
         CASE WHICH.OPTION = 'DEBUG.LEVEL'
            GOSUB PROCESS.OPTION.DEBUG.LEVEL
         CASE WHICH.OPTION = 'PRINT.LAYOUT'
            GOSUB PROCESS.OPTION.PRINT.LAYOUT
         CASE WHICH.OPTION = 'SAMPLE'
            GOSUB PROCESS.OPTION.SAMPLE
         CASE WHICH.OPTION = 'FROM'
            GOSUB PROCESS.OPTION.FROM
         CASE WHICH.OPTION = 'DEFAULT'
            GOSUB PROCESS.OPTION.DEFAULT
         CASE WHICH.OPTION = 'USING'
            GOSUB PROCESS.OPTION.USING
         CASE WHICH.OPTION = 'FORMAT'
            GOSUB PROCESS.OPTION.FORMAT
         CASE WHICH.OPTION = 'RECORD.ORIENTATION'
            GOSUB PROCESS.OPTION.RECORD.ORIENTATION
         CASE WHICH.OPTION = 'RECORD.LENGTH'
            GOSUB PROCESS.OPTION.RECORD.LENGTH
         CASE WHICH.OPTION = 'NO.LINEFEED'
            GOSUB PROCESS.OPTION.NO.LINEFEED
         CASE WHICH.OPTION = 'FILE'
            GOSUB PROCESS.OPTION.FILE
         CASE WHICH.OPTION = 'BY.EXP'
            GOSUB PROCESS.OPTION.BY.EXP
         CASE WHICH.OPTION = 'WHEN'
            GOSUB PROCESS.OPTION.WHEN
         CASE WHICH.OPTION = 'OVERWRITING'
            GOSUB PROCESS.OPTION.OVERWRITING
         CASE WHICH.OPTION = 'APPEND'
            GOSUB PROCESS.OPTION.APPEND
         CASE WHICH.OPTION = 'HEADING'
            GOSUB PROCESS.OPTION.HEADING
         CASE WHICH.OPTION = 'DETAIL'
            GOSUB PROCESS.OPTION.DETAIL
         CASE WHICH.OPTION = 'HEADING.ON'
            GOSUB PROCESS.OPTION.HEADING.ON
         CASE WHICH.OPTION = 'FOOTING'
            GOSUB PROCESS.OPTION.FOOTING
         CASE WHICH.OPTION = 'FOOTING.ON'
            GOSUB PROCESS.OPTION.FOOTING.ON
         CASE WHICH.OPTION = 'DET.SUP'
            GOSUB PROCESS.OPTION.DET.SUP
         CASE WHICH.OPTION = 'QUOTE.CHAR'
            GOSUB PROCESS.OPTION.QUOTE.CHAR
         CASE WHICH.OPTION = 'EOR.CHAR'
            GOSUB PROCESS.OPTION.EOR.CHAR
         CASE WHICH.OPTION = 'COMMA.CHAR'
            GOSUB PROCESS.OPTION.COMMA.CHAR
         CASE WHICH.OPTION = 'UPCASE'
            GOSUB PROCESS.OPTION.UPCASE
         CASE WHICH.OPTION = 'REMOVE.PUNCTUATION'
            GOSUB PROCESS.OPTION.REMOVE.PUNCTUATION
         CASE WHICH.OPTION = 'FIELD.GAP'
            GOSUB PROCESS.OPTION.FIELD.GAP
         CASE WHICH.OPTION = 'HTML.TITLE'
            GOSUB PROCESS.OPTION.HTML.TITLE
         CASE WHICH.OPTION = 'HTML.TOP'
            GOSUB PROCESS.OPTION.HTML.TOP
         CASE WHICH.OPTION = 'HTML.BOTTOM'
            GOSUB PROCESS.OPTION.HTML.BOTTOM
         CASE WHICH.OPTION = 'HTML.TABLE'
            GOSUB PROCESS.OPTION.HTML.TABLE
         CASE WHICH.OPTION = 'HTML.BODY'
            GOSUB PROCESS.OPTION.HTML.BODY
         CASE WHICH.OPTION = 'XML.FILE.NAME'
            GOSUB PROCESS.OPTION.XML.FILE.NAME
         CASE WHICH.OPTION = 'XML.FILE.ATTRIBUTE'
            GOSUB PROCESS.OPTION.XML.FILE.ATTRIBUTE
         CASE WHICH.OPTION = 'XML.VERSION'
            GOSUB PROCESS.OPTION.XML.VERSION
         CASE WHICH.OPTION = 'XML.ROOT.NAME'
            GOSUB PROCESS.OPTION.XML.ROOT.NAME
         CASE WHICH.OPTION = 'XML.ROOT.ATTRIBUTE'
            GOSUB PROCESS.OPTION.XML.ROOT.ATTRIBUTE
         CASE WHICH.OPTION = 'XML.ALLOW.PERIODS'
            GOSUB PROCESS.OPTION.XML.ALLOW.PERIODS
         CASE WHICH.OPTION = 'XML.UPCASE'
            GOSUB PROCESS.OPTION.XML.UPCASE
      END CASE
      RETURN


*
*
* PROCESS OPTION "DISPLAY.COUNT"
*
PROCESS.OPTION.DISPLAY.COUNT: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.DISPLAY.COUNT'
      END
      DLMAIN.DISPLAY.COUNT = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "NO.DISPLAY.COUNT"
*
PROCESS.OPTION.NO.DISPLAY.COUNT: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.NO.DISPLAY.COUNT '
      END
      DLMAIN.DISPLAY.COUNT = FALSE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "NO.PAGE"
*
PROCESS.OPTION.NO.PAGE: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.NO.PAGE '
      END
      DLMAIN.HAVE.NO.PAGE = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN



*
*
* PROCESS OPTION "PROGRESS.INTERVAL"
*
PROCESS.OPTION.PROGRESS.INTERVAL: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.PROGRESS.INTERVAL '
      END
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            DLMAIN.PROGRESS.INTERVAL = ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be a number greater than 0'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.PROGRESS.INTERVAL = DEFAULT.PROGRESS.INTERVAL
      END
      RETURN


*
*
* PROCESS OPTION "WRITE.INTERVAL"
*
PROCESS.OPTION.WRITE.INTERVAL: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.WRITE.INTERVAL '
      END
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            DLMAIN.WRITE.INTERVAL = ITEM
            GOSUB GET.NEXT.ITEM
            IF ITEM.TYPE = '' THEN
               IF NUM(ITEM) AND ITEM > -1 THEN
                  DLMAIN.WRITE.SLEEP.TIME = ITEM
               END ELSE
                  DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be a number greater than -1'
               END
            END
         END ELSE
            DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be a number greater than 0'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.WRITE.INTERVAL = DEFAULT.WRITE.INTERVAL
         DLMAIN.WRITE.SLEEP.TIME = DEFAULT.WRITE.SLEEP.TIME
      END
      RETURN


*
*
* PROCESS OPTION "PRINT.ERRORS"
*
PROCESS.OPTION.PRINT.ERRORS: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.PRINT.ERRORS '
      END
      DLMAIN.PRINT.ERRORS = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "NO.PRINT.ERRORS"
*
PROCESS.OPTION.NO.PRINT.ERRORS: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.NO.PRINT.ERRORS '
      END
      DLMAIN.PRINT.ERRORS = FALSE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "LPTR"
*
PROCESS.OPTION.LPTR: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.LPTR '
      END
      DLMAIN.LPTR = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "DEBUG.LEVEL"
*
PROCESS.OPTION.DEBUG.LEVEL: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.DEBUG.LEVEL '
      END
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         ITEM.USED.LIST<ITEM.CTR> = TRUE
         IF NUM(ITEM) AND ITEM > 0 THEN
            X.TEMP = ITEM
            X.DISPLAY = 1
            WHICH.TABLE.ROW = 0
            LOOP
               WHICH.TABLE.ROW += 1
               Y = MOD(X.TEMP,2)
               IF Y GT 0 THEN
                  DLMAIN.DEBUG.LEVEL(WHICH.TABLE.ROW) = TRUE
                  CRT 'SETTING DEBUG.LEVEL ':X.DISPLAY
               END
               X.TEMP = INT(X.TEMP/2)
               X.DISPLAY = 2*X.DISPLAY
            UNTIL (X.TEMP = 0) OR (WHICH.TABLE.ROW GT 7)
            REPEAT
         END ELSE
            DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be a number greater than 0'
            MAT DLMAIN.DEBUG.LEVEL = DEFAULT.DEBUG.LEVEL
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be a number greater than 0'
         MAT DLMAIN.DEBUG.LEVEL = DEFAULT.DEBUG.LEVEL
      END
      RETURN


*
*
* PROCESS OPTION "XML.ALLOW.PERIODS"
*
PROCESS.OPTION.XML.ALLOW.PERIODS: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.XML.ALLOW.PERIODS '
      END
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      XML.ALLOW.PERIODS = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "XML.UPCASE"
*
PROCESS.OPTION.XML.UPCASE: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.XML.UPCASE '
      END
      ITEM.USED.LIST<ITEM.CTR> = TRUE
      XML.UPCASE = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "PRINT.LAYOUT"
*
PROCESS.OPTION.PRINT.LAYOUT: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.PRINT.LAYOUT '
      END
      DLMAIN.PRINT.LAYOUT = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "SAMPLE"
*
PROCESS.OPTION.SAMPLE: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.SAMPLE '
      END
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            DLMAIN.SAMPLE.SIZE = ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be a number greater than 0'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.SAMPLE.SIZE = DEFAULT.DLMAIN.SAMPLE.SIZE
      END
      RETURN


*
*
* PROCESS OPTION "FROM"
*
PROCESS.OPTION.FROM: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.FROM '
      END
      TEMP.ERRMSG = ORIGINAL.ITEM:' must be followed by a select list number from '
      TEMP.ERRMSG := '0 to ':DBMS.HIGHEST.SELECT.UNIT
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         IF ITEM >= 0 AND ITEM <= DBMS.HIGHEST.SELECT.UNIT THEN
            DLMAIN.FROM.UNIT = ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
*
* PROCESS OPTION "DEFAULT"
*
PROCESS.OPTION.DEFAULT: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.DEFAULT '
      END
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE # 'QUALIFIER' THEN
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' must be followed by a valid field qualifier, not ':ITEM
         RETURN
      END
      LOCATE WHICH.QUALIFIER IN QUALIFIERS.WITH.NO.DEFAULT<1> SETTING TEMP.POS THEN
         DLMAIN.ERRMSG<-1> = 'There is no default value for ':ITEM
         RETURN
      END
      CHECK.QUALIFIER = WHICH.QUALIFIER
      LOOKUP.FIELD.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      IF ITEMS.DONE THEN
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a value'
         RETURN
      END
      BEGIN CASE
         CASE CHECK.QUALIFIER = 'LINE'
            GOSUB PROCESS.DEFAULT.LINE
         CASE CHECK.QUALIFIER = 'FMT'
            GOSUB PROCESS.DEFAULT.FMT
         CASE CHECK.QUALIFIER = 'CONV'
            GOSUB PROCESS.DEFAULT.CONV
         CASE CHECK.QUALIFIER = 'HTML.START'
            GOSUB PROCESS.DEFAULT.HTML.START
         CASE CHECK.QUALIFIER = 'HTML.END'
            GOSUB PROCESS.DEFAULT.HTML.END
         CASE CHECK.QUALIFIER = 'HTML.CELL'
            GOSUB PROCESS.DEFAULT.HTML.CELL
         CASE CHECK.QUALIFIER = 'HTML.ROW'
            GOSUB PROCESS.DEFAULT.HTML.ROW
         CASE CHECK.QUALIFIER = 'NUM.VALUES'
            GOSUB PROCESS.DEFAULT.NUM.VALUES
         CASE CHECK.QUALIFIER = 'NUM.SUBVALUES'
            GOSUB PROCESS.DEFAULT.NUM.SUBVALUES
         CASE CHECK.QUALIFIER = 'LENGTH'
            GOSUB PROCESS.DEFAULT.LENGTH
         CASE CHECK.QUALIFIER = 'BEG.COL'
            GOSUB PROCESS.DEFAULT.BEG.COL
         CASE CHECK.QUALIFIER = 'MV.ORIENTATION'
            GOSUB PROCESS.DEFAULT.MV.ORIENTATION
         CASE CHECK.QUALIFIER = 'VALUE.SEPARATOR'
            GOSUB PROCESS.DEFAULT.VALUE.SEPARATOR
         CASE CHECK.QUALIFIER = 'SUBVALUE.SEPARATOR'
            GOSUB PROCESS.DEFAULT.SUBVALUE.SEPARATOR
         CASE CHECK.QUALIFIER = 'DEFAULT.VALUE'
            GOSUB PROCESS.DEFAULT.DEFAULT.VALUE
      END CASE
      RETURN
*
* PROCESS "DEFAULT NUM.VALUES"
*
PROCESS.DEFAULT.NUM.VALUES: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.NUM.VALUES '
      END
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a number greater than 0 or "ALL"'
      IF ITEM.TYPE = '' OR (ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.ALL) THEN
         BEGIN CASE
            CASE ITEM.KEYWORD = KEYWORD.ALL
               DEFAULT.NUM.VALUES = 'ALL'
               SET.DEFAULT.NUM.VALUES = TRUE
            CASE NUM(ITEM) AND ITEM > 0
               DEFAULT.NUM.VALUES = ITEM
               SET.DEFAULT.NUM.VALUES = TRUE
            CASE 1
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
* PROCESS "DEFAULT NUM.SUBVALUES"
*
PROCESS.DEFAULT.NUM.SUBVALUES: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.NUM.SUBVALUES '
      END
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a number greater than 0 or "ALL"'
      IF ITEM.TYPE = '' OR (ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.ALL) THEN
         BEGIN CASE
            CASE ITEM.KEYWORD = KEYWORD.ALL
               DEFAULT.NUM.SUBVALUES = 'ALL'
               SET.DEFAULT.NUM.SUBVALUES = TRUE
            CASE NUM(ITEM) AND ITEM > 0
               DEFAULT.NUM.SUBVALUES = ITEM
               SET.DEFAULT.NUM.SUBVALUES = TRUE
            CASE 1
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
* PROCESS "DEFAULT MV.ORIENTATION"
*
PROCESS.DEFAULT.MV.ORIENTATION: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.MV.ORIENTATION '
      END
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' specified must be in this list: "':ORIENTATION.TYPE.LIST:'"'
      CONVERT @FM:@VM:@SM TO '   ' IN TEMP.ERRMSG
      LOCATE ITEM IN ORIENTATION.TYPE.LIST<1> SETTING POS THEN
         DEFAULT.MV.ORIENTATION = ITEM
         ITEM.TYPE = ''
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
* PROCESS "DEFAULT VALUE.SEPARATOR"
*
PROCESS.DEFAULT.VALUE.SEPARATOR: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.VALUE.SEPARATOR '
      END
      DEFAULT.VALUE.SEPARATOR = ITEM
      SET.DEFAULT.VALUE.SEPARATOR = TRUE
      ITEM.TYPE = ''
      GOSUB GET.NEXT.ITEM
      RETURN


*
* PROCESS "DEFAULT SUBVALUE.SEPARATOR"
*
PROCESS.DEFAULT.SUBVALUE.SEPARATOR: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.SUBVALUE.SEPARATOR '
      END
      DEFAULT.SUBVALUE.SEPARATOR = ITEM
      SET.DEFAULT.SUBVALUE.SEPARATOR = TRUE
      ITEM.TYPE = ''
      GOSUB GET.NEXT.ITEM
      RETURN


*
* PROCESS "DEFAULT DEFAULT.VALUE"
*
PROCESS.DEFAULT.DEFAULT.VALUE: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.DEFAULT.VALUE '
      END
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a value to use.'
      BEGIN CASE
         CASE ITEM # '' AND ITEM.KEYWORD = ''
            DEFAULT.DEFAULT.VALUE = ITEM
         CASE 1
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN
*
* PROCESS "DEFAULT LINE"
*
PROCESS.DEFAULT.LINE: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.LINE '
      END
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a number greater than 0'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE NUM(ITEM) AND ITEM > 0
               DEFAULT.LINE = ITEM
            CASE 1
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
* PROCESS "DEFAULT BEG.COL"
*
PROCESS.DEFAULT.BEG.COL: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.BEG.COL '
      END
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a number greater than 0'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE NUM(ITEM) AND ITEM > 0
               DEFAULT.BEG.COL = ITEM
            CASE 1
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
* PROCESS "DEFAULT LENGTH"
*
PROCESS.DEFAULT.LENGTH: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.LENGTH '
      END
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a number greater than 0'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE NUM(ITEM) AND ITEM > 0
               DEFAULT.LENGTH = ITEM
            CASE 1
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
* PROCESS "DEFAULT FMT"
*
PROCESS.DEFAULT.FMT: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.FMT '
      END
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a valid FMT code or ""'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE ITEM = ''
               DEFAULT.FMT = NULL.CODE
            CASE 1
               TEST = FMT('',ITEM)
               IF STATUS() THEN
                  DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
               END ELSE
                  DEFAULT.FMT = ITEM
               END
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN
*
* PROCESS "DEFAULT CONV"
*
PROCESS.DEFAULT.CONV: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.CONV '
      END
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':CHECK.QUALIFIER:' must be followed by a valid CONV code or ""'
      IF ITEM.TYPE = '' THEN
         BEGIN CASE
            CASE ITEM = ''
               DEFAULT.CONV = NULL.CODE
            CASE 1
               TEST = OCONV('',ITEM)
               IF STATUS() THEN
                  DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
               END ELSE
                  DEFAULT.CONV = ITEM
               END
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
* PROCESS "DEFAULT HTML.START"
*
PROCESS.DEFAULT.HTML.START: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.HTML.START '
      END
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         DEFAULT.HTML.START = X.LIT.DICT.EVAL
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
* PROCESS "DEFAULT HTML.END"
*
PROCESS.DEFAULT.HTML.END: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.HTML.END '
      END
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         DEFAULT.HTML.END = X.LIT.DICT.EVAL
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
* PROCESS "DEFAULT HTML.CELL"
*
PROCESS.DEFAULT.HTML.CELL: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.HTML.CELL '
      END
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         DEFAULT.HTML.CELL = X.LIT.DICT.EVAL
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
* PROCESS "DEFAULT HTML.ROW"
*
PROCESS.DEFAULT.HTML.ROW: 
      DEBUG4
      CRT 'GOSUB PROCESS.DEFAULT.HTML.ROW '
      END
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         DEFAULT.HTML.ROW = X.LIT.DICT.EVAL
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "USING"
*
PROCESS.OPTION.USING: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.USING '
      END
      DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' may only be specified once on the command line'
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "FORMAT"
*
PROCESS.OPTION.FORMAT: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.FORMAT '
      END
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' specified must be in this list: "':FORMAT.TYPE.LIST<1>:'"'
      CONVERT @FM:@VM:@SM TO '   ' IN TEMP.ERRMSG
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEMS.DONE THEN
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         DLMAIN.FATAL.ERROR = TRUE
      END ELSE
         LOCATE ITEM IN FORMAT.TYPE.LIST<1,1> SETTING POS THEN
            DLMAIN.FORMAT = FORMAT.TYPE.LIST<2,POS>
            ITEM.TYPE = ''
            GOSUB GET.NEXT.ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      TEMP.ERRMSG = ''
      RETURN


*
*
* PROCESS OPTION "RECORD.ORIENTATION"
*
PROCESS.OPTION.RECORD.ORIENTATION: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.RECORD.ORIENTATION '
      END
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' specified must be in this list: "':ORIENTATION.TYPE.LIST:'"'
      CONVERT @FM:@VM:@SM TO '   ' IN TEMP.ERRMSG
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEMS.DONE THEN
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         DLMAIN.FATAL.ERROR = TRUE
      END ELSE
         LOCATE ITEM IN ORIENTATION.TYPE.LIST<1> SETTING POS THEN
            DLMAIN.RECORD.ORIENTATION = ITEM
            ITEM.TYPE = ''
            GOSUB GET.NEXT.ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      RETURN


*
*
* PROCESS OPTION "RECORD.LENGTH"
*
PROCESS.OPTION.RECORD.LENGTH: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.RECORD.LENGTH '
      END
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' specified must be a positive number'
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEMS.DONE THEN
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         DLMAIN.FATAL.ERROR = TRUE
      END ELSE
         IF NUM(ITEM) AND ITEM > 0 THEN
            DLMAIN.RECORD.LENGTH = ITEM
            ITEM.TYPE = ''
            GOSUB GET.NEXT.ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      RETURN


*
*
* PROCESS OPTION "NO.LINEFEED"
*
PROCESS.OPTION.NO.LINEFEED: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.NO.LINEFEED '
      END
      GOSUB GET.NEXT.ITEM
      DLMAIN.NO.LINEFEED = TRUE
      RETURN


*
*
* PROCESS OPTION "FILE"
*
PROCESS.OPTION.FILE: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.FILE '
      END
      LOOKUP.FIELD.NAME = FALSE
      LOOKUP.FILE.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      TEMP.ERRMSG = 'Invalid syntax "':ORIGINAL.ITEM:' ':ITEM.QUOTED:ITEM:ITEM.QUOTED:'": should be "':ORIGINAL.ITEM:' Type1FileName RecordInFile"'
      IF ITEM.TYPE = 'DIR' OR ITEM.TYPE = 'FILE' THEN
         DLMAIN.OUTPUT.FILE.NAME = ITEM
         DLMAIN.OUTPUT.FILE.TYPE = ITEM.TYPE
         LOOKUP.FIELD.NAME = FALSE
         GOSUB GET.NEXT.ITEM
         IF ITEMS.DONE THEN
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END ELSE
            DLMAIN.OUTPUT.RECORD.NAME = ITEM
            DEBUG2
            CRT 'Writing to ':DLMAIN.OUTPUT.FILE.NAME:' ':DLMAIN.OUTPUT.RECORD.NAME
         END
         GOSUB GET.NEXT.ITEM
      END
      END ELSE
      DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
*
* PROCESS OPTION "BY.EXP"
*
PROCESS.OPTION.BY.EXP: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.BY.EXP '
      END
      IF BY.EXP.FIELD = '' THEN
         GOSUB GET.NEXT.ITEM
         IF ITEM.TYPE = 'FIELD' THEN
            GOSUB PO.BY.EXP.FIELD
         END ELSE
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':ORIGINAL.ITEM:' ':ITEM:'": should be "':ORIGINAL.ITEM:' multi-valuedField"'
         END
      END ELSE
         GOSUB GET.NEXT.ITEM
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' may only be specified once on the command line'
      END
      RETURN


*
*
* PROCESS OPTION 'BY.EXP field' handle a field
*
PO.BY.EXP.FIELD: 
      ITEM.SM = DICT.REC<6>
      IF (ITEM.FIELD.TYPE = 'I' OR ITEM.FIELD.TYPE = 'D') AND ITEM.SM = 'M' THEN
         GOSUB CHECK.ASSOC.NAME
         IF WHEN.ASSOC.NAME.IS.OKAY THEN
            BY.EXP.FIELD = ITEM
            DICT.FIELD.NAME = ITEM
            DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
            GOSUB ADD.DICT.REC
            BY.EXP.DICT.CTR = WHICH.DICT.REC.CTR
            WHEN.ASSOC.CONTROL.DICT.CTR = WHICH.DICT.REC.CTR
         END ELSE
            IF WHEN.ASSOC.NAME.IS.FIELD.NAME THEN
               DLMAIN.ERRMSG<-1> = 'The field "':ITEM:'" and "':WHEN.ASSOC.NAME:'" are not associated'
            END ELSE
               DLMAIN.ERRMSG<-1> = 'The association name "':DICT.REC<7>:'" in "':ORIGINAL.ITEM:' ':ITEM:'"'
               DLMAIN.ERRMSG<-1> = '     does not match the association name "':WHEN.ASSOC.NAME:'" already being used'
            END
         END
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':ORIGINAL.ITEM:' ':ITEM:'": should be "':ORIGINAL.ITEM:' multi-valuedField"'
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* ADD DICT.REC
*
ADD.DICT.REC: 
      LOCATE DICT.FIELD.NAME IN DL.DATA.DICT.REC.FIELD.LIST<1> SETTING WHICH.DICT.REC.CTR ELSE
         DL.DATA.NUM.DICT.RECS += 1
         IF DL.DATA.NUM.DICT.RECS > DLMAX.DICT.RECS THEN
            DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many dictionary items: ':DL.DATA.NUM.DICT.RECS
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
         DL.DATA.DICT.RECS(DL.DATA.NUM.DICT.RECS) = DICT.REC
         DL.DATA.DICT.REC.FIELD.LIST<DL.DATA.NUM.DICT.RECS> = DICT.FIELD.NAME
         DL.DATA.DICT.REC.FILE.NUM(DL.DATA.NUM.DICT.RECS) = ITEM.FIELD.FILE.NUM
         WHICH.DICT.REC.CTR = DL.DATA.NUM.DICT.RECS
         IF DLMAIN.INFO.FILE.KEY.IS.MULTIVALUE(ITEM.FIELD.FILE.NUM) AND ITEM.FIELD.FILE.NUM # PRIMARY.FILE.NUM THEN
            FILE.KEY.ASSOC = DL.DATA.DICT.RECS(DLMAIN.INFO.FILE.KEY.DICT.CTR(ITEM.FIELD.FILE.NUM))<7>
            DL.DATA.DICT.RECS(DL.DATA.NUM.DICT.RECS)<7> = FILE.KEY.ASSOC
         END
      END
      RETURN


*
*
* CHECK WHEN.ASSOC NAME
*
CHECK.ASSOC.NAME: 
      WHEN.ASSOC.NAME.IS.OKAY = FALSE
      DICT.ASSOC.NAME = DICT.REC<7>
      IF WHEN.ASSOC.NAME = '' THEN
         WHEN.ASSOC.NAME.IS.OKAY = TRUE
         IF DICT.ASSOC.NAME = '' THEN
            WHEN.ASSOC.NAME = ITEM
            WHEN.ASSOC.NAME.IS.FIELD.NAME = TRUE
         END ELSE
            WHEN.ASSOC.NAME = DICT.ASSOC.NAME
            WHEN.ASSOC.NAME.IS.FIELD.NAME = FALSE
         END
      END ELSE
         IF WHEN.ASSOC.NAME.IS.FIELD.NAME THEN
            IF WHEN.ASSOC.NAME = ITEM THEN
               WHEN.ASSOC.NAME.IS.OKAY = TRUE
            END
         END ELSE
            IF WHEN.ASSOC.NAME = DICT.ASSOC.NAME THEN
               WHEN.ASSOC.NAME.IS.OKAY = TRUE
            END
         END
      END
      RETURN


*
*
* PROCESS OPTION "WHEN"
*
PROCESS.OPTION.WHEN: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.WHEN '
      END
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE # 'FIELD' THEN
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':ORIGINAL.ITEM:' ':ITEM:'": should be "':ORIGINAL.ITEM:' multi-valuedField operator value"'
         DLMAIN.FATAL.ERROR = TRUE
         RETURN
      END
*
      ITEM.SM = DICT.REC<6>
      IF ITEM.SM # 'M' OR (ITEM.FIELD.TYPE # 'I' AND ITEM.FIELD.TYPE # 'D') THEN
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':ORIGINAL.ITEM:' ':ITEM:'": should be "':ORIGINAL.ITEM:' multi-valuedField operator value"'
         DLMAIN.FATAL.ERROR = TRUE
         GOSUB GET.NEXT.ITEM
         RETURN
      END
      GOSUB CHECK.ASSOC.NAME
      IF NOT(WHEN.ASSOC.NAME.IS.OKAY) THEN
         IF WHEN.ASSOC.NAME.IS.FIELD.NAME THEN
            DLMAIN.ERRMSG<-1> = 'The field "':ITEM:'" and "':WHEN.ASSOC.NAME:'" are not associated'
            DLMAIN.FATAL.ERROR = TRUE
         END ELSE
            DLMAIN.ERRMSG<-1> = 'The association name "':DICT.REC<7>:'" in "':ORIGINAL.ITEM:' ':ITEM:'"'
            DLMAIN.ERRMSG<-1> = '     does not match the association name "':WHEN.ASSOC.NAME:'" already being used'
         END
         GOSUB GET.NEXT.ITEM
         RETURN
      END
*
      SAVE.FIELD = ITEM
      SAVE.FILE.NUM = ITEM.FIELD.FILE.NUM
      SAVE.DICT.REC = DICT.REC
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE # 'OPERATOR' THEN
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':ORIGINAL.ITEM:' ':ITEM:'": should be "':ORIGINAL.ITEM:' multi-valuedField operator value"'
         DLMAIN.ERRMSG<-1> = '     "':ITEM:'" is not a valid operator'
         DLMAIN.FATAL.ERROR = TRUE
         RETURN
      END
      SAVE.OPERATOR = WHICH.OPERATOR
      GOSUB GET.NEXT.ITEM
      BEGIN CASE
         CASE ITEM.TYPE = 'FIELD' AND (ITEM.FIELD.TYPE = 'I' OR ITEM.FIELD.TYPE = 'D')
            SAVE.VALUE.IS.FIELD = TRUE
            DICT.FIELD.NAME = ITEM
            DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
            GOSUB ADD.DICT.REC
            SAVE.VALUE.LIST = WHICH.DICT.REC.CTR
            GOSUB GET.NEXT.ITEM
         CASE ITEM.TYPE = ''
            SAVE.VALUE.IS.FIELD = FALSE
            SAVE.VALUE.LIST = ITEM
            LOOP
               GOSUB GET.NEXT.ITEM
            UNTIL ITEM.TYPE # '' OR ITEMS.DONE
               SAVE.VALUE.LIST := @VM:ITEM
            REPEAT
         CASE 1
            DLMAIN.ERRMSG<-1> = 'Invalid syntax "':ORIGINAL.ITEM
            DLMAIN.ERRMSG := ' ':SAVE.FIELD:' ':SAVE.OPERATOR:' ':ITEM:'"'
            DLMAIN.ERRMSG := ' should be "':ORIGINAL.ITEM:' multi-valuedField operator value"'
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
      END CASE
*
* ADD TO LIST OF "WHEN" FIELDS
*
      NUM.WHEN.FIELDS += 1
      WHEN.FIELD.LIST<NUM.WHEN.FIELDS> = SAVE.FIELD
      WHEN.OPERATOR.LIST<NUM.WHEN.FIELDS> = SAVE.OPERATOR
      WHEN.CHECK.VALUE.IS.FIELD.LIST<NUM.WHEN.FIELDS> = SAVE.VALUE.IS.FIELD
      WHEN.CHECK.VALUE.LIST<NUM.WHEN.FIELDS> = SAVE.VALUE.LIST
*
      LAST.DICT.REC = DICT.REC
      LAST.DICT.FIELD.NAME = DICT.FIELD.NAME
      LAST.DICT.FILE.NUM = DICT.FILE.NUM
      DICT.REC = SAVE.DICT.REC
      DICT.FIELD.NAME = SAVE.FIELD
      DICT.FILE.NUM = SAVE.FILE.NUM
      GOSUB ADD.DICT.REC
      DICT.REC = LAST.DICT.REC
      DICT.FIELD.NAME = LAST.DICT.FIELD.NAME
      DICT.FILE.NUM = LAST.DICT.FILE.NUM
      WHEN.DICT.CTR.LIST<NUM.WHEN.FIELDS> = WHICH.DICT.REC.CTR
      IF NOT(WHEN.ASSOC.CONTROL.DICT.CTR) THEN
         WHEN.ASSOC.CONTROL.DICT.CTR = WHICH.DICT.REC.CTR
      END
      RETURN


*
*
* PROCESS OPTION "UPCASE"
*
PROCESS.OPTION.UPCASE: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.UPCASE '
      END
      DLMAIN.UPCASE = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
* PROCESS OPTION "REMOVE.PUNCTUATION"
*
PROCESS.OPTION.REMOVE.PUNCTUATION: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.REMOVE.PUNCTUATION '
      END
      DLMAIN.REMOVE.PUNCTUATION = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "FIELD.GAP"
*
PROCESS.OPTION.FIELD.GAP: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.FIELD.GAP '
      END
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' specified must be a non-negative integer.'
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEMS.DONE THEN
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         DLMAIN.FATAL.ERROR = TRUE
      END ELSE
         IF NUM(ITEM) AND (INT(ITEM) EQ ITEM) AND (ITEM GE 0) THEN
            DLMAIN.FIELD.GAP = ITEM
            ITEM.TYPE = ''
            GOSUB GET.NEXT.ITEM
         END ELSE
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      RETURN


*
*
* PROCESS OPTION "OVERWRITING"
*
PROCESS.OPTION.OVERWRITING: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.OVERWRITING '
      END
      DLMAIN.OVERWRITING = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "APPEND"
*
PROCESS.OPTION.APPEND: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.APPEND '
      END
      DLMAIN.APPEND = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "HEADING"
*
PROCESS.OPTION.HEADING: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.HEADING '
      END
      IF DLMAIN.HEADING.OUT.REC # '' THEN
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' may be specified only once.'
         GOSUB GET.NEXT.ITEM
         RETURN
      END ELSE
         DL.OUTR.NUM.OUT.RECS += 1
         IF DL.OUTR.NUM.OUT.RECS > DLMAX.OUT.RECS THEN
            DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many output records: ':DL.OUTR.NUM.OUT.RECS
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
         CUR.OUT.REC = DL.OUTR.NUM.OUT.RECS
         DLMAIN.HEADING.OUT.REC = DL.OUTR.NUM.OUT.RECS
         GOSUB GET.NEXT.ITEM
      END
      RETURN


*
*
* PROCESS OPTION "DETAIL"
*
PROCESS.OPTION.DETAIL: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.DETAIL '
      END
      CUR.OUT.REC = DL.OUTR.DETAIL.OUT.REC
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "HEADING.ON"
*
PROCESS.OPTION.HEADING.ON: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.HEADING.ON '
      END
      GOSUB GET.NEXT.ITEM
      PHRASE.USED = ORIGINAL.ITEM:' ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      TEMP.ERRMSG = 'Invalid syntax "':PHRASE.USED:'" should be "':ORIGINAL.ITEM:' BreakField"'
      HAVE.VALID.HEADING = FALSE
      BEGIN CASE
         CASE ITEM.TYPE = 'FIELD'
            DICT.FIELD.NAME = ITEM
            DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
            GOSUB ADD.DICT.REC
            LOCATE WHICH.DICT.REC.CTR IN DLMAIN.BREAK.DICT.CTR.LIST<1> SETTING BREAK.LIST.CTR THEN
               IF DLMAIN.BREAK.HEADING.OUT.REC.LIST<BREAK.LIST.CTR> # '' THEN
                  TEMP.ERRMSG = PHRASE.USED:' may be specified only once.'
               END ELSE
                  HAVE.VALID.HEADING = TRUE
                  DL.OUTR.NUM.OUT.RECS += 1
                  IF DL.OUTR.NUM.OUT.RECS > DLMAX.OUT.RECS THEN
                     DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many output records: ':DL.OUTR.NUM.OUT.RECS
                     DLMAIN.FATAL.ERROR = TRUE
                     RETURN
                  END
                  CUR.OUT.REC = DL.OUTR.NUM.OUT.RECS
                  DLMAIN.BREAK.HEADING.OUT.REC.LIST<BREAK.LIST.CTR> = DL.OUTR.NUM.OUT.RECS
                  GOSUB GET.NEXT.ITEM
               END
            END
      END CASE
      IF NOT(HAVE.VALID.HEADING) THEN
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
*
* PROCESS OPTION "FOOTING"
*
PROCESS.OPTION.FOOTING: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.FOOTING '
      END
      IF DLMAIN.FOOTING.OUT.REC # '' THEN
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' may be specified only once.'
      END ELSE
         DL.OUTR.NUM.OUT.RECS += 1
         IF DL.OUTR.NUM.OUT.RECS > DLMAX.OUT.RECS THEN
            DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many output records: ':DL.OUTR.NUM.OUT.RECS
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
         CUR.OUT.REC = DL.OUTR.NUM.OUT.RECS
         DLMAIN.FOOTING.OUT.REC = DL.OUTR.NUM.OUT.RECS
         GOSUB GET.NEXT.ITEM
      END
      RETURN


*
*
* PROCESS OPTION "FOOTING.ON"
*
PROCESS.OPTION.FOOTING.ON: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.FOOTING.ON '
      END
      GOSUB GET.NEXT.ITEM
      PHRASE.USED = ORIGINAL.ITEM:' ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      BREAK.LIST.CTR = ''
      BEGIN CASE
         CASE ITEM.TYPE = 'FIELD'
            DICT.FIELD.NAME = ITEM
            DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
            GOSUB ADD.DICT.REC
            LOCATE WHICH.DICT.REC.CTR IN DLMAIN.BREAK.DICT.CTR.LIST<1> SETTING BREAK.LIST.CTR ELSE
               BREAK.LIST.CTR = ''
            END
         CASE ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.FINAL
            BREAK.LIST.CTR = 1
            IF DLMAIN.NUM.BREAK.FIELDS = 0 THEN
               DLMAIN.NUM.BREAK.FIELDS += 1
               DLMAIN.BREAK.DICT.CTR.LIST<DLMAIN.NUM.BREAK.FIELDS> = 'ALL'
            END
         CASE ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.ALL
            BREAK.LIST.CTR = 'ALL'
            DL.OUTR.NUM.OUT.RECS += 1
            IF DL.OUTR.NUM.OUT.RECS > DLMAX.OUT.RECS THEN
               DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many output records: ':DL.OUTR.NUM.OUT.RECS
               DLMAIN.FATAL.ERROR = TRUE
               RETURN
            END
            CUR.OUT.REC = DL.OUTR.NUM.OUT.RECS
            DEFAULT.OUT.REC = DL.OUTR.NUM.OUT.RECS
      END CASE
      IF NOT(BREAK.LIST.CTR) THEN
         DLMAIN.ERRMSG<-1> = 'Invalid syntax "':PHRASE.USED:'" should be:'
         DLMAIN.ERRMSG<-1> = '"':ORIGINAL.ITEM:' BreakField | ALL | FINAL" [NONE]'
         RETURN
      END
*
      GOSUB GET.NEXT.ITEM
      IF BREAK.LIST.CTR = 'ALL' THEN
         IF ITEM = KEYWORD.NONE THEN
            DEFAULT.OUT.REC = KEYWORD.NONE
            GOSUB GET.NEXT.ITEM
         END
      END ELSE
         IF DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> # '' THEN
            DLMAIN.ERRMSG<-1> = PHRASE.USED:' may be specified only once.'
         END ELSE
            IF ITEM = KEYWORD.NONE THEN
               DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> = KEYWORD.NONE
               GOSUB GET.NEXT.ITEM
            END ELSE
               DL.OUTR.NUM.OUT.RECS += 1
               IF DL.OUTR.NUM.OUT.RECS > DLMAX.OUT.RECS THEN
                  DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many output records: ':DL.OUTR.NUM.OUT.RECS
                  DLMAIN.FATAL.ERROR = TRUE
                  RETURN
               END
               CUR.OUT.REC = DL.OUTR.NUM.OUT.RECS
               DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> = DL.OUTR.NUM.OUT.RECS
            END
         END
      END
      RETURN


*
*
* PROCESS OPTION "DET.SUP"
*
PROCESS.OPTION.DET.SUP: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.DET.SUP '
      END
      IF DLMAIN.DET.SUP THEN
         DLMAIN.ERRMSG<-1> = ORIGINAL.ITEM:' may be specified only once.'
      END ELSE
         DLMAIN.DET.SUP = TRUE
      END
      GOSUB GET.NEXT.ITEM
      RETURN



PROCESS.OPTION.QUOTE.CHAR: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.QUOTE.CHAR '
      END
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      DLMAIN.QUOTE = ITEM[1,1]
      GOSUB GET.NEXT.ITEM
      RETURN



PROCESS.OPTION.COMMA.CHAR: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.COMMA.CHAR '
      END
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      COUNT.CARATS = COUNT(ITEM,'^')
      DLMAIN.COMMA = FIELD(ITEM,'^',1,1)
      FOR WHICH.CARAT = 2 TO COUNT.CARATS+1
         TEST.VALUE = FIELD(ITEM,'^',WHICH.CARAT,1)
         IF NUM(TEST.VALUE) AND TEST.VALUE # '' THEN
            DLMAIN.COMMA := CHAR(TEST.VALUE)
         END ELSE
            DLMAIN.COMMA := TEST.VALUE
         END
      NEXT WHICH.CARAT
      GOSUB GET.NEXT.ITEM
      RETURN

PROCESS.OPTION.EOR.CHAR: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.EOR.CHAR '
      END
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      COUNT.CARATS = COUNT(ITEM,'^')
      DLMAIN.EOR = FIELD(ITEM,'^',1,1)
      FOR WHICH.CARAT = 2 TO COUNT.CARATS+1
         TEST.VALUE = FIELD(ITEM,'^',WHICH.CARAT,1)
         IF NUM(TEST.VALUE) AND TEST.VALUE # '' THEN
            DLMAIN.EOR := CHAR(TEST.VALUE)
         END ELSE
            DLMAIN.EOR := TEST.VALUE
         END
      NEXT WHICH.CARAT
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "HTML.TITLE"
*
PROCESS.OPTION.HTML.TITLE: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.HTML.TITLE '
      END
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         DL.OUTR.DOCUMENT.TITLE = X.LIT.DICT.EVAL
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "HTML.TOP"
*
PROCESS.OPTION.HTML.TOP: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.HTML.TOP '
      END
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         DL.OUTR.DOCUMENT.TOP = X.LIT.DICT.EVAL
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "HTML.BOTTOM"
*
PROCESS.OPTION.HTML.BOTTOM: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.HTML.BOTTOM '
      END
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         DL.OUTR.DOCUMENT.BOTTOM = X.LIT.DICT.EVAL
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "HTML.TABLE"
*
PROCESS.OPTION.HTML.TABLE: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.HTML.TABLE '
      END
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         DL.OUTR.DOCUMENT.TABLE = X.LIT.DICT.EVAL
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "HTML.BODY"
*
PROCESS.OPTION.HTML.BODY: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.HTML.BODY '
      END
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         DL.OUTR.DOCUMENT.BODY = X.LIT.DICT.EVAL
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      GOSUB GET.NEXT.ITEM
      RETURN



*
*
* PROCESS OPTION "XML.FILE.NAME"
*
PROCESS.OPTION.XML.FILE.NAME: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.XML.FILE.NAME '
      END
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         IF X.LIT.DICT.EVAL.TYPE = 'LIT' THEN
            X.ITEM.OUT = ''
            X.DO.LOWER.CASE = FALSE
            CALL DLXMLELEM(X.ITEM.OUT,ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML file name "':ITEM:'" does not generate a valid XML name.'
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               DL.OUTR.XML.FILE.NAME = X.ITEM.OUT
            END
         END ELSE
            DL.OUTR.XML.FILE.NAME = X.LIT.DICT.EVAL
         END
      END
      GOSUB GET.NEXT.ITEM
      RETURN



*
*
* PROCESS OPTION "XML.VERSION"
*
PROCESS.OPTION.XML.VERSION: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.XML.VERSION '
      END
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         DL.OUTR.XML.VERSION = ITEM
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Expecting XML version, found "':ITEM:'"'
      END
      RETURN


*
*
* PROCESS OPTION "XML.ROOT.NAME"
*
PROCESS.OPTION.XML.ROOT.NAME: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.XML.ROOT.NAME '
      END
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         DL.OUTR.XML.ROOT.NAME = X.LIT.DICT.EVAL
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "XML.ROOT.ATTRIBUTE"
*
PROCESS.OPTION.XML.ROOT.ATTRIBUTE: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.XML.ROOT.ATTRIBUTE '
      END
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         DL.OUTR.XML.ROOT.ATTRIBUTE = X.LIT.DICT.EVAL
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS OPTION "XML.FILE.ATTRIBUTE"
*
PROCESS.OPTION.XML.FILE.ATTRIBUTE: 
      DEBUG4
      CRT 'GOSUB PROCESS.OPTION.XML.FILE.ATTRIBUTE '
      END
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF VALID.VALUE THEN
         DL.OUTR.XML.FILE.ATTRIBUTE = X.LIT.DICT.EVAL
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS.MISC.FIELD
*
PROCESS.MISC.FIELD: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.MISC.FIELD'
      CRT 'WHICH.MISC.FIELD: ':WHICH.MISC.FIELD
      END
      X.CURRENT.TYPE = WHICH.MISC.FIELD
      BEGIN CASE
         CASE WHICH.MISC.FIELD = 'LITERAL'
            GOSUB PROCESS.MISC.FIELD.LITERAL
         CASE WHICH.MISC.FIELD = 'EVAL'
            GOSUB PROCESS.MISC.FIELD.EVAL
         CASE WHICH.MISC.FIELD = 'SUBR'
            GOSUB PROCESS.MISC.FIELD.SUBR
      END CASE
      RETURN


*
*
* PROCESS MISC.FIELD "LITERAL"
*
PROCESS.MISC.FIELD.LITERAL: 
      DEBUG4
      CRT 'GOSUB PROCESS.MISC.FIELD.LITERAL '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         GOSUB PROCESS.MISC.FIELD.LITERAL.OPTION
         DLMAIN.NUM.LITERAL.VALUES += 1
         DLMAIN.LITERAL.VALUE.LIST<DLMAIN.NUM.LITERAL.VALUES> = ITEM
         DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC) += 1
         CUR.OUT.FIELD.CTR = DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)
         DL.OUTR.FIELD.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = 'LITERAL ':ITEM.QUOTED:ITEM:ITEM.QUOTED
         DL.OUTR.TYPE.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = 'LITERAL'
         DL.OUTR.CTR.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = DLMAIN.NUM.LITERAL.VALUES
         DL.OUTR.FMT.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = CALC.ITEM.LEN:'L'
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Not expecting ':ITEM:', ':ORIGINAL.ITEM:' must be followed by a literal value'
      END
      RETURN


*
*
* PROCESS MISC.FIELD "EVAL"
*
PROCESS.MISC.FIELD.EVAL: 
      DEBUG4
      CRT 'GOSUB PROCESS.MISC.FIELD.EVAL '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      IF ITEM.TYPE = '' THEN
         DLMAIN.NUM.EVAL.FORMULAE += 1
         DLMAIN.EVAL.FORMULAE(DLMAIN.NUM.EVAL.FORMULAE) = ITEM
         DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC) += 1
         CUR.OUT.FIELD.CTR = DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)
         DL.OUTR.FIELD.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = 'EVAL ':ITEM.QUOTED:ITEM:ITEM.QUOTED
         DL.OUTR.TYPE.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = 'EVAL'
         DL.OUTR.CTR.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = DLMAIN.NUM.EVAL.FORMULAE
         GOSUB GET.NEXT.ITEM
      END ELSE
         DLMAIN.ERRMSG<-1> = 'Not expecting ':ITEM:', ':ORIGINAL.ITEM:' must be followed by a literal value'
      END
      RETURN


PROCESS.MISC.FIELD.LITERAL.OPTION: 
      DEBUG4
      CRT 'GOSUB PROCESS.MISC.FIELD.LITERAL.OPTION '
      END
      CALC.ITEM.LEN = LEN(ITEM)
      NUM.ORIGINAL.ITEM.FIELDS = COUNT(ORIGINAL.ITEM,"'")
      IF MOD(NUM.ORIGINAL.ITEM.FIELDS,2) # 0 THEN
         DLMAIN.ERRMSG<-1> = 'Unbalanced quotation marks in LITERAL ':ORIGINAL.ITEM:'.'
         DLMAIN.FATAL.ERROR = TRUE
         RETURN
      END
      ORIGINAL.ITEM.START = 2
      FOR WHICH.ORIGINAL.ITEM = ORIGINAL.ITEM.START TO NUM.ORIGINAL.ITEM.FIELDS STEP 2
         ORIGINAL.ITEM.OPTIONS = FIELD(ORIGINAL.ITEM,"'",WHICH.ORIGINAL.ITEM,1)
         GOSUB PROCESS.ORIGINAL.ITEM.OPTIONS
      NEXT WHICH.ORIGINAL.ITEM
      RETURN



PROCESS.ORIGINAL.ITEM.OPTIONS: 
      DEBUG4
      CRT 'GOSUB PROCESS.ORIGINAL.ITEM.OPTIONS '
      END
      NUM.ORIGINAL.ITEM.OPTIONS = LEN(ORIGINAL.ITEM.OPTIONS)
      CALC.ITEM.LEN -= 2   ;* TWO QUOTES
      FOR WHICH.ORIGINAL.ITEM.OPTION = 1 TO NUM.ORIGINAL.ITEM.OPTIONS
         ORIGINAL.ITEM.OPTION = ORIGINAL.ITEM.OPTIONS[WHICH.ORIGINAL.ITEM.OPTION,1]
         BEGIN CASE
            CASE ORIGINAL.ITEM.OPTION = 'D'
               CALC.ITEM.LEN += 7  ;* 8 CHARACTERS REPLACING ONE CODE
            CASE ORIGINAL.ITEM.OPTION = 'T'
               CALC.ITEM.LEN += 19 ;* 20 CHARACTERS REPLACING ONE CODE
            CASE 1
               DLMAIN.ERRMSG<-1> = 'Unsupported LITERAL "quote" option: ':ORIGINAL.ITEM:'.'
               DLMAIN.FATAL.ERROR = TRUE
         END CASE
      NEXT WHICH.ORIGINAL.ITEM.OPTION
      RETURN


*
*
* PROCESS MISC.FIELD "SUBR"
*
PROCESS.MISC.FIELD.SUBR: 
      DEBUG4
      CRT 'GOSUB PROCESS.MISC.FIELD.SUBR '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.PHRASE = TRUE
      TEMP.ERRMSG = 'Invalid ':PHRASE.USED
      IF ITEM.TYPE = '' AND NOT(ITEM.QUOTED) THEN
         IF ITEM = '(' THEN
            GOSUB PROCESS.SUBR.ARG.LIST
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.MISC.FIELD:', expecting ('
            VALID.PHRASE = FALSE
         END
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER
         VALID.PHRASE = FALSE
      END
      IF VALID.PHRASE THEN
         GOSUB PROCESS.VALID.SUBR
      END ELSE
         DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
      END
      RETURN


*
*
* PROCESS SUBR ARGUMENT LIST
*
PROCESS.SUBR.ARG.LIST: 
      DEBUG4
      CRT 'GOSUB PROCESS.SUBR.ARG.LIST '
      END
      TEMP.SUBR.NAME = ''
      TEMP.SUBR.NUM.ARGS = 0
      TEMP.SUBR.ARG.TYPE = ''
      TEMP.SUBR.ARG.VALUE = ''
      TEMP.SUBR.ARG.DICT.CTR = ''
      PHRASE.USED := '('
      LOOP
      UNTIL (NOT(ITEM.QUOTED) AND ITEM = ')') OR NOT(VALID.PHRASE)
         GOSUB GET.NEXT.ITEM
         PHRASE.USED := ITEM.QUOTED:ITEM:ITEM.QUOTED
         BEGIN CASE
            CASE TEMP.SUBR.NAME = ''
               TEMP.SUBR.NAME = ITEM
               TEMP.SUBR.NUM.ARGS = 1
            CASE ITEM.TYPE = ''
               TEMP.SUBR.NUM.ARGS += 1
               TEMP.SUBR.ARG.TYPE<1,TEMP.SUBR.NUM.ARGS> = ''
               TEMP.SUBR.ARG.VALUE<1,TEMP.SUBR.NUM.ARGS> = ITEM
            CASE ITEM.TYPE = 'FIELD'
               TEMP.SUBR.NUM.ARGS += 1
               TEMP.SUBR.ARG.TYPE<1,TEMP.SUBR.NUM.ARGS> = 'FIELD'
               TEMP.SUBR.ARG.VALUE<1,TEMP.SUBR.NUM.ARGS> = ITEM
               DICT.FIELD.NAME = ITEM
               DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
               GOSUB ADD.DICT.REC
               TEMP.SUBR.ARG.DICT.CTR<1,TEMP.SUBR.NUM.ARGS> = WHICH.DICT.REC.CTR
         END CASE
         GOSUB GET.NEXT.ITEM
         IF ITEM.QUOTED OR (ITEM # ',' AND ITEM # ')') THEN
            VALID.PHRASE = FALSE
            TEMP.ERRMSG = 'Expecting a comma after ':PHRASE.USED
         END
         PHRASE.USED := ITEM.QUOTED:ITEM:ITEM.QUOTED
      REPEAT
      RETURN


*
*
* PROCESS VALID SUBR ITEM
*
PROCESS.VALID.SUBR: 
      DEBUG4
      CRT 'GOSUB PROCESS.VALID.SUBR '
      END
      SUBR.NAME = TEMP.SUBR.NAME
      SUBR.NUM.ARGS = TEMP.SUBR.NUM.ARGS
      GOSUB ADD.SUBR.TO.LIST
      IF DLMAIN.FATAL.ERROR THEN
         RETURN
      END
*
      NUM.USE.SUBRS += 1
      USE.SUBR.CTR.LIST<NUM.USE.SUBRS> = WHICH.SUBR.CTR
      USE.SUBR.ARG.TYPE.LIST<NUM.USE.SUBRS> = TEMP.SUBR.ARG.TYPE
      USE.SUBR.ARG.VALUE.LIST<NUM.USE.SUBRS> = TEMP.SUBR.ARG.VALUE
      USE.SUBR.ARG.DICT.CTR.LIST<NUM.USE.SUBRS> = TEMP.SUBR.ARG.DICT.CTR
*
      DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC) += 1
      CUR.OUT.FIELD.CTR = DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)
      DL.OUTR.TYPE.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = 'SUBR'
      DL.OUTR.FIELD.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = 'SUBR(':TEMP.SUBR.NAME:')'
      DL.OUTR.CTR.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = NUM.USE.SUBRS
      CUR.OUT.FIELD.CTR = DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* ADD SUBR TO LIST
*
ADD.SUBR.TO.LIST: 
      LOCATE SUBR.NAME IN SUBR.NAME.LIST<1> SETTING WHICH.SUBR.CTR THEN
         IF SUBR.NUM.ARGS # SUBR.NUM.ARGS.LIST(WHICH.SUBR.CTR) THEN
            DLMAIN.ERRMSG<-1> = 'Inconsistent number of arguements listed with SUBR(':SUBR.NAME:')'
            DLMAIN.ERRMSG<-1> = '   listed with ':SUBR.NUM.ARGS.LIST(WHICH.SUBR.CTR):' initially, and then with ':SUBR.NUM.ARGS:' arguements'
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
         IF SUBR.NUM.ARGS > DLMAX.SUBR.ARGS THEN
            DLMAIN.ERRMSG<-1> = 'Too many arguements listed with SUBR(':SUBR.NAME:'), maximum arguements is ':DLMAX.SUBR.ARGS
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
      END ELSE
         NUM.SUBR.NAMES += 1
         IF NUM.SUBR.NAMES > DLMAX.SUBR.NAMES THEN
            DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many SUBR() items: ':NUM.SUBR.NAMES
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
         SUBR.NAMES(NUM.SUBR.NAMES) = SUBR.NAME
         SUBR.NUM.ARGS.LIST(NUM.SUBR.NAMES) = SUBR.NUM.ARGS
         SUBR.NAME.LIST<NUM.SUBR.NAMES> = SUBR.NAME
         WHICH.SUBR.CTR = NUM.SUBR.NAMES
      END
      RETURN

*
*
* PROCESS FIELD PREFIX
*  THE ACTUAL PROCESSING OF THE PREFIX IS DONE WHEN THE FIELD NAME
*  IS ENCOUNTERED
*
PROCESS.PREFIX: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.PREFIX'
      CRT 'WHICH.PREFIX: ':WHICH.PREFIX
      END
      PHRASE.USED = ORIGINAL.ITEM
      ACTIVE.PREFIX = WHICH.PREFIX
      GOSUB GET.NEXT.ITEM
      RETURN



*
* PROCESS @ VARIABLE
* TREAT THE AT VARIABLE AS THOUGH IT WERE A LITERAL
* ACTUAL VALUE WILL BE ASSIGNED LATER
*
PROCESS.AT.VARIABLE: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.AT.VARIABLE'
      CRT 'AT.VARIABLE: ':ITEM
      END
      DLMAIN.NUM.LITERAL.VALUES += 1
      DLMAIN.LITERAL.VALUE.LIST<DLMAIN.NUM.LITERAL.VALUES> = ITEM
      DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC) += 1
      CUR.OUT.FIELD.CTR = DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)
      DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = 'AT.VARIABLE ':ITEM.QUOTED:ITEM:ITEM.QUOTED
      DL.OUTR.TYPE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = 'AT.VARIABLE'
      DL.OUTR.CTR.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = DLMAIN.NUM.LITERAL.VALUES
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS.QUALIFIER
*
PROCESS.QUALIFIER: 
      DEBUG3OR4
      CRT 'GOSUB PROCESS.QUALIFIER'
      CRT 'WHICH.QUALIFIER ':WHICH.QUALIFIER
      END
      X.CURRENT.TYPE = WHICH.QUALIFIER
      BEGIN CASE
         CASE WHICH.QUALIFIER = 'LINE'
            GOSUB PROCESS.QUALIFIER.LINE
         CASE WHICH.QUALIFIER = 'LENGTH'
            GOSUB PROCESS.QUALIFIER.LENGTH
         CASE WHICH.QUALIFIER = 'BEG.COL'
            GOSUB PROCESS.QUALIFIER.BEG.COL
         CASE WHICH.QUALIFIER = 'END.COL'
            GOSUB PROCESS.QUALIFIER.END.COL
         CASE WHICH.QUALIFIER = 'COLUMNS'
            GOSUB PROCESS.QUALIFIER.COLUMNS
         CASE WHICH.QUALIFIER = 'FMT'
            GOSUB PROCESS.QUALIFIER.FMT
         CASE WHICH.QUALIFIER = 'COL.HDG'
            CRT 'WHICH.QUALIFIER ':WHICH.QUALIFIER
            CRT 'DLMAIN.FORMAT ':DLMAIN.FORMAT
            IF DLMAIN.FORMAT = 'XML' THEN
               GOSUB PROCESS.QUALIFIER.XML.NAME
            END ELSE
               GOSUB PROCESS.QUALIFIER.COL.HDG
            END
         CASE WHICH.QUALIFIER = 'CONV'
            GOSUB PROCESS.QUALIFIER.CONV
         CASE WHICH.QUALIFIER = 'HTML.START'
            GOSUB PROCESS.QUALIFIER.HTML.START
         CASE WHICH.QUALIFIER = 'HTML.END'
            GOSUB PROCESS.QUALIFIER.HTML.END
         CASE WHICH.QUALIFIER = 'HTML.CELL'
            GOSUB PROCESS.QUALIFIER.HTML.CELL
         CASE WHICH.QUALIFIER = 'HTML.ROW'
            GOSUB PROCESS.QUALIFIER.HTML.ROW
         CASE WHICH.QUALIFIER = 'XML.ATTRIBUTE'
            GOSUB PROCESS.QUALIFIER.XML.ATTRIBUTE
         CASE WHICH.QUALIFIER = 'XML.GROUP.NAME'
            GOSUB PROCESS.QUALIFIER.XML.GROUP.NAME
         CASE WHICH.QUALIFIER = 'XML.ASSOC.NAME'
            GOSUB PROCESS.QUALIFIER.XML.ASSOC.NAME
         CASE WHICH.QUALIFIER = 'XML.SUBASSOC.NAME'
            GOSUB PROCESS.QUALIFIER.XML.SUBASSOC.NAME
         CASE WHICH.QUALIFIER = 'XML.NAME'
            GOSUB PROCESS.QUALIFIER.XML.NAME
         CASE WHICH.QUALIFIER = 'NUM.VALUES'
            GOSUB PROCESS.QUALIFIER.NUM.VALUES
         CASE WHICH.QUALIFIER = 'NUM.SUBVALUES'
            GOSUB PROCESS.QUALIFIER.NUM.SUBVALUES
         CASE WHICH.QUALIFIER = 'MV.ORIENTATION'
            GOSUB PROCESS.QUALIFIER.MV.ORIENTATION
         CASE WHICH.QUALIFIER = 'VALUE.SEPARATOR'
            GOSUB PROCESS.QUALIFIER.VALUE.SEPARATOR
         CASE WHICH.QUALIFIER = 'SUBVALUE.SEPARATOR'
            GOSUB PROCESS.QUALIFIER.SUBVALUE.SEPARATOR
         CASE WHICH.QUALIFIER = 'MULTI.VALUE'
            GOSUB PROCESS.QUALIFIER.MULTI.VALUE
         CASE WHICH.QUALIFIER = 'SINGLE.VALUE'
            GOSUB PROCESS.QUALIFIER.SINGLE.VALUE
         CASE WHICH.QUALIFIER = 'FIELD.NAMES'
            GOSUB PROCESS.QUALIFIER.FIELD.NAMES
         CASE WHICH.QUALIFIER = 'FIELD.LABELS'
            GOSUB PROCESS.QUALIFIER.FIELD.LABELS
         CASE WHICH.QUALIFIER = 'DEFAULT.VALUE'
            GOSUB PROCESS.QUALIFIER.DEFAULT.VALUE
         CASE WHICH.QUALIFIER = 'NO.NULLS'
            GOSUB PROCESS.QUALIFIER.NO.NULLS
      END CASE
      RETURN


*
*
* PROCESS FIELD QUALIFIER "LINE"
*
PROCESS.QUALIFIER.LINE: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.LINE '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            LINE.VALUE = ITEM
            VALID.VALUE = TRUE
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.LINE.VALUE = DL.OUTR.LINE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.LINE.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.LINE.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               DL.OUTR.LINE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = LINE.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "LENGTH"
*  OR ALTERNATELY, A # FOLLOWING A FIELD WITHOUT A QUALIFIER
*
PROCESS.QUALIFIER.LENGTH: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.LENGTH '
      END
      PHRASE.USED = ORIGINAL.ITEM
      IF ITEM = 'LENGTH' THEN
         LOOKUP.FIELD.NAME = FALSE
         GOSUB GET.NEXT.ITEM
      END
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            LENGTH.VALUE = ITEM
            VALID.VALUE = TRUE
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:''
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.LENGTH.VALUE = DL.OUTR.LENGTH.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.LENGTH.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.LENGTH.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               DL.OUTR.LENGTH.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = LENGTH.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "BEG.COL"
*
PROCESS.QUALIFIER.BEG.COL: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.BEG.COL '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            BEG.COL.VALUE = ITEM
            VALID.VALUE = TRUE
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:''
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.BEG.COL.VALUE = DL.OUTR.BEG.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.BEG.COL.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.BEG.COL.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               DL.OUTR.BEG.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = BEG.COL.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "END.COL"
*
PROCESS.QUALIFIER.END.COL: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.END.COL '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            END.COL.VALUE = ITEM
            VALID.VALUE = TRUE
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:''
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.END.COL.VALUE = DL.OUTR.END.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.END.COL.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.END.COL.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               DL.OUTR.END.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = END.COL.VALUE
         END CASE
      END
      RETURN

*
*
* PROCESS FIELD QUALIFIER "COLUMNS"
*
PROCESS.QUALIFIER.COLUMNS: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.COLUMNS '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         IF NUM(ITEM) AND ITEM > 0 THEN
            BEG.COL.VALUE = ITEM
* LOOK FOR END COL
            LOOKUP.FIELD.NAME = FALSE
            GOSUB GET.NEXT.ITEM
            IF ITEM.TYPE = '' THEN
               IF NUM(ITEM) AND ITEM > 0 THEN
                  END.COL.VALUE = ITEM
                  VALID.VALUE = TRUE
               END ELSE
                  TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
               END
            END ELSE
               TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:' ':BEG.COL.VALUE
            END
*
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:''
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.BEG.COL.VALUE = DL.OUTR.BEG.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         OLD.END.COL.VALUE = DL.OUTR.END.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.BEG.COL.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a BEG.COL qualifier "BEG.COL ':BEG.COL.VALUE:'"'
            CASE OLD.END.COL.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a END.COL qualifier "END.COL ':END.COL.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               DL.OUTR.BEG.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = BEG.COL.VALUE
               DL.OUTR.END.COL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = END.COL.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "FMT"
*
PROCESS.QUALIFIER.FMT: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.FMT '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         TEST.FMT = FMT('',ITEM)
         IF STATUS() = 0 THEN
            IF ITEM = '' THEN
               FMT.VALUE = NULL.CODE
            END ELSE
               FMT.VALUE = ITEM
            END
            VALID.VALUE = TRUE
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:''
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.FMT.VALUE = DL.OUTR.FMT.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.FMT.VALUE # '' AND DL.OUTR.TYPE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> # 'LITERAL'
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.FMT.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               DL.OUTR.FMT.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = FMT.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "CONV"
*
PROCESS.QUALIFIER.CONV: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.CONV '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         TEST.CONV.1 = OCONV('',ITEM)
         STATUS.1 = STATUS()
         TEST.CONV.2 = OCONV('1',ITEM)
         STATUS.2 = STATUS()
         IF STATUS.1 = 0 OR STATUS.2 = 0 THEN
            IF ITEM = '' THEN
               CONV.VALUE = NULL.CODE
            END ELSE
               CONV.VALUE = ITEM
            END
            VALID.VALUE = TRUE
         END ELSE
            TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER:''
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.CONV.VALUE = DL.OUTR.CONV.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.CONV.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.CONV.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               DL.OUTR.CONV.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = CONV.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "COL.HDG"
*
PROCESS.QUALIFIER.COL.HDG: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.COL.HDG '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      BEGIN CASE
         CASE ITEM = ''
            DLMAIN.ERRMSG<-1> = 'Expecting column heading, found nothing.'
         CASE ITEM.TYPE # ''
            DLMAIN.ERRMSG<-1> = 'Expecting column heading, found "':ITEM:'"'
         CASE 1
            COL.HDG.VALUE = ITEM
            VALID.VALUE = TRUE
            IF CUR.OUT.FIELD.CTR < 1 THEN
               DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
            END ELSE
               OLD.COL.HDG.VALUE = DL.OUTR.COL.HDG.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
               FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
               IF OLD.COL.HDG.VALUE = '' THEN
                  DL.OUTR.COL.HDG.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = COL.HDG.VALUE
               END ELSE
                  DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.COL.HDG.VALUE:'"'
               END
            END
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "HTML.START"
*
PROCESS.QUALIFIER.HTML.START: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.HTML.START '
      END
      HTML.START.VALUE = ''
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.HTML.START.VALUE = DL.OUTR.HTML.START.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.HTML.START.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.HTML.START.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               HTML.START.VALUE = X.LIT.DICT.EVAL
               DL.OUTR.HTML.START.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = HTML.START.VALUE
         END CASE
      END
      GOSUB GET.NEXT.ITEM
      RETURN



*
*
* PROCESS FIELD QUALIFIER "HTML.END"
*
PROCESS.QUALIFIER.HTML.END: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.HTML.END '
      END
      HTML.END.VALUE = ''
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.HTML.END.VALUE = DL.OUTR.HTML.END.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.HTML.END.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.HTML.END.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               HTML.END.VALUE = X.LIT.DICT.EVAL
               DL.OUTR.HTML.END.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = HTML.END.VALUE
         END CASE
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "HTML.CELL"
*
PROCESS.QUALIFIER.HTML.CELL: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.HTML.CELL '
      END
      HTML.CELL.VALUE = ''
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.HTML.CELL.VALUE = DL.OUTR.HTML.CELL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.HTML.CELL.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.HTML.CELL.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               HTML.CELL.VALUE = X.LIT.DICT.EVAL
               DL.OUTR.HTML.CELL.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = HTML.CELL.VALUE
         END CASE
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "HTML.ROW"
*
PROCESS.QUALIFIER.HTML.ROW: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.HTML.ROW '
      END
      HTML.ROW.VALUE = ''
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = TRUE
      GOSUB GET.NEXT.ITEM
      GOSUB CHECK.LIT.DICT.EVAL
      IF CUR.OUT.FIELD.CTR < 1 AND NOT(CUR.OUT.REC = DLMAIN.HEADING.OUT.REC) THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.HTML.ROW.VALUE = DL.OUTR.HTML.ROW.LIST(CUR.OUT.REC)
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.HTML.ROW.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.HTML.ROW.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               HTML.ROW.VALUE = X.LIT.DICT.EVAL
               DL.OUTR.HTML.ROW.LIST(CUR.OUT.REC) = HTML.ROW.VALUE
         END CASE
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "XML.ATTRIBUTE"
*
PROCESS.QUALIFIER.XML.ATTRIBUTE: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.XML.ATTRIBUTE '
      END
      PHRASE.USED = ORIGINAL.ITEM
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         IF DL.OUTR.SM.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = 'M' THEN
            DLMAIN.ERRMSG<-1> = PHRASE.USED:' cannot be used with multi-valued fields.'
         END ELSE
            DL.OUTR.XML.ATTRIBUTE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = TRUE
         END
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "XML.GROUP.NAME"
*
PROCESS.QUALIFIER.XML.GROUP.NAME: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.XML.GROUP.NAME '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      BEGIN CASE
         CASE ITEM = ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML group name, found nothing.'
         CASE ITEM.TYPE # ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML group name, found "':ITEM:'"'
         CASE 1
            X.ITEM.OUT = ''
            X.DO.LOWER.CASE = FALSE
            CALL DLXMLELEM(X.ITEM.OUT,ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML group name "':ITEM:'" does not generate a valid XML name.'
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               XML.GROUP.NAME.VALUE = X.ITEM.OUT
               VALID.VALUE = TRUE
               IF CUR.OUT.FIELD.CTR < 1 THEN
                  DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
               END ELSE
                  OLD.XML.GROUP.NAME.VALUE = DL.OUTR.XML.GROUP.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  IF OLD.XML.GROUP.NAME.VALUE = '' THEN
                     DL.OUTR.XML.GROUP.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = XML.GROUP.NAME.VALUE
                  END ELSE
                     DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.XML.GROUP.NAME.VALUE:'"'
                  END
               END
            END
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "XML.ASSOC.NAME"
*
PROCESS.QUALIFIER.XML.ASSOC.NAME: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.XML.ASSOC.NAME '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      BEGIN CASE
         CASE ITEM = ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML association name, found nothing.'
         CASE ITEM.TYPE # ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML association name, found "':ITEM:'"'
         CASE 1
            X.ITEM.OUT = ''
            X.DO.LOWER.CASE = FALSE
            CALL DLXMLELEM(X.ITEM.OUT,ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML association name "':ITEM:'" does not generate a valid XML name.'
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               XML.ASSOC.NAME.VALUE = X.ITEM.OUT
               VALID.VALUE = TRUE
               IF CUR.OUT.FIELD.CTR < 1 THEN
                  DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
               END ELSE
                  OLD.XML.ASSOC.NAME.VALUE = DL.OUTR.XML.ASSOC.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  IF OLD.XML.ASSOC.NAME.VALUE = '' THEN
                     DL.OUTR.XML.ASSOC.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = XML.ASSOC.NAME.VALUE
                  END ELSE
                     DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.XML.ASSOC.NAME.VALUE:'"'
                  END
               END
            END
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "XML.SUBASSOC.NAME"
*
PROCESS.QUALIFIER.XML.SUBASSOC.NAME: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.XML.SUBASSOC.NAME '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      BEGIN CASE
         CASE ITEM = ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML subassociation name, found nothing.'
         CASE ITEM.TYPE # ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML subassociation name, found "':ITEM:'"'
         CASE 1
            X.ITEM.OUT = ''
            X.DO.LOWER.CASE = FALSE
            CALL DLXMLELEM(X.ITEM.OUT,ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML subassociation name "':ITEM:'" does not generate a valid XML name.'
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               XML.SUBASSOC.NAME.VALUE = X.ITEM.OUT
               VALID.VALUE = TRUE
               IF CUR.OUT.FIELD.CTR < 1 THEN
                  DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
               END ELSE
                  OLD.XML.SUBASSOC.NAME.VALUE = DL.OUTR.XML.SUBASSOC.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  IF OLD.XML.SUBASSOC.NAME.VALUE = '' THEN
                     DL.OUTR.XML.SUBASSOC.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = XML.SUBASSOC.NAME.VALUE
                  END ELSE
                     DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.XML.SUBASSOC.NAME.VALUE:'"'
                  END
               END
            END
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "XML.NAME"
*
PROCESS.QUALIFIER.XML.NAME: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.XML.NAME '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      BEGIN CASE
         CASE ITEM = ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML field name, found nothing.'
         CASE ITEM.TYPE # ''
            DLMAIN.ERRMSG<-1> = 'Expecting XML field name, found "':ITEM:'"'
         CASE 1
            X.ITEM.OUT = ''
            X.DO.LOWER.CASE = FALSE
            CALL DLXMLELEM(X.ITEM.OUT,ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML field name "':ITEM:'" does not generate a valid XML name.'
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               XML.NAME.VALUE = X.ITEM.OUT
               VALID.VALUE = TRUE
               IF CUR.OUT.FIELD.CTR < 1 THEN
                  DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
               END ELSE
                  OLD.XML.NAME.VALUE = DL.OUTR.XML.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
                  IF OLD.XML.NAME.VALUE = '' THEN
                     DL.OUTR.XML.NAME.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = XML.NAME.VALUE
                  END ELSE
                     DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.XML.NAME.VALUE:'"'
                  END
               END
            END
      END CASE
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "NUM.VALUES"
*
PROCESS.QUALIFIER.NUM.VALUES: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.NUM.VALUES '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' OR (ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.ALL) THEN
         BEGIN CASE
            CASE NUM(ITEM) AND ITEM > 0
               NUM.VALUES.VALUE = ITEM
               VALID.VALUE = TRUE
            CASE ITEM.KEYWORD = KEYWORD.ALL
               NUM.VALUES.VALUE = ITEM
               VALID.VALUE = TRUE
            CASE 1
               TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.NUM.VALUES.VALUE = DL.OUTR.NUM.VALUES.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.NUM.VALUES.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.NUM.VALUES.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               DL.OUTR.NUM.VALUES.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = NUM.VALUES.VALUE
               ITEM.USED.LIST<ITEM.CTR> = TRUE
         END CASE
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "NUM.SUBVALUES"
*
PROCESS.QUALIFIER.NUM.SUBVALUES: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.NUM.SUBVALUES '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' OR (ITEM.TYPE = 'KEYWORD' AND ITEM.KEYWORD = KEYWORD.ALL) THEN
         BEGIN CASE
            CASE NUM(ITEM) AND ITEM > 0
               NUM.SUBVALUES.VALUE = ITEM
               VALID.VALUE = TRUE
            CASE ITEM.KEYWORD = KEYWORD.ALL
               NUM.SUBVALUES.VALUE = ITEM
               VALID.VALUE = TRUE
            CASE 1
               TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' is not a valid ':WHICH.QUALIFIER:' value'
         END CASE
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.NUM.SUBVALUES.VALUE = DL.OUTR.NUM.SUBVALUES.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.NUM.SUBVALUES.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.NUM.SUBVALUES.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               DL.OUTR.NUM.SUBVALUES.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = NUM.SUBVALUES.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS QUALIFIER "MV.ORIENTATION"
*
PROCESS.QUALIFIER.MV.ORIENTATION: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.MV.ORIENTATION '
      END
      TEMP.ERRMSG = 'The ':ORIGINAL.ITEM:' specified must be in this list: "':ORIENTATION.TYPE.LIST:'"'
      CONVERT @FM:@VM:@SM TO '   ' IN TEMP.ERRMSG
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' OR ITEM.TYPE = 'KEYWORD' THEN
         LOCATE ITEM IN ORIENTATION.TYPE.LIST<1> SETTING POS THEN
            MV.ORIENTATION.VALUE = ITEM
            PHRASE.USED := ' ':ITEM
            ITEM.TYPE = ''
            VALID.VALUE = TRUE
         END ELSE
            DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
         END
         GOSUB GET.NEXT.ITEM
      END ELSE
         TEMP.ERRMSG = ITEM.QUOTED:ITEM:ITEM.QUOTED:' was not expected after ':WHICH.QUALIFIER
      END
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.MV.ORIENTATION.VALUE = DL.OUTR.MV.ORIENTATION.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.MV.ORIENTATION.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.MV.ORIENTATION.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               DL.OUTR.MV.ORIENTATION.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = MV.ORIENTATION.VALUE
         END CASE
      END
      RETURN


*
*
* PROCESS QUALIFIER "VALUE.SEPARATOR"
*
PROCESS.QUALIFIER.VALUE.SEPARATOR: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.VALUE.SEPARATOR '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         VALUE.SEPARATOR.VALUE = ITEM
         PHRASE.USED := ' ':ITEM
         VALID.VALUE = TRUE
      END ELSE
         TEMP.ERRMSG = 'Expecting ':PHRASE.USED:', but found ':ITEM:'.'
      END
      IF VALID.VALUE = TRUE THEN
         IF CUR.OUT.FIELD.CTR < 1 THEN
            DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
         END ELSE
            OLD.VALUE.SEPARATOR.VALUE = DL.OUTR.VALUE.SEPARATOR.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
            FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
            BEGIN CASE
               CASE OLD.VALUE.SEPARATOR.VALUE # ''
                  DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.VALUE.SEPARATOR.VALUE:'"'
               CASE NOT(VALID.VALUE)
                  DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
               CASE 1
                  DL.OUTR.VALUE.SEPARATOR.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = VALUE.SEPARATOR.VALUE
                  DL.OUTR.VALUE.SEPARATOR.SET(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = TRUE
            END CASE
         END
         GOSUB GET.NEXT.ITEM
      END
      RETURN


*
*
* PROCESS QUALIFIER "SUBVALUE.SEPARATOR"
*
PROCESS.QUALIFIER.SUBVALUE.SEPARATOR: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.SUBVALUE.SEPARATOR '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM.TYPE = '' THEN
         SUBVALUE.SEPARATOR.VALUE = ITEM
         PHRASE.USED := ' ':ITEM
         VALID.VALUE = TRUE
      END ELSE
         TEMP.ERRMSG = 'Expecting ':PHRASE.USED:', but found ':ITEM:'.'
      END
      IF VALID.VALUE = TRUE THEN
         IF CUR.OUT.FIELD.CTR < 1 THEN
            DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
         END ELSE
            OLD.SUBVALUE.SEPARATOR.VALUE = DL.OUTR.SUBVALUE.SEPARATOR.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
            FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
            BEGIN CASE
               CASE OLD.SUBVALUE.SEPARATOR.VALUE # ''
                  DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.SUBVALUE.SEPARATOR.VALUE:'"'
               CASE NOT(VALID.VALUE)
                  DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
               CASE 1
                  DL.OUTR.SUBVALUE.SEPARATOR.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = SUBVALUE.SEPARATOR.VALUE
                  DL.OUTR.SUBVALUE.SEPARATOR.SET(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = TRUE
            END CASE
         END
         GOSUB GET.NEXT.ITEM
      END
      RETURN


*
*
* PROCESS FIELD QUALIFIER "SINGLE.VALUE"
*
PROCESS.QUALIFIER.SINGLE.VALUE: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.SINGLE.VALUE '
      END
      PHRASE.USED = ORIGINAL.ITEM
      SM.VALUE = 'S'
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.SM.VALUE = DL.OUTR.SM.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         IF OLD.SM.VALUE # '' THEN
            DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.SM.VALUE:'"'
         END ELSE
            DL.OUTR.SM.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = SM.VALUE
         END
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD QUALIFIER "MULTI.VALUE"
*
PROCESS.QUALIFIER.MULTI.VALUE: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.MULTI.VALUE '
      END
      PHRASE.USED = ORIGINAL.ITEM
      SM.VALUE = 'M'
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.SM.VALUE = DL.OUTR.SM.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         IF OLD.SM.VALUE # '' THEN
            DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.SM.VALUE:'"'
         END ELSE
            DL.OUTR.SM.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = SM.VALUE
         END
      END
      GOSUB GET.NEXT.ITEM
      RETURN

*
* PROCESS FIELD QUALIFIER "FIELD.NAMES"
*
PROCESS.QUALIFIER.FIELD.NAMES: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.FIELD.NAMES '
      END
      PHRASE.USED = ORIGINAL.ITEM
      IF NOT(DLMAIN.HEADING.OUT.REC) THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow the HEADING keyword.'
      END ELSE
         HEADING.OUT.REC.USE.FIELD.NAMES = TRUE
      END
      GOSUB GET.NEXT.ITEM
      RETURN



*
* PROCESS FIELD QUALIFIER "FIELD.LABELS"
*
PROCESS.QUALIFIER.FIELD.LABELS: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.FIELD.LABELS '
      END
      PHRASE.USED = ORIGINAL.ITEM
      IF NOT(DLMAIN.HEADING.OUT.REC) THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow the HEADING keyword.'
      END ELSE
         HEADING.OUT.REC.USE.FIELD.LABELS = TRUE
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
* PROCESS FIELD QUALIFIER "DEFAULT.VALUE"
*
PROCESS.QUALIFIER.DEFAULT.VALUE: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.DEFAULT.VALUE '
      END
      PHRASE.USED = ORIGINAL.ITEM
      LOOKUP.FIELD.NAME = FALSE
      GOSUB GET.NEXT.ITEM
      VALID.VALUE = FALSE
      IF ITEM = '' OR ITEM.TYPE = 'KEYWORD' OR ITEMS.DONE THEN
         TEMP.ERRMSG = WHICH.QUALIFIER:' requires a value to be specified.'
      END ELSE
         DEFAULT.VALUE.VALUE = ITEM
         VALID.VALUE = TRUE
      END
      GOSUB GET.NEXT.ITEM
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         OLD.DEFAULT.VALUE.VALUE = DL.OUTR.DEFAULT.VALUE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         FIELD.NAME = DL.OUTR.FIELD.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR>
         BEGIN CASE
            CASE OLD.DEFAULT.VALUE.VALUE # ''
               DLMAIN.ERRMSG<-1> = FIELD.NAME:' already has a ':WHICH.QUALIFIER:' qualifier "':WHICH.QUALIFIER:' ':OLD.DEFAULT.VALUE.VALUE:'"'
            CASE NOT(VALID.VALUE)
               DLMAIN.ERRMSG<-1> = TEMP.ERRMSG
            CASE 1
               DL.OUTR.DEFAULT.VALUE.LIST(CUR.OUT.REC)<CUR.OUT.FIELD.CTR> = DEFAULT.VALUE.VALUE
         END CASE
      END
      RETURN


*
*
PROCESS.QUALIFIER.NO.NULLS: 
      DEBUG4
      CRT 'GOSUB PROCESS.QUALIFIER.NO.NULLS '
      END
      PHRASE.USED = ORIGINAL.ITEM
      IF CUR.OUT.FIELD.CTR < 1 THEN
         DLMAIN.ERRMSG<-1> = PHRASE.USED:' must follow a field name to be downloaded'
      END ELSE
         FOR WHICH.BREAK.FIELD = 1 TO DLMAIN.NUM.BREAK.FIELDS
            DATA.INCLUDE.NULLS(WHICH.BREAK.FIELD) = FALSE
         NEXT WHICH.BREAK.FIELD
      END
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS.FIELD
*
PROCESS.FIELD: 
      DEBUG4
      CRT 'GOSUB PROCESS.FIELD '
      CRT 'CUR.OUT.REC: ':CUR.OUT.REC
      END
      DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC) += 1
      IF ACTIVE.PREFIX = 'BREAK.SUP' THEN
         DL.OUTR.TYPE.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = 'SUP'
      END ELSE
         DL.OUTR.TYPE.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = 'FIELD'
      END
      DL.OUTR.FIELD.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = ITEM
      DICT.FIELD.NAME = ITEM
      DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
      GOSUB ADD.DICT.REC
      IF ACTIVE.PREFIX THEN
         DL.OUTR.PREFIX.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = ACTIVE.PREFIX
         GOSUB PROCESS.FIELD.PREFIX
      END
      DL.OUTR.CTR.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = WHICH.DICT.REC.CTR
      IF X.FILE.NUM.VALUES(FILE.NUM) THEN
         DL.OUTR.NUM.VALUES.LIST(CUR.OUT.REC)<DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)> = X.FILE.NUM.VALUES(FILE.NUM)
      END
      CUR.OUT.FIELD.CTR = DL.OUTR.NUM.OUT.FIELDS(CUR.OUT.REC)
      GOSUB GET.NEXT.ITEM
      RETURN


*
*
* PROCESS FIELD PREFIX
*
PROCESS.FIELD.PREFIX: 
      DEBUG4
      CRT 'GOSUB PROCESS.FIELD.PREFIX '
      END
      BEGIN CASE
         CASE ACTIVE.PREFIX = 'BREAK.ON' OR ACTIVE.PREFIX = 'BREAK.SUP'
            GOSUB PROCESS.FIELD.PREFIX.BREAK.ON
         CASE ACTIVE.PREFIX = 'TOTAL'
            GOSUB PROCESS.FIELD.PREFIX.TOTAL
         CASE ACTIVE.PREFIX = 'AVERAGE'
            GOSUB PROCESS.FIELD.PREFIX.AVERAGE
         CASE ACTIVE.PREFIX = 'MIN'
            GOSUB PROCESS.FIELD.PREFIX.MIN
         CASE ACTIVE.PREFIX = 'MAX'
            GOSUB PROCESS.FIELD.PREFIX.MAX
      END CASE
      RETURN


*
*
* PROCESS FIELD PREFIX BREAK.ON
*  MARK THE FIRST BREAK FIELD AS #2 (BREAK #1 IS THE FINAL BREAK)
*
PROCESS.FIELD.PREFIX.BREAK.ON: 
      DEBUG4
      CRT 'GOSUB PROCESS.FIELD.PREFIX.BREAK.ON '
      END
      IF DLMAIN.NUM.BREAK.FIELDS = 0 THEN
         DLMAIN.NUM.BREAK.FIELDS += 1
         DLMAIN.BREAK.DICT.CTR.LIST<DLMAIN.NUM.BREAK.FIELDS> = 'ALL'
      END
      DLMAIN.NUM.BREAK.FIELDS += 1
      DLMAIN.BREAK.DICT.CTR.LIST<DLMAIN.NUM.BREAK.FIELDS> = WHICH.DICT.REC.CTR
      RETURN


*
*
* PROCESS FIELD PREFIX TOTAL
*
PROCESS.FIELD.PREFIX.TOTAL: 
      DEBUG4
      CRT 'GOSUB PROCESS.FIELD.PREFIX.TOTAL '
      END
      DL.DATA.DICT.KEEP.TOTAL(WHICH.DICT.REC.CTR) = TRUE
      RETURN


*
*
* PROCESS FIELD PREFIX AVERAGE
*
PROCESS.FIELD.PREFIX.AVERAGE: 
      DEBUG4
      CRT 'GOSUB PROCESS.FIELD.PREFIX.AVERAGE '
      END
      DICT.KEEP.AVERAGE(WHICH.DICT.REC.CTR) = TRUE
      RETURN


*
*
* PROCESS FIELD PREFIX MIN
*
PROCESS.FIELD.PREFIX.MIN: 
      DEBUG4
      CRT 'GOSUB PROCESS.FIELD.PREFIX.MIN '
      END
      DICT.KEEP.MIN(WHICH.DICT.REC.CTR) = TRUE
      RETURN


*
*
* PROCESS FIELD PREFIX MAX
*
PROCESS.FIELD.PREFIX.MAX: 
      DEBUG4
      CRT 'GOSUB PROCESS.FIELD.PREFIX.MAX '
      END
      DICT.KEEP.MAX(WHICH.DICT.REC.CTR) = TRUE
      RETURN


*
*
* GET NEXT ITEM
*
GET.NEXT.ITEM: 
      DEBUG3OR4
      CRT 'GOSUB GET.NEXT.ITEM'
      END
      ITEM.CTR += 1
      LOOP
         ITEM.EXPANDED = FALSE
         ITEM = ITEM.LIST<ITEM.CTR>
         ORIGINAL.ITEM = ITEM
         ITEM.QUOTED = ITEM.QUOTED.LIST<ITEM.CTR>
         ITEM.USED = ITEM.USED.LIST<ITEM.CTR>
         IF ITEM.CTR > NUM.ITEMS THEN
            ITEMS.DONE = TRUE
            ITEM = '** End of line **'
            ITEM.TYPE = 'END.OF.ITEMS'
         END ELSE
            GOSUB DETERMINE.ITEM.TYPE
         END
      UNTIL NOT(ITEM.EXPANDED)
      REPEAT
      DEBUG3OR4
      CRT 'ITEM: ':ITEM
      CRT 'ITEM.TYPE: ':ITEM.TYPE
      END
      RETURN


*
*
* DETERMINE ITEM TYPE
*   THE VARIABLE 'LOOKUP.FIELD.NAME' IS USED TO DECIDE IF THE
*   DICTIONARY & VOC SHOULD BE READ.  IT IS INITIALLY SET TO TRUE,
*   AND RESET TO TRUE AT THE END OF THIS SUBROUTINE.
*   IF A FIELD NAME IS NOT ALLOWED (EG. AFTER AN OPTION SUCH AS
*   NUM.VALUES, AS IN 'NUM.VALUES ALL') THEN BEFORE THE 'GET.NEXT.ITEM'
*   OR 'DETERMINE.ITEM.TYPE' SUBROUTINES ARE CALLED, THE FLAG
*   SHOULD BE SET TO FALSE.
*
DETERMINE.ITEM.TYPE: 
      DEBUG4
      CRT 'GOSUB DETERMINE.ITEM.TYPE'
      END
      PASSED.LOOKUP.FIELD.NAME = LOOKUP.FIELD.NAME
      LOOKUP.FIELD.NAME = TRUE
      ITEM.TYPE = ''
      ITEM.KEYWORD = ''
      ITEM.FIELD.FILE.NUM = ''
      IF ITEM = '' THEN
         RETURN
      END
      IF ITEM.QUOTED THEN
         RETURN
      END
      GOSUB CHECK.FOR.SYNONYMS
      IF ITEM.TYPE = '' THEN
         GOSUB CHECK.VOC.FOR.NONFIELD
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN PREPROCESS.LIST<1> SETTING PREPROCESS.POS THEN
            WHICH.PREPROCESS = ITEM
            ITEM.TYPE = 'PREPROCESS'
            ITEM.KEYWORD = PREPROCESS.KEYWORD.LIST<PREPROCESS.POS>
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN OPTION.LIST<1> SETTING OPTION.POS THEN
            WHICH.OPTION = ITEM
            ITEM.TYPE = 'OPTION'
            ITEM.KEYWORD = OPTION.KEYWORD.LIST<OPTION.POS>
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN PREFIX.LIST<1> SETTING PREFIX.POS THEN
            WHICH.PREFIX = ITEM
            ITEM.TYPE = 'PREFIX'
            ITEM.KEYWORD = PREFIX.KEYWORD.LIST<PREFIX.POS>
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN AT.VARIABLE.LIST<1> SETTING AT.VARIABLE.POS THEN
            WHICH.AT.VARIABLE = ITEM
            ITEM.TYPE = 'AT.VARIABLE'
            ITEM.KEYWORD = ITEM
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN QUALIFIER.LIST<1> SETTING QUALIFIER.POS THEN
            WHICH.QUALIFIER = ITEM
            ITEM.TYPE = 'QUALIFIER'
            ITEM.KEYWORD = QUALIFIER.KEYWORD.LIST<QUALIFIER.POS>
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN MISC.FIELD.LIST<1> SETTING MISC.FIELD.POS THEN
            WHICH.MISC.FIELD = ITEM
            ITEM.TYPE = 'MISC.FIELD'
            ITEM.KEYWORD = MISC.FIELD.KEYWORD.LIST<MISC.FIELD.POS>
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN OPERATOR.LIST<1,1> SETTING OPERATOR.POS THEN
            WHICH.OPERATOR = OPERATOR.LIST<2,OPERATOR.POS>
            ITEM.TYPE = 'OPERATOR'
            ITEM.KEYWORD = OPERATOR.KEYWORD.LIST<2,OPERATOR.POS>
         END
      END
      IF ITEM.TYPE = '' THEN
         LOCATE ITEM IN MISC.KEYWORD.LIST<1> SETTING MISC.KEYWORD.POS THEN
            WHICH.MISC.KEYWORD = ITEM
            ITEM.TYPE = 'KEYWORD'
            ITEM.KEYWORD = MISC.KEYWORD.KEYWORD.LIST<MISC.KEYWORD.POS>
         END
      END
      IF PASSED.LOOKUP.FIELD.NAME THEN
         IF ITEM.TYPE = '' THEN
            GOSUB CHECK.DICT.FOR.ITEM
         END
         IF ITEM.TYPE = '' THEN
            GOSUB CHECK.VOC.FOR.FIELD
         END
      END
      RETURN


*
*
* CHECK DICT FOR ITEM
*
CHECK.DICT.FOR.ITEM: 
      ITEM.FIELD.TYPE = ''
      IF ITEM.QUOTED THEN
         RETURN
      END
      IF NOT(PRIMARY.DICT.OPENED) THEN
         RETURN
      END
      TEMP.POS = INDEX(ITEM, DL.DATA.SECONDARY.FIELD.FLAG, 1)
      IF TEMP.POS = 0 THEN
         FILE.NAME = ''
         FILE.NUM = PRIMARY.FILE.NUM
         FIELD.NAME = ITEM
      END ELSE
         FILE.NAME = ITEM[1,TEMP.POS-1]
         FIELD.NAME = ITEM[TEMP.POS+LEN.SECONDARY.FIELD.FLAG,999]
         LOCATE FILE.NAME IN DLMAIN.INFO.FILE.ALIAS.LIST<1> SETTING FILE.NUM ELSE
            DLMAIN.ERRMSG<-1> = '"':ITEM:'" does not include a valid file name or alias name'
            DLMAIN.FATAL.ERROR = TRUE
            FILE.NUM = ''
         END
      END
      IF FILE.NUM THEN
         IF FIELD.NAME = '@RECORD' THEN
            ITEM.TYPE = 'FIELD'
            ITEM.FIELD.FILE.NUM = FILE.NUM
            GOSUB PROCESS.AT.RECORD
            IF XL.USE.DICT NE '' THEN
               CONVERT @VM TO ' ' IN XL.USE.DICT
               PHRASE.TO.EXPAND = XL.USE.DICT
               GOSUB EXPAND.PHRASE
            END
         END ELSE
            READ DICT.REC FROM F.DICT.FILE(FILE.NUM), FIELD.NAME THEN
               ITEM.TYPE = 'FIELD'
               ITEM.FIELD.FILE.NUM = FILE.NUM
               IF DICT.REC<1>[1,2] = 'PH' THEN
                  PHRASE.TO.EXPAND = DICT.REC<2>
                  GOSUB EXPAND.PHRASE
               END ELSE
                  ITEM.FIELD.TYPE = DICT.REC<1>[1,1]
                  ITEM.FIELD.TYPE = OCONV(ITEM.FIELD.TYPE,'MCU')
                  IF ITEM.FIELD.TYPE = 'V' THEN
                     ITEM.FIELD.TYPE = 'I'
                  END
               END
            END
         END
      END
      RETURN


PROCESS.AT.RECORD: 
      IF X.PRIMARY.LIST.NAME = '' THEN
         GOSUB SAVE.PRIMARY.LIST
      END
      X.COMMAND = 'SELECT DICT ':DLMAIN.INFO.FILE.NAME.PART.2(ITEM.FIELD.FILE.NUM)
      X.COMMAND := ' WITH TYPE = "D"'
      EXECUTE X.COMMAND CAPTURING X.OUTPUT
      READLIST XL.RECORD.DICT ELSE
         XL.RECORD.DICT = ''
      END
      CONVERT @IM:@FM TO @VM:@VM IN XL.RECORD.DICT
      XL.USE.DICT = ''
      XL.USE.FIELD.NUMBER = ''
      IF XL.RECORD.DICT = '' THEN
         RETURN
      END
      NUM.XL.RECORD.DICT = DCOUNT(XL.RECORD.DICT,@VM)
      FOR WHICH.XL.RECORD.DICT = 1 TO NUM.XL.RECORD.DICT
         X.RECORD.DICT = XL.RECORD.DICT<1,WHICH.XL.RECORD.DICT>
         READ R.RECORD.DICT FROM F.DICT.FILE(ITEM.FIELD.FILE.NUM), X.RECORD.DICT THEN
            X.LOC = R.RECORD.DICT<2>
            X.LOC = FMT(X.LOC,'5"0"R')
            LOCATE X.LOC IN XL.USE.FIELD.NUMBER<1,1> BY 'AR' SETTING X.POS ELSE
               INS X.LOC BEFORE XL.USE.FIELD.NUMBER<1,X.POS>
               X.TEMP = X.RECORD.DICT
               IF FILE.NUM NE PRIMARY.FILE.NUM THEN
                  X.TEMP = FILE.NAME:DL.DATA.SECONDARY.FIELD.FLAG:X.TEMP
               END
               INS X.TEMP BEFORE XL.USE.DICT<1,X.POS>
            END
         END
      NEXT WHICH.XL.RECORD.DICT
      RETURN


*
* EXPAND PHRASES FROM THE DICTIONARY OR VOC ON THE FLY AS THEY ARE
* ENCOUNTERED.  (THIS KEEPS THE PROCESSING FROM EXPANDING ITEMS
* THAT ARE KEYWORDS TO THE PROGRAM AS WELL AS PHRASES SOMEWHERE
* IN SITUATIONS WHERE IT SHOULD NOT BE CHECKING FOR FIELD NAMES, ETC.)
* EG.  DEFAULT NUM.VALUES ALL,  IF 'ALL' IS DEFINED AS A PHRASE IN THE
*      DICT, THEN THIS PHRASE USED TO CHOKE.
*
EXPAND.PHRASE: 
      CALL PARSECL(PHRASE.TO.EXPAND, PHRASE.LIST, PHRASE.QUOTED.LIST, NUM.PHRASE.ITEMS, OTHER.SEPARATORS)
      IF NUM.PHRASE.ITEMS < 1 THEN
         ITEM.TYPE = ''
         ITEM = ''
         ITEM.FIELD.TYPE = ''
         ITEM.FIELD.FILE.NUM = ''
         RETURN
      END
*
      ITEM.LIST.PART.1 = FIELD(ITEM.LIST,@FM,1,ITEM.CTR-1)
      ITEM.QUOTED.LIST.PART.1 = FIELD(ITEM.QUOTED.LIST,@FM,1,ITEM.CTR-1)
      ITEM.USED.LIST.PART.1 = FIELD(ITEM.USED.LIST,@FM,1,ITEM.CTR-1)
      ITEM.LIST.PART.2 = FIELD(ITEM.LIST,@FM,ITEM.CTR+1,NUM.ITEMS)
      ITEM.QUOTED.LIST.PART.2 = FIELD(ITEM.QUOTED.LIST,@FM,ITEM.CTR+1,NUM.ITEMS)
      ITEM.USED.LIST.PART.2 = FIELD(ITEM.USED.LIST,@FM,ITEM.CTR+1,NUM.ITEMS)
*
      ITEM.LIST = ITEM.LIST.PART.1
      ITEM.QUOTED.LIST = ITEM.QUOTED.LIST.PART.1
      ITEM.USED.LIST = ITEM.USED.LIST.PART.1
      ITEM.LIST<ITEM.CTR> = PHRASE.LIST
      ITEM.QUOTED.LIST<ITEM.CTR> = PHRASE.QUOTED.LIST
      ITEM.USED.LIST<ITEM.CTR> = ''
      ITEM.LIST<ITEM.CTR+NUM.PHRASE.ITEMS> = ITEM.LIST.PART.2
      ITEM.QUOTED.LIST<ITEM.CTR+NUM.PHRASE.ITEMS> = ITEM.QUOTED.LIST.PART.2
      ITEM.USED.LIST<ITEM.CTR+NUM.PHRASE.ITEMS> = ITEM.USED.LIST.PART.2
      NUM.ITEMS += NUM.PHRASE.ITEMS
      ITEM.EXPANDED = TRUE
      RETURN


*
*
* CHECK ITEM FOR NONFIELD
*
CHECK.VOC.FOR.NONFIELD: 
      DEBUG4
      CRT 'CHECK.VOC.FOR.NONFIELD with ITEM ':ITEM
      CRT 'ITEM.QUOTED is ':ITEM.QUOTED
      CRT 'LOOKUP.FILE.NAME is ':LOOKUP.FILE.NAME
      END
      PASSED.LOOKUP.FILE.NAME = LOOKUP.FILE.NAME
      LOOKUP.FILE.NAME = FALSE
      ITEM.TYPE = ''
      ITEM.KEYWORD = ''
      ITEM.FIELD.TYPE = ''
      IF ITEM.QUOTED THEN
         RETURN
      END
      IF PASSED.LOOKUP.FILE.NAME THEN
         TEMP.ITEM = FIELD(ITEM,OP.SYS.PATH.DELIM,1)
      END ELSE
         TEMP.ITEM = ITEM
      END
      DEBUG4
      CRT 'Reading VOC for ':TEMP.ITEM
      END
      READ VOC.REC FROM DLMAIN.F.VOC, TEMP.ITEM ELSE
         RETURN
      END
      DEBUG4
      CRT 'Found VOC item ':TEMP.ITEM
      CRT '001: ':VOC.REC<1>
      CRT '002: ':VOC.REC<2>
      CRT '003: ':VOC.REC<3>
      END
      IF TEMP.ITEM # ITEM THEN
         VOC.REC<2> := OP.SYS.PATH.DELIM:FIELD(ITEM,OP.SYS.PATH.DELIM,2,999)
         WRITE VOC.REC ON DLMAIN.F.VOC, ITEM
         DLMAIN.VOC.DELETE.LIST<1,-1> = ITEM
      END
      VOC.ITEM.TYPE = ''
      X.VOC.REC.FIELD.ONE = OCONV(VOC.REC<1>,'MCU')
      IF X.VOC.REC.FIELD.ONE[1,2] = 'LD' THEN
         X.VOC.REC.FIELD.ONE = 'DIR'
      END
      IF X.VOC.REC.FIELD.ONE[1,2] = 'LF' THEN
         X.VOC.REC.FIELD.ONE = 'F'
      END
      FOR NUM.CHARS=3 TO 1 STEP -1 UNTIL VOC.ITEM.TYPE # ''
         CHECK.TYPE = X.VOC.REC.FIELD.ONE[1,NUM.CHARS]
         LOCATE CHECK.TYPE IN DBMS.VOC.ITEM.TYPE.LIST<1> SETTING POS THEN
            VOC.ITEM.TYPE = CHECK.TYPE
         END
      NEXT NUM.CHARS
      VOC.KEYWORD = VOC.REC<2>
      BEGIN CASE
         CASE (VOC.ITEM.TYPE = 'F' OR VOC.ITEM.TYPE = 'DIR') AND PASSED.LOOKUP.FILE.NAME
            DEBUG4
            CRT 'Opening ':ITEM
         END
         OPEN '', ITEM TO F.TEST THEN
            DEBUG2
            CRT 'Open was successful.'
         END
         GOSUB OP.SYS.FILE.TYPE
         *UNIDATA               IF ITEM.TYPE = 'DIR' OR ITEM.TYPE = 'FILE' THEN
         *UNIDATA                  DLMAIN.OUTPUT.FILE.PATH.NAME = VOC.REC<2>
         *UNIDATA                  IF DLMAIN.OUTPUT.FILE.PATH.NAME[1,1] EQ '@' THEN
         *UNIDATA                     X.TEMP = GETENV(DLMAIN.OUTPUT.FILE.PATH.NAME[2,LEN(DLMAIN.OUTPUT.FILE.PATH.NAME)])
         *UNIDATA                     DEBUG4
         *UNIDATA                        CRT 'Checking for file specified by environment variable ':X.TEMP
         *UNIDATA                     END
         *UNIDATA                     IF X.TEMP NE '' THEN
         *UNIDATA                        DLMAIN.OUTPUT.FILE.PATH.NAME = X.TEMP
         *UNIDATA                     END
         *UNIDATA                  END
         *UNIDATA               END
         CLOSE F.TEST
      END ELSE
         DEBUG2
         CRT 'Open was not successful.'
      END
      END
      CASE VOC.ITEM.TYPE = 'K' AND VOC.KEYWORD # THROWAWAY.KEYWORD
         GOSUB CHECK.VOC.KEYWORD
      CASE VOC.ITEM.TYPE = 'X'
         LOCATE PROGRAM.NAME IN VOC.REC<2,1> SETTING POS THEN
            VOC.KEYWORD = VOC.REC<3,POS>
            GOSUB CHECK.VOC.KEYWORD
         END
      END CASE
      RETURN


*
*
* CHECK ITEM VOC TYPE
*
CHECK.VOC.FOR.FIELD: 
      ITEM.TYPE = ''
      ITEM.KEYWORD = ''
      ITEM.FIELD.TYPE = ''
      IF ITEM.QUOTED THEN
      RETURN
      END
      READ VOC.REC FROM DLMAIN.F.VOC, ITEM ELSE
         RETURN
      END
      VOC.ITEM.TYPE = ''
      X.VOC.REC.FIELD.ONE = OCONV(VOC.REC<1>,'MCU')
      IF X.VOC.REC.FIELD.ONE[1,2] = 'LD' THEN
         X.VOC.REC.FIELD.ONE = 'DIR'
      END
      IF X.VOC.REC.FIELD.ONE[1,2] = 'LF' THEN
         X.VOC.REC.FIELD.ONE = 'F'
      END
      FOR NUM.CHARS=3 TO 1 STEP -1 UNTIL VOC.ITEM.TYPE # ''
         CHECK.TYPE = X.VOC.REC.FIELD.ONE[1,NUM.CHARS]
         LOCATE CHECK.TYPE IN DBMS.VOC.ITEM.TYPE.LIST<1> SETTING POS THEN
            VOC.ITEM.TYPE = CHECK.TYPE
         END
      NEXT NUM.CHARS
      VOC.KEYWORD = VOC.REC<2>
      BEGIN CASE
         CASE VOC.ITEM.TYPE = 'I' OR VOC.ITEM.TYPE = 'D'
            ITEM.TYPE = 'FIELD'
            ITEM.FIELD.TYPE = VOC.ITEM.TYPE
            ITEM.FIELD.FILE.NUM = PRIMARY.FILE.NUM
            DICT.REC = VOC.REC
         CASE VOC.ITEM.TYPE = 'PH'
            PHRASE.TO.EXPAND = VOC.REC<2>
            GOSUB EXPAND.PHRASE
      END CASE
      RETURN


*
*
* CHECK VOC KEYWORD RECORD
*
CHECK.VOC.KEYWORD: 
      ITEM.TYPE = '*KEYWORD*'
      ITEM.KEYWORD = VOC.KEYWORD
      LOCATE ITEM.KEYWORD IN PREPROCESS.KEYWORD.LIST<1> SETTING PREPROCESS.POS THEN
         WHICH.PREPROCESS = PREPROCESS.LIST<PREPROCESS.POS>
         ITEM.TYPE = 'PREPROCESS'
      END
      LOCATE ITEM IN XL.IGNORE.OPTION<1,1> SETTING X.POS ELSE
         LOCATE ITEM.KEYWORD IN OPTION.KEYWORD.LIST<1> SETTING OPTION.POS THEN
            WHICH.OPTION = OPTION.LIST<OPTION.POS>
            ITEM.TYPE = 'OPTION'
         END
      END
      IF ITEM.TYPE = '*KEYWORD*' THEN
         LOCATE ITEM.KEYWORD IN PREFIX.KEYWORD.LIST<1> SETTING PREFIX.POS THEN
            WHICH.PREFIX = PREFIX.LIST<PREFIX.POS>
            ITEM.TYPE = 'PREFIX'
         END
      END
      IF ITEM.TYPE = '*KEYWORD*' THEN
         LOCATE ITEM.KEYWORD IN QUALIFIER.KEYWORD.LIST<1> SETTING QUALIFIER.POS THEN
            WHICH.QUALIFIER = QUALIFIER.LIST<QUALIFIER.POS>
            ITEM.TYPE = 'QUALIFIER'
         END
      END
      IF ITEM.TYPE = '*KEYWORD*' THEN
         LOCATE ITEM.KEYWORD IN OPERATOR.KEYWORD.LIST<2,1> SETTING OPERATOR.POS THEN
            WHICH.OPERATOR = OPERATOR.LIST<2,OPERATOR.POS>
            ITEM.TYPE = 'OPERATOR'
         END
      END
      IF ITEM.TYPE = '*KEYWORD*' THEN
         LOCATE ITEM.KEYWORD IN MISC.FIELD.KEYWORD.LIST<1> SETTING MISC.FIELD.POS THEN
            WHICH.MISC.FIELD = MISC.FIELD.LIST<MISC.FIELD.POS>
            ITEM.TYPE = 'MISC.FIELD'
         END
      END
      IF ITEM.TYPE = '*KEYWORD*' THEN
         LOCATE ITEM.KEYWORD IN MISC.KEYWORD.KEYWORD.LIST<1> SETTING MISC.KEYWORD.POS THEN
            WHICH.MISC.KEYWORD = MISC.KEYWORD.LIST<MISC.KEYWORD.POS>
            ITEM.TYPE = 'KEYWORD'
         END
      END
      IF ITEM.TYPE = '*KEYWORD*' THEN
         ITEM.TYPE = 'KEYWORD'
      END
      RETURN




*******************************************************************************
**
**   FINISH UP COMMAND LINE ITEMS: CHECK FOR CONSISTENCY, COMPLETENESS
**
*******************************************************************************
FINISH.ITEMS: 
      DEBUG3OR4
      CRT 'GOSUB FINISH.ITEMS'
      END
      GOSUB FINISH.COMPILE.IDESC
      GOSUB FINISH.DLMAIN.PRINT.METHOD
      GOSUB FINISH.FILE.DICT.ITEMS
      GOSUB FINISH.OPTIONS
      IF DLMAIN.FATAL.ERROR THEN
         RETURN
      END
      GOSUB FINISH.EOR.CHAR
      GOSUB FINISH.COMMA.CHAR
      GOSUB FINISH.QUOTE.CHAR
* SEE IF NUM.VALUES WAS SPECIFIED FOR A SECONDARY KEY
      FOR WHICH.FILE.NUM = 1 TO DLMAIN.NUM.FILES
         NUM.VALUES.VALUE = DLMAIN.INFO.FILE.KEY.NUM.VALUES(WHICH.FILE.NUM)
         IF NUM.VALUES.VALUE NE '' THEN
            OUT.REC = DLMAIN.INFO.FILE.KEY.DICT.CTR(WHICH.FILE.NUM)
            X.HAVE.MATCH = FALSE
            FOR OUT.REC.CTR=1 TO DL.OUTR.NUM.OUT.RECS UNTIL X.HAVE.MATCH
               FOR FIELD.CTR = 1 TO DL.OUTR.NUM.OUT.FIELDS(OUT.REC.CTR) UNTIL X.HAVE.MATCH
                  IF OUT.REC = DL.OUTR.CTR.LIST(OUT.REC.CTR)<FIELD.CTR> THEN
                     X.HAVE.MATCH = TRUE
                     DL.OUTR.NUM.VALUES.LIST(OUT.REC.CTR)<FIELD.CTR> = NUM.VALUES.VALUE
                  END
               NEXT FIELD.CTR
            NEXT OUT.REC.CTR
         END
      NEXT WHICH.FILE.NUM

      FOR OUT.REC.CTR=1 TO DL.OUTR.NUM.OUT.RECS
         GOSUB FINISH.OUTPUT.FIELDS
      NEXT OUT.REC.CTR
      IF DLMAIN.HEADING.OUT.REC # '' THEN
         GOSUB FINISH.HEADING
      END
      GOSUB FINISH.CHECK.LITERAL
      FOR BREAK.LIST.CTR=1 TO DLMAIN.NUM.BREAK.FIELDS
         GOSUB FINISH.BREAK.FIELDS
      NEXT BREAK.LIST.CTR
      IF DLMAIN.FATAL.ERROR THEN
         RETURN
      END
      RETURN


FINISH.CHECK.LITERAL: 
      IF DLMAIN.NUM.LITERAL.VALUES > DLMAX.LITERAL.VALUES THEN
         DLMAIN.ERRMSG<-1> = '*** Fatal Error, too many literal items: ':DLMAIN.NUM.LITERAL.VALUES
         DLMAIN.FATAL.ERROR = TRUE
         RETURN
      END
      MATPARSE DLMAIN.LITERAL.VALUES FROM DLMAIN.LITERAL.VALUE.LIST, @FM
      RETURN

*
* COMPILE ALL I-DESC'S THAT NEED IT
*
FINISH.COMPILE.IDESC: 
      FOR DICT.FIELD.CTR=1 TO DL.DATA.NUM.DICT.RECS
         IF DL.DATA.DICT.RECS(DICT.FIELD.CTR)<1>[1,1] = 'I' AND DL.DATA.DICT.RECS(DICT.FIELD.CTR)<DBMS.DICT.FIELD.TO.CHECK> = '' THEN
            FILE.NUM = DL.DATA.DICT.REC.FILE.NUM(DICT.FIELD.CTR)
            FILE.NAME = DLMAIN.INFO.FILE.NAME.PART.2(FILE.NUM)
            IF PRIMARY.DICT.PART.1 = 'DICT' OR FILE.NUM # PRIMARY.FILE.NUM THEN
               FIELD.NAME = DL.DATA.DICT.REC.FIELD.LIST<DICT.FIELD.CTR>
               CD.COMMAND = 'COMPILE.DICT ':FILE.NAME:' ':FIELD.NAME
               EXECUTE CD.COMMAND
               READ DL.DATA.DICT.RECS(DICT.FIELD.CTR) FROM F.DICT.FILE(FILE.NUM), FIELD.NAME ELSE
                  DLMAIN.ERRMSG<-1> = 'Can not read "':FIELD.NAME:'" from "DICT" "':FILE.NAME:'"'
                  DLMAIN.FATAL.ERROR = TRUE
               END
            END
         END
      NEXT DICT.FIELD.CTR
      RETURN

*
* CHECK WHICH METHOD TO PRINT LINES
*
FINISH.DLMAIN.PRINT.METHOD: 
      BEGIN CASE
         CASE DLMAIN.OUTPUT.FILE.NAME = ''
            DLMAIN.PRINT.METHOD = 'CRT'
         CASE DLMAIN.FORMAT = 'WP50'
            DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS'
         CASE DLMAIN.FORMAT = 'WP51'
            DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS'
         CASE DLMAIN.FORMAT = 'FIXED' AND DLMAIN.NO.LINEFEED
            DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS'
         CASE DLMAIN.FORMAT = 'DBF'
            DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS'
         CASE 1
            DLMAIN.PRINT.METHOD = 'WRITESEQ'
      END CASE
      IF DLMAIN.PRINT.METHOD NE 'CRT' THEN
         IF DLMAIN.OUTPUT.FILE.TYPE NE 'DIR' THEN
            IF @LOGNAME = 'rotmand' THEN
               CRT 'DLMAIN.OUTPUT.FILE.TYPE ':DLMAIN.OUTPUT.FILE.TYPE
            END
            DLMAIN.ERRMSG<-1> = 'Output format ':DLMAIN.FORMAT:' requires that output be written to a DIRectory.'
            DLMAIN.FATAL.ERROR = TRUE
            RETURN
         END
      END
      RETURN


*
*
* MAKE DICT ITEMS FROM SECONDARY FIELDS MV IF KEY TO FILE IS MV
*
FINISH.FILE.DICT.ITEMS: 
      FOR DICT.FIELD.CTR=1 TO DL.DATA.NUM.DICT.RECS
         FILE.NUM = DL.DATA.DICT.REC.FILE.NUM(DICT.FIELD.CTR)
         IF DLMAIN.INFO.FILE.KEY.IS.MULTIVALUE(FILE.NUM) THEN
            DL.DATA.DICT.RECS(DICT.FIELD.CTR)<6> = 'M'
         END
         NUM.VALUES.VALUE = DLMAIN.INFO.FILE.KEY.NUM.VALUES(FILE.NUM)
      NEXT DICT.FIELD.CTR
      RETURN


*
*
* FINISH OPTIONS
*
FINISH.OPTIONS: 
      GOSUB FO.CONSISTENCY.CHECK
      GOSUB FO.FILL.IN.MISSING
      RETURN

*
* FINISH.OPTIONS CONSISTENCY CHECK
*
FO.CONSISTENCY.CHECK: 
      IF DEFAULT.NUM.VALUES = 'ALL' THEN
         OKAY.LIST = 'WP50 WP51 COMMA QUOTE DIF HTML TAB XML'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            IF DLMAIN.FORMAT = 'FIXED' AND DEFAULT.MV.ORIENTATION = 'VERTICAL' THEN
               NULL
            END ELSE
               DLMAIN.ERRMSG<-1> = 'DEFAULT NUM.VALUES ALL is only valid with formats ':OKAY.LIST.DISPLAY
               DLMAIN.ERRMSG<-1> = '   or FORMAT FIXED DEFAULT MV.ORIENTATION VERTICAL.'
               DLMAIN.FATAL.ERROR = TRUE
            END
         END
      END
      IF DEFAULT.NUM.SUBVALUES = 'ALL' THEN
         OKAY.LIST = 'WP50 WP51 COMMA QUOTE DIF HTML TAB XML'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            IF DLMAIN.FORMAT = 'FIXED' AND DEFAULT.MV.ORIENTATION = 'VERTICAL' THEN
               NULL
            END ELSE
               DLMAIN.ERRMSG<-1> = 'DEFAULT NUM.SUBVALUES ALL is only valid with formats ':OKAY.LIST.DISPLAY
               DLMAIN.ERRMSG<-1> = '   or FORMAT FIXED DEFAULT MV.ORIENTATION VERTICAL.'
               DLMAIN.FATAL.ERROR = TRUE
            END
         END
      END
      IF DEFAULT.MV.ORIENTATION # '' THEN
         OKAY.LIST = 'COMMA QUOTE DIF HTML'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            DLMAIN.ERRMSG<-1> = 'DEFAULT MV.ORIENTATION is not a valid option with FORMAT ':DLMAIN.FORMAT
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      IF DLMAIN.RECORD.LENGTH # '' AND DLMAIN.FORMAT # 'FIXED' THEN
         DLMAIN.ERRMSG<-1> = 'RECORD.LENGTH is only valid with FORMAT FIXED'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DLMAIN.FIELD.GAP # '' THEN
         OKAY.LIST = 'FIXED XML'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            DLMAIN.ERRMSG<-1> = 'FIELD.GAP is only valid with format ':OKAY.LIST.DISPLAY:'.'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      IF DLMAIN.NO.LINEFEED AND DLMAIN.FORMAT # 'FIXED' THEN
         DLMAIN.ERRMSG<-1> = 'NO.LINEFEED is only valid with FORMAT FIXED'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DL.OUTR.DOCUMENT.TITLE # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.TITLE option is only valid for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DL.OUTR.DOCUMENT.TOP # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.TOP option is only valid for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DL.OUTR.DOCUMENT.BOTTOM # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.BOTTOM option is only valid for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DL.OUTR.DOCUMENT.TABLE # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.TABLE option is only valid for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DL.OUTR.DOCUMENT.BODY # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.BODY option is only valid for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF DLMAIN.APPEND THEN
         OKAY.LIST = 'COMMA HTML QUOTE TAB XML FIXED'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            DLMAIN.ERRMSG<-1> = 'APPEND option is only valid for formats ':OKAY.LIST.DISPLAY:'.'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      RETURN

*
* FINISH.OPTIONS FILL.IN.MISSING
*
FO.FILL.IN.MISSING: 
      IF DLMAIN.DISPLAY.COUNT = '' THEN
         IF DLMAIN.PRINT.METHOD = 'CRT' THEN
            DLMAIN.DISPLAY.COUNT = FALSE
         END ELSE
            DLMAIN.DISPLAY.COUNT = TRUE
         END
      END
      IF DEFAULT.MV.ORIENTATION = '' AND DLMAIN.FORMAT # 'WP50' AND DLMAIN.FORMAT # 'WP51' THEN
         DEFAULT.MV.ORIENTATION = DLMAIN.RECORD.ORIENTATION
      END
      IF NOT(SET.DEFAULT.NUM.VALUES) THEN
         IF DLMAIN.FORMAT = 'WP50' OR DLMAIN.FORMAT = 'WP51' THEN
            DEFAULT.NUM.VALUES = 'ALL'
         END
      END
      IF NOT(SET.DEFAULT.NUM.SUBVALUES) THEN
         IF DLMAIN.FORMAT = 'WP50' OR DLMAIN.FORMAT = 'WP51' THEN
            DEFAULT.NUM.SUBVALUES = 'ALL'
         END
      END
      IF DLMAIN.FORMAT = 'XML' THEN
         IF XML.UPCASE THEN
            DL.OUTR.XML.ROOT.NAME = OCONV(DL.OUTR.XML.ROOT.NAME,'MCU')
         END
         IF DL.OUTR.XML.FILE.NAME = '' THEN
            X.ITEM.OUT = ''
            X.DO.LOWER.CASE = TRUE
            X.ITEM = DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM)
            CALL DLXMLELEM(X.ITEM.OUT,X.ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'Cannot generate legal XML element name for file ':X.ITEM
               DLMAIN.FATAL.ERROR = TRUE
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               DL.OUTR.XML.FILE.NAME = X.ITEM.OUT
            END
         END
         IF DLMAIN.FIELD.GAP = '' THEN
            DLMAIN.FIELD.GAP = 2
         END
      END
      RETURN



FINISH.EOR.CHAR: 
      IF DLMAIN.FORMAT = 'DBF' THEN
         DLMAIN.EOR = SPACE(1)
      END
      RETURN


FINISH.QUOTE.CHAR: 
      IF DLMAIN.FORMAT = 'TAB' THEN
         DLMAIN.QUOTE = ''
      END
      RETURN


FINISH.COMMA.CHAR: 
      IF DLMAIN.FORMAT = 'TAB' THEN
         DLMAIN.COMMA = CHAR(9)
      END
      RETURN


*
*
* FINISH DOWNLOAD FIELDS
*  (PARSE DICT RECORDS, CHECK FOR CONSISTENCY AMONG QUALIFIERS)
*
FINISH.OUTPUT.FIELDS: 
      LAST.LINE.VALUE = DEFAULT.LINE
      FOR FIELD.CTR = 1 TO DL.OUTR.NUM.OUT.FIELDS(OUT.REC.CTR)
         GOSUB FOF.GET.VALUES
         GOSUB FOF.CONSISTENCY.CHECK
         GOSUB FOF.FILL.IN.MISSING
         GOSUB FOF.PUT.VALUES
      NEXT FIELD.CTR
      IF DLMAIN.FATAL.ERROR THEN
         RETURN
      END
*
* SECOND PASS
*   ASSIGN DEFAULT NUM VALUES FOR ASSOCIATED ITEMS
*   CHECK LINE/COL BEING USED
*
      LAST.LINE.VALUE = DEFAULT.LINE
      CUR.LINE = ''
      LAST.COL.USED.LIST = ''
      FOR FIELD.CTR=1 TO DL.OUTR.NUM.OUT.FIELDS(OUT.REC.CTR)
         GOSUB FOF.GET.VALUES
         GOSUB FOF.ASSOC.NUM.VALUES
         GOSUB FOF.CHECK.LINE.VALUE
         IF DLMAIN.FORMAT = 'FIXED' OR DLMAIN.FORMAT = 'DBF' THEN
            GOSUB FOF.CHECK.COLUMN.VALUES
         END
         IF DLMAIN.FORMAT = 'XML' THEN
            GOSUB FOF.CHECK.XML.GROUP.NAME
         END
         GOSUB FOF.DETERMINE.NUMERIC
         GOSUB FOF.PUT.VALUES
      NEXT FIELD.CTR
      RETURN


*
*
* FINISH DOWNLOAD FIELDS GET VALUES FROM ARRAYS
*
FOF.GET.VALUES: 
      FIELD.NAME = DL.OUTR.FIELD.LIST(OUT.REC.CTR)<FIELD.CTR>
      OUT.REC = DL.OUTR.CTR.LIST(OUT.REC.CTR)<FIELD.CTR>
      OUT.TYPE = DL.OUTR.TYPE.LIST(OUT.REC.CTR)<FIELD.CTR>
      OUT.FMT = DL.OUTR.FMT.LIST(OUT.REC.CTR)<FIELD.CTR>
      BEGIN CASE
         CASE OUT.TYPE = 'FIELD' OR OUT.TYPE = 'SUP'
            FIELD.CONV = DL.DATA.DICT.RECS(OUT.REC)<3>
            FIELD.FMT = DL.DATA.DICT.RECS(OUT.REC)<5>
            FIELD.SM = DL.DATA.DICT.RECS(OUT.REC)<6>
            FIELD.ASSOC = DL.DATA.DICT.RECS(OUT.REC)<7>
         CASE OUT.TYPE = 'SUBR'
            FIELD.CONV = ''
            FIELD.FMT = DEFAULT.FIELD.FMT
            FIELD.SM = 'S'
            FIELD.ASSOC = ''
         CASE OUT.TYPE = 'LITERAL'
            FIELD.CONV = ''
            FIELD.FMT = LEN(DLMAIN.LITERAL.VALUE.LIST<OUT.REC>):'L'
            FIELD.SM = 'S'
            FIELD.ASSOC = ''
         CASE OUT.TYPE = 'EVAL'
            FIELD.CONV = ''
            FIELD.FMT = OUT.FMT
            FIELD.SM = 'S'
            FIELD.ASSOC = ''
         CASE OUT.TYPE = 'AT.VARIABLE'
            AT.VARIABLE.NAME = FIELD(FIELD.NAME,' ',2,1)
            GOSUB GET.AT.VARIABLE.VALUE
            FIELD.CONV = ''
            FIELD.FMT = LEN(AT.VARIABLE.VALUE):'L'
            FIELD.SM = 'S'
            FIELD.ASSOC = ''
            DLMAIN.LITERAL.VALUE.LIST<OUT.REC> = AT.VARIABLE.VALUE
            DL.OUTR.TYPE.LIST(OUT.REC.CTR)<FIELD.CTR> = 'LITERAL'
      END CASE
      LINE.VALUE = DL.OUTR.LINE.LIST(OUT.REC.CTR)<FIELD.CTR>
      LENGTH.VALUE = DL.OUTR.LENGTH.LIST(OUT.REC.CTR)<FIELD.CTR>
      BEG.COL.VALUE = DL.OUTR.BEG.COL.LIST(OUT.REC.CTR)<FIELD.CTR>
      END.COL.VALUE = DL.OUTR.END.COL.LIST(OUT.REC.CTR)<FIELD.CTR>
      FMT.VALUE = DL.OUTR.FMT.LIST(OUT.REC.CTR)<FIELD.CTR>
      CONV.VALUE = DL.OUTR.CONV.LIST(OUT.REC.CTR)<FIELD.CTR>
      HTML.START.VALUE = DL.OUTR.HTML.START.LIST(OUT.REC.CTR)<FIELD.CTR>
      HTML.END.VALUE = DL.OUTR.HTML.END.LIST(OUT.REC.CTR)<FIELD.CTR>
      HTML.CELL.VALUE = DL.OUTR.HTML.CELL.LIST(OUT.REC.CTR)<FIELD.CTR>
      HTML.ROW.VALUE = DL.OUTR.HTML.ROW.LIST(OUT.REC.CTR)
      X.XML.ATTRIBUTE = DL.OUTR.XML.ATTRIBUTE.LIST(OUT.REC.CTR)<FIELD.CTR>
      X.XML.NAME = DL.OUTR.XML.NAME.LIST(OUT.REC.CTR)<FIELD.CTR>
      X.XML.GROUP.NAME = DL.OUTR.XML.GROUP.NAME.LIST(OUT.REC.CTR)<FIELD.CTR>
      X.XML.ASSOC.NAME = DL.OUTR.XML.ASSOC.NAME.LIST(OUT.REC.CTR)<FIELD.CTR>
      X.XML.SUBASSOC.NAME = DL.OUTR.XML.SUBASSOC.NAME.LIST(OUT.REC.CTR)<FIELD.CTR>
      SM.VALUE = DL.OUTR.SM.LIST(OUT.REC.CTR)<FIELD.CTR>
      NUM.VALUES.VALUE = DL.OUTR.NUM.VALUES.LIST(OUT.REC.CTR)<FIELD.CTR>
      NUM.SUBVALUES.VALUE = DL.OUTR.NUM.SUBVALUES.LIST(OUT.REC.CTR)<FIELD.CTR>
      MV.ORIENTATION.VALUE = DL.OUTR.MV.ORIENTATION.LIST(OUT.REC.CTR)<FIELD.CTR>
      VALUE.SEPARATOR.VALUE = DL.OUTR.VALUE.SEPARATOR.LIST(OUT.REC.CTR)<FIELD.CTR>
      VALUE.SEPARATOR.SET.VALUE = DL.OUTR.VALUE.SEPARATOR.SET(OUT.REC.CTR)<FIELD.CTR>
      SUBVALUE.SEPARATOR.VALUE = DL.OUTR.SUBVALUE.SEPARATOR.LIST(OUT.REC.CTR)<FIELD.CTR>
      SUBVALUE.SEPARATOR.SET.VALUE = DL.OUTR.SUBVALUE.SEPARATOR.SET(OUT.REC.CTR)<FIELD.CTR>
      PART.OF.ASSOC.VALUE = DL.OUTR.PART.OF.ASSOC.LIST(OUT.REC.CTR)<FIELD.CTR>
      NUMERIC.FLAG.VALUE = DL.OUTR.NUMERIC.FLAG.LIST(OUT.REC.CTR)<FIELD.CTR>
      DEFAULT.VALUE.VALUE = DL.OUTR.DEFAULT.VALUE.LIST(OUT.REC.CTR)<FIELD.CTR>
      IF LINE.VALUE # '' THEN
         LAST.LINE.VALUE = LINE.VALUE
      END
      RETURN


GET.AT.VARIABLE.VALUE: 
      BEGIN CASE
         CASE AT.VARIABLE.NAME = '@ACCOUNT'
            AT.VARIABLE.VALUE = @ACCOUNT
         CASE AT.VARIABLE.NAME = '@DATE'
            AT.VARIABLE.VALUE = @DATE
         CASE AT.VARIABLE.NAME = '@DAY'
            AT.VARIABLE.VALUE = @DAY
         CASE AT.VARIABLE.NAME = '@LOGNAME'
            AT.VARIABLE.VALUE = @LOGNAME
         CASE AT.VARIABLE.NAME = '@MONTH'
            AT.VARIABLE.VALUE = @MONTH
         CASE AT.VARIABLE.NAME = '@PATH'
            AT.VARIABLE.VALUE = @PATH
         CASE AT.VARIABLE.NAME = '@SYSTEM.RETURN.CODE'
            AT.VARIABLE.VALUE = @SYSTEM.RETURN.CODE
         CASE AT.VARIABLE.NAME = '@TIME'
            AT.VARIABLE.VALUE = @TIME
         CASE AT.VARIABLE.NAME = '@YEAR'
            AT.VARIABLE.VALUE = @YEAR
         CASE 1
            AT.VARIABLE.VALUE = AT.VARIABLE.NAME
      END CASE
      RETURN



*
*
* FINISH DOWNLOAD FIELDS PUT VALUES BACK IN ARRAYS & LISTS
*
FOF.PUT.VALUES: 
      DL.OUTR.LINE.LIST(OUT.REC.CTR)<FIELD.CTR> = LINE.VALUE
      DL.OUTR.LENGTH.LIST(OUT.REC.CTR)<FIELD.CTR> = LENGTH.VALUE
      DL.OUTR.BEG.COL.LIST(OUT.REC.CTR)<FIELD.CTR> = BEG.COL.VALUE
      DL.OUTR.END.COL.LIST(OUT.REC.CTR)<FIELD.CTR> = END.COL.VALUE
      DL.OUTR.FMT.LIST(OUT.REC.CTR)<FIELD.CTR> = FMT.VALUE
      DL.OUTR.FIELD.FMT.LIST(OUT.REC.CTR)<FIELD.CTR> = FIELD.FMT
      DL.OUTR.CONV.LIST(OUT.REC.CTR)<FIELD.CTR> = CONV.VALUE
      DL.OUTR.HTML.START.LIST(OUT.REC.CTR)<FIELD.CTR> = HTML.START.VALUE
      DL.OUTR.HTML.END.LIST(OUT.REC.CTR)<FIELD.CTR> = HTML.END.VALUE
      DL.OUTR.HTML.CELL.LIST(OUT.REC.CTR)<FIELD.CTR> = HTML.CELL.VALUE
      DL.OUTR.HTML.ROW.LIST(OUT.REC.CTR) = HTML.ROW.VALUE
      DL.OUTR.XML.NAME.LIST(OUT.REC.CTR)<FIELD.CTR> = X.XML.NAME
      DL.OUTR.XML.GROUP.NAME.LIST(OUT.REC.CTR)<FIELD.CTR> = X.XML.GROUP.NAME
      DL.OUTR.XML.ASSOC.NAME.LIST(OUT.REC.CTR)<FIELD.CTR> = X.XML.ASSOC.NAME
      DL.OUTR.XML.SUBASSOC.NAME.LIST(OUT.REC.CTR)<FIELD.CTR> = X.XML.SUBASSOC.NAME
      DL.OUTR.SM.LIST(OUT.REC.CTR)<FIELD.CTR> = SM.VALUE
      DL.OUTR.FIELD.CONV.LIST(OUT.REC.CTR)<FIELD.CTR> = FIELD.CONV
      DL.OUTR.NUM.VALUES.LIST(OUT.REC.CTR)<FIELD.CTR> = NUM.VALUES.VALUE
      DL.OUTR.NUM.SUBVALUES.LIST(OUT.REC.CTR)<FIELD.CTR> = NUM.SUBVALUES.VALUE
      DL.OUTR.MV.ORIENTATION.LIST(OUT.REC.CTR)<FIELD.CTR> = MV.ORIENTATION.VALUE
      DL.OUTR.VALUE.SEPARATOR.LIST(OUT.REC.CTR)<FIELD.CTR> = VALUE.SEPARATOR.VALUE
      DL.OUTR.VALUE.SEPARATOR.SET(OUT.REC.CTR)<FIELD.CTR> = VALUE.SEPARATOR.SET.VALUE
      DL.OUTR.SUBVALUE.SEPARATOR.LIST(OUT.REC.CTR)<FIELD.CTR> = SUBVALUE.SEPARATOR.VALUE
      DL.OUTR.SUBVALUE.SEPARATOR.SET(OUT.REC.CTR)<FIELD.CTR> = SUBVALUE.SEPARATOR.SET.VALUE
      DL.OUTR.PART.OF.ASSOC.LIST(OUT.REC.CTR)<FIELD.CTR> = PART.OF.ASSOC.VALUE
      WHICH.DICT.REC.CTR = DL.OUTR.CTR.LIST(OUT.REC.CTR)<FIELD.CTR>
      IF WHICH.DICT.REC.CTR AND (OUT.TYPE = 'FIELD' OR OUT.TYPE = 'SUP') THEN
         DL.DATA.DICT.PART.OF.ASSOC.LIST(WHICH.DICT.REC.CTR) = PART.OF.ASSOC.VALUE
      END
      DL.OUTR.NUMERIC.FLAG.LIST(OUT.REC.CTR)<FIELD.CTR> = NUMERIC.FLAG.VALUE
      DL.OUTR.DEFAULT.VALUE.LIST(OUT.REC.CTR)<FIELD.CTR> = DEFAULT.VALUE.VALUE
      RETURN


*
*
* FINISH DOWNLOAD FIELDS CONSISTENCY CHECK
*
FOF.CONSISTENCY.CHECK: 
      IF SUBVALUE.SEPARATOR.SET.VALUE THEN
         IF VALUE.SEPARATOR.SET.VALUE AND (SUBVALUE.SEPARATOR.VALUE EQ DLMAIN.COMMA) THEN
            DLMAIN.ERRMSG<-1> = 'If you specify the VALUE.SEPARATOR, then either omit the SUBVALUE.SEPARATOR qualifier or specify a SUBVALUE.SEPARATOR different than the field separator (comma character).'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      IF LINE.VALUE # '' THEN
         OKAY.LIST = 'FIXED COMMA QUOTE TAB'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': LINE ':LINE.VALUE:' can only be used with formats ':OKAY.LIST.DISPLAY:'.'
            DLMAIN.FATAL.ERROR = TRUE
         END
      END
      IF HTML.CELL.VALUE # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.CELL qualifier is valid only for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF HTML.ROW.VALUE # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.ROW qualifier is valid only for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF HTML.START.VALUE # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.START qualifier is valid only for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF HTML.END.VALUE # '' AND DLMAIN.FORMAT # 'HTML' THEN
         DLMAIN.ERRMSG<-1> = 'HTML.END qualifier is valid only for HTML format.'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF BEG.COL.VALUE # '' AND DLMAIN.FORMAT # 'FIXED' THEN
         DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': BEG.COL ':BEG.COL.VALUE:' can only be used with FORMAT FIXED'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF END.COL.VALUE # '' AND DLMAIN.FORMAT # 'FIXED' THEN
         DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': END.COL ':END.COL.VALUE:' can only be used with FORMAT FIXED'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF LENGTH.VALUE # '' AND END.COL.VALUE # '' THEN
         DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': LENGTH ':LENGTH.VALUE:' and END.COL ':END.COL.VALUE:' are incompatible'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF BEG.COL.VALUE # '' AND END.COL.VALUE # '' AND BEG.COL.VALUE > END.COL.VALUE THEN
         DLMAIN.ERRMSG<-1> = 'Invalid qualifiers for ':FIELD.NAME:': BEG.COL ':BEG.COL.VALUE:' is greater than END.COL ':END.COL.VALUE
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF MV.ORIENTATION.VALUE # '' AND (DLMAIN.FORMAT = 'WP50' OR DLMAIN.FORMAT = 'WP51') THEN
         DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': MV.ORIENTATION is not valid with FORMAT WP50 or WP51'
         DLMAIN.FATAL.ERROR = TRUE
      END
      IF NUM.VALUES.VALUE = 'ALL' THEN
         OKAY.LIST = 'WP50 WP51 COMMA QUOTE TAB DIF HTML XML'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            BEGIN CASE
               CASE MV.ORIENTATION.VALUE = 'VERTICAL' AND DLMAIN.FORMAT = 'FIXED'
                  NULL
               CASE DEFAULT.MV.ORIENTATION = 'VERTICAL' AND MV.ORIENTATION.VALUE = '' AND DLMAIN.FORMAT = 'FIXED'
                  NULL
               CASE 1
                  DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': NUM.VALUES ALL is only valid with formats ':OKAY.LIST.DISPLAY
                  DLMAIN.ERRMSG<-1> = '   or FORMAT FIXED with option MV.ORIENTATION VERTICAL.'
                  DLMAIN.FATAL.ERROR = TRUE
            END CASE
         END
      END
      IF NUM.SUBVALUES.VALUE = 'ALL' THEN
         OKAY.LIST = 'FIXED COMMA QUOTE TAB WP50 WP51 DIF XML'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS ELSE
            BEGIN CASE
               CASE MV.ORIENTATION.VALUE = 'VERTICAL' AND DLMAIN.FORMAT = 'FIXED'
                  NULL
               CASE DEFAULT.MV.ORIENTATION = 'VERTICAL' AND MV.ORIENTATION.VALUE = '' AND DLMAIN.FORMAT = 'FIXED'
                  NULL
               CASE 1
                  DLMAIN.ERRMSG<-1> = 'Invalid qualifier for ':FIELD.NAME:': NUM.SUBVALUES ALL is only valid with formats ':OKAY.LIST.DISPLAY
                  DLMAIN.ERRMSG<-1> = '   or FORMAT FIXED with option MV.ORIENTATION VERTICAL.'
                  DLMAIN.FATAL.ERROR = TRUE
            END CASE
         END
      END
      RETURN


*
*
* FINISH DOWNLOAD FIELDS FILL IN MISSING INFORMATION
*
FOF.FILL.IN.MISSING: 
      IF FMT.VALUE = '' THEN
         FMT.VALUE = DEFAULT.FMT
      END
      IF CONV.VALUE = '' THEN
         CONV.VALUE = DEFAULT.CONV
      END
      IF HTML.START.VALUE = '' THEN
         HTML.START.VALUE = DEFAULT.HTML.START
      END
      IF HTML.END.VALUE = '' THEN
         HTML.END.VALUE = DEFAULT.HTML.END
      END
      IF HTML.CELL.VALUE = '' THEN
         HTML.CELL.VALUE = DEFAULT.HTML.CELL
      END
      IF HTML.ROW.VALUE = '' THEN
         HTML.ROW.VALUE = DEFAULT.HTML.ROW
      END
      IF LENGTH.VALUE = '' THEN
         LENGTH.VALUE = DEFAULT.LENGTH
      END
      IF SM.VALUE = '' THEN
         IF FIELD.SM = '' THEN
            SM.VALUE = DEFAULT.SM
         END ELSE
            SM.VALUE = FIELD.SM
         END
      END
      IF MV.ORIENTATION.VALUE = '' THEN
         MV.ORIENTATION.VALUE = DEFAULT.MV.ORIENTATION
      END
      IF VALUE.SEPARATOR.VALUE = '' THEN
         IF SET.DEFAULT.VALUE.SEPARATOR THEN
            VALUE.SEPARATOR.VALUE = DEFAULT.VALUE.SEPARATOR
            VALUE.SEPARATOR.SET.VALUE = TRUE
         END
      END
      IF SUBVALUE.SEPARATOR.VALUE = '' THEN
         IF SET.DEFAULT.SUBVALUE.SEPARATOR THEN
            SUBVALUE.SEPARATOR.VALUE = VALUE.SEPARATOR.VALUE
            SUBVALUE.SEPARATOR.SET.VALUE = TRUE
         END
      END
      IF DEFAULT.VALUE.VALUE = '' THEN
         DEFAULT.VALUE.VALUE = DEFAULT.DEFAULT.VALUE
      END
      IF DLMAIN.FORMAT = 'XML' THEN
         IF X.XML.NAME = '' THEN
            X.ITEM.OUT = ''
            X.ITEM = FIELD.NAME
            X.DO.LOWER.CASE = TRUE
            CALL DLXMLELEM(X.ITEM.OUT,X.ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML field name "':X.ITEM:'" does not generate a valid XML name.'
               DLMAIN.FATAL.ERROR = TRUE
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               X.XML.NAME = X.ITEM.OUT
            END
         END
         IF FIELD.SM = 'M' AND X.XML.ASSOC.NAME = '' THEN
            X.ITEM.OUT = ''
            X.ITEM = FIELD.ASSOC
            IF X.ITEM = '' THEN
               X.ITEM = FIELD.NAME:'ASSOC'
            END
            X.DO.LOWER.CASE = TRUE
            CALL DLXMLELEM(X.ITEM.OUT,X.ITEM,X.DO.LOWER.CASE,XML.ALLOW.PERIODS)
            IF X.ITEM.OUT = '' THEN
               DLMAIN.ERRMSG<-1> = 'XML association name "':X.ITEM:'" (field "':FIELD.NAME:'") does not generate a valid XML name.'
               DLMAIN.FATAL.ERROR = TRUE
            END ELSE
               IF XML.UPCASE THEN
                  X.ITEM.OUT = OCONV(X.ITEM.OUT,'MCU')
               END
               X.XML.ASSOC.NAME = X.ITEM.OUT
            END
         END
      END
*
* DETERMINE WHICH CODES WILL BE USED (TO CHECK OUTPUT LENGTHS, ETC.)
*
      GOSUB FOF.USE.FMT.CONV
*
* DETERMINE IS THIS FIELD IS PART OF THE "WHEN" ASSOCIATION
*
      IF SM.VALUE = 'M' THEN
         GOSUB FOF.CHECK.FOR.MATCHING.ASSOC.NAME
         IF WHEN.ASSOC.NAME.MATCHES THEN
            PART.OF.ASSOC.VALUE = TRUE
         END
      END
*
* FINISHING THE FIELDS IS A 2-PASS OPERATION,
*   SO ASSOCIATED FIELDS THAT DO NOT HAVE AN EXPLICIT
*   NUM.VALUES CLAUSE ARE NOT HANDLED HERE, BUT
*   IN FOF.ASSOC.NUM.VALUES
*
      IF NUM.VALUES.VALUE = '' THEN
         IF SM.VALUE # 'M' THEN
            NUM.VALUES.VALUE = 1
         END ELSE
            IF FIELD.ASSOC = '' THEN
               NUM.VALUES.VALUE = DEFAULT.NUM.VALUES
            END
         END
      END ELSE
         IF FIELD.ASSOC # '' THEN
            LOCATE FIELD.ASSOC IN DL.WHEN.ASSOC.NAME.LIST<1> SETTING ASSOC.NAME.POS ELSE
               DL.WHEN.ASSOC.NAME.LIST<ASSOC.NAME.POS> = FIELD.ASSOC
            END
            IF ASSOC.NUM.VALUES.LIST<ASSOC.NAME.POS> = '' THEN
               ASSOC.NUM.VALUES.LIST<ASSOC.NAME.POS> = NUM.VALUES.VALUE
            END
         END
      END
      IF NUM.SUBVALUES.VALUE = '' THEN
         IF SM.VALUE # 'M' THEN
            NUM.SUBVALUES.VALUE = 1
         END ELSE
            IF FIELD.ASSOC = '' THEN
               NUM.SUBVALUES.VALUE = DEFAULT.NUM.SUBVALUES
            END
         END
      END ELSE
         IF FIELD.ASSOC # '' THEN
            LOCATE FIELD.ASSOC IN DL.WHEN.ASSOC.NAME.LIST<1> SETTING ASSOC.NAME.POS ELSE
               DL.WHEN.ASSOC.NAME.LIST<ASSOC.NAME.POS> = FIELD.ASSOC
            END
            IF ASSOC.NUM.SUBVALUES.LIST<ASSOC.NAME.POS> = '' THEN
               ASSOC.NUM.SUBVALUES.LIST<ASSOC.NAME.POS> = NUM.SUBVALUES.VALUE
            END
         END
      END
      RETURN


*
*
* CHECK FOR A MATCH WITH THE WHEN.ASSOC NAME
*
FOF.CHECK.FOR.MATCHING.ASSOC.NAME: 
      WHEN.ASSOC.NAME.MATCHES = FALSE
      IF WHEN.ASSOC.NAME.IS.FIELD.NAME THEN
         IF WHEN.ASSOC.NAME = FIELD.NAME THEN
            WHEN.ASSOC.NAME.MATCHES = TRUE
         END
      END ELSE
         IF WHEN.ASSOC.NAME # '' AND WHEN.ASSOC.NAME = FIELD.ASSOC THEN
            WHEN.ASSOC.NAME.MATCHES = TRUE
         END
      END
      RETURN


*
*
* CREATE USE.FMT & USE.CONV
*
FOF.USE.FMT.CONV: 
      BEGIN CASE
         CASE FMT.VALUE = NULL.CODE
            USE.FMT.VALUE = ''
         CASE FMT.VALUE = ''
            USE.FMT.VALUE = FIELD.FMT
         CASE 1
            USE.FMT.VALUE = FMT.VALUE
      END CASE
      BEGIN CASE
         CASE CONV.VALUE = NULL.CODE
            USE.CONV.VALUE = ''
         CASE CONV.VALUE = ''
            USE.CONV.VALUE = FIELD.CONV
         CASE 1
            USE.CONV.VALUE = CONV.VALUE
      END CASE
      RETURN


*
*
* FINISH DOWNLOAD FIELDS CHECK LINE VALUE
*   MAKE SURE WE HAVE A LINE #
*   FOR FIXED FORMAT, MAKE SURE WE HAVE A BEG.COL & LENGTH
*
FOF.CHECK.LINE.VALUE: 
      IF LINE.VALUE = '' THEN
         IF CUR.LINE = '' THEN
            LINE.VALUE = DEFAULT.LINE
         END ELSE
            IF DLMAIN.RECORD.ORIENTATION = 'HORIZONTAL' THEN
               LINE.VALUE = LAST.LINE.VALUE
            END ELSE
               LINE.VALUE = CUR.LINE + 1
            END
         END
      END
      IF NUM.VALUES.VALUE # '' AND NUM(NUM.VALUES.VALUE) AND (MV.ORIENTATION.VALUE = 'VERTICAL' OR DLMAIN.RECORD.ORIENTATION = 'VERTICAL') THEN
         IF NUM.SUBVALUES.VALUE # '' AND NUM(NUM.SUBVALUES.VALUE) THEN
            CUR.LINE = LINE.VALUE + NUM.VALUES.VALUE*NUM.SUBVALUES.VALUE - 1
         END ELSE
            CUR.LINE = LINE.VALUE + NUM.VALUES.VALUE - 1
         END
      END ELSE
         CUR.LINE = LINE.VALUE
      END
      RETURN


*
*
* FINISH DOWNLOAD FIELDS CHECK COLUMN VALUES
*   FOR FIXED FORMAT, MAKE SURE WE HAVE A BEG.COL & LENGTH
*
FOF.CHECK.COLUMN.VALUES: 
      GOSUB FOF.USE.FMT.CONV
      IF LAST.COL.USED.LIST<LINE.VALUE> = '' THEN
         CUR.COL = DEFAULT.BEG.COL
         LAST.COL.USED.LIST<LINE.VALUE> = CUR.COL - 1
      END ELSE
         CUR.COL = LAST.COL.USED.LIST<LINE.VALUE> + 1 + DLMAIN.FIELD.GAP
      END
      IF BEG.COL.VALUE = '' THEN
         BEG.COL.VALUE = CUR.COL
      END
      IF END.COL.VALUE = '' THEN
         IF LENGTH.VALUE = '' THEN
            LENGTH.VALUE = LEN(FMT('',USE.FMT.VALUE))
         END
         IF MV.ORIENTATION.VALUE = 'HORIZONTAL' THEN
            VALUE.MULTIPLIER = NUM.VALUES.VALUE * NUM.SUBVALUES.VALUE
         END ELSE
            VALUE.MULTIPLIER = 1
         END
         END.COL.VALUE = BEG.COL.VALUE + LENGTH.VALUE*VALUE.MULTIPLIER - 1
      END ELSE
         IF MV.ORIENTATION.VALUE = 'HORIZONTAL' THEN
            VALUE.DIVISOR = NUM.VALUES.VALUE * NUM.SUBVALUES.VALUE
         END ELSE
            VALUE.DIVISOR = 1
         END
         LENGTH.VALUE = INT(END.COL.VALUE - BEG.COL.VALUE + 1) / VALUE.DIVISOR
      END
      IF END.COL.VALUE > LAST.COL.USED.LIST<LINE.VALUE> THEN
         LAST.COL.USED.LIST<LINE.VALUE> = END.COL.VALUE
      END
      RETURN


FOF.CHECK.XML.GROUP.NAME: 
      XL.TEMP = DL.OUTR.XML.ASSOC.NAME.LIST(OUT.REC.CTR)
      NUM.XL.TEMP = DCOUNT(XL.TEMP,@FM)
      FOR WHICH.XL.TEMP = 1 TO NUM.XL.TEMP UNTIL X.XML.GROUP.NAME NE ''
         X.ASSOC.NAME = XL.TEMP<WHICH.XL.TEMP>
         IF X.ASSOC.NAME = X.XML.ASSOC.NAME THEN
            X.GROUP.NAME = DL.OUTR.XML.GROUP.NAME.LIST(OUT.REC.CTR)<WHICH.XL.TEMP>
            IF X.GROUP.NAME NE '' THEN
               X.XML.GROUP.NAME = X.GROUP.NAME
            END
         END
      NEXT WHICH.XL.TEMP
      RETURN


*
*
* FINISH DOWNLOAD FIELDS ASSOC NUM.VALUES
*
FOF.ASSOC.NUM.VALUES: 
      IF FIELD.ASSOC # '' AND NUM.VALUES.VALUE = '' THEN
         LOCATE FIELD.ASSOC IN DL.WHEN.ASSOC.NAME.LIST<1> SETTING ASSOC.NAME.POS THEN
            NUM.VALUES.VALUE = ASSOC.NUM.VALUES.LIST<ASSOC.NAME.POS>
         END
      END
      IF NUM.VALUES.VALUE = '' THEN
         NUM.VALUES.VALUE = DEFAULT.NUM.VALUES
      END
      IF FIELD.ASSOC # '' AND NUM.SUBVALUES.VALUE = '' THEN
         LOCATE FIELD.ASSOC IN DL.WHEN.ASSOC.NAME.LIST<1> SETTING ASSOC.NAME.POS THEN
            NUM.SUBVALUES.VALUE = ASSOC.NUM.SUBVALUES.LIST<ASSOC.NAME.POS>
         END
      END
      IF NUM.SUBVALUES.VALUE = '' THEN
         NUM.SUBVALUES.VALUE = DEFAULT.NUM.SUBVALUES
      END
      RETURN


*
*
* FINISH DOWNLOAD FIELDS, DETERMINE IF A FIELD IS NUMERIC (USED
*      IN COMMA & DIF FORMATS)
*  IF THERE IS A NUMERIC (MD...) CONVERION FLAG, THEN ASSUME FIELD
*    IS NUMERIC.  IF THERE IS NO CONVERSION FLAG, THEN IF IT IS RIGHT
*    JUSTIFIED, ASSUME IT IS NUMERIC
*
FOF.DETERMINE.NUMERIC: 
      BEGIN CASE
         CASE CONV.VALUE = NULL.CODE
            NULL
         CASE CONV.VALUE[1,2] = 'MD'
            NUMERIC.FLAG.VALUE = TRUE
         CASE CONV.VALUE # ''
            NULL
         CASE FIELD.CONV[1,2] = 'MD'
            NUMERIC.FLAG.VALUE = TRUE
         CASE FIELD.CONV # ''
            NULL
         CASE FMT.VALUE = NULL.CODE
            NULL
         CASE INDEX(FMT.VALUE,'R',1) > 0
            NUMERIC.FLAG.VALUE = TRUE
         CASE FMT.VALUE # ''
            NULL
         CASE INDEX(FIELD.FMT,'R',1) > 0
            NUMERIC.FLAG.VALUE = TRUE
      END CASE
      RETURN


*
*
* FINISH BREAK FIELDS
*
FINISH.BREAK.FIELDS: 
      IF DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> = '' THEN
         DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> = DEFAULT.OUT.REC
      END
      IF DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> = KEYWORD.NONE THEN
         DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.LIST.CTR> = ''
      END
      RETURN




*******************************************************************************
**
**   POST-ITEM PROCESSING (DO THESE THINGS AFTER PROCESSING ITEMS, BUT BEFORE
**       PROCESSING DATA RECORD
**
*******************************************************************************
POST.ITEMS.PROCESSING: 
      DEBUG3OR4
      CRT 'GOSUB POST.ITEMS.PROCESSING'
      END
      BEGIN CASE
         CASE DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS'
            GOSUB OP.SYS.OPENFILE
         CASE DLMAIN.PRINT.METHOD = 'WRITESEQ'
            GOSUB OPEN.OUTPUT.FILE
      END CASE
      IF DLMAIN.NUM.EVAL.FORMULAE GT 0 THEN
         GOSUB EVAL.INIT
      END
      IF X.PRIMARY.LIST.NAME NE '' THEN
         GOSUB RESTORE.PRIMARY.LIST
      END
      RETURN


EVAL.INIT: 
      IF X.PRIMARY.LIST.NAME = '' THEN
         GOSUB SAVE.PRIMARY.LIST
      END
      X.COMMAND = 'GET.LIST ':X.PRIMARY.LIST.NAME:' TO ':DLMAIN.FROM.UNIT
      EXECUTE X.COMMAND
      READNEXT DLMAIN.RECORD.ID FROM DLMAIN.FROM.UNIT ELSE
         DLMAIN.RECORD.ID = ''
      END
      IF DLMAIN.RECORD.ID = '' THEN
         DLMAIN.RECORD = ''
      END ELSE
         READ DLMAIN.RECORD FROM DLMAIN.F.INFO.FILE(PRIMARY.FILE.NUM), DLMAIN.RECORD.ID ELSE
            DLMAIN.RECORD = ''
         END
      END
      DLMAIN.EVAL.UNIT = 0
      RETURN


RESTORE.PRIMARY.LIST: 
      X.COMMAND = 'GET.LIST ':X.PRIMARY.LIST.NAME:' TO ':DLMAIN.FROM.UNIT
      EXECUTE X.COMMAND
      RETURN


SAVE.PRIMARY.LIST: 
      X.PRIMARY.LIST.NAME = 'DL'
      X.PRIMARY.LIST.NAME := OCONV(@LOGNAME,'MCU')
      X.PRIMARY.LIST.NAME := TIME()
      DLMAIN.SAVEDLISTS.DELETE.LIST<1,-1> = X.PRIMARY.LIST.NAME
      X.COMMAND = 'SAVE.LIST ':X.PRIMARY.LIST.NAME
      IF DLMAIN.FROM.UNIT = 0 THEN
         DLMAIN.FROM.UNIT = 1
      END ELSE
         X.COMMAND := ' FROM ':DLMAIN.FROM.UNIT
      END
      CRT 'Creating temporary list ':X.PRIMARY.LIST.NAME
      EXECUTE X.COMMAND
      RETURN


*
*
* OPEN TYPE1 FILE
*
OPEN.OUTPUT.FILE: 
      DEBUG2
      CRT 'Opening ':DLMAIN.OUTPUT.RECORD.NAME
      END
      OPENSEQ DLMAIN.OUTPUT.FILE.NAME, DLMAIN.OUTPUT.RECORD.NAME TO DLMAIN.F.OUTPUT.FILE THEN
         IF DLMAIN.OVERWRITING THEN
            WEOFSEQ DLMAIN.F.OUTPUT.FILE
         END ELSE
            IF DLMAIN.APPEND THEN
               GOSUB APPEND.READ.THROUGH.FILE
            END ELSE
               DLMAIN.ERRMSG<-1> = '"':DLMAIN.OUTPUT.FILE.NAME:'" "':DLMAIN.OUTPUT.RECORD.NAME:'" already exists'
               DLMAIN.FATAL.ERROR = TRUE
            END
         END
      END
      RETURN


APPEND.READ.THROUGH.FILE: 
      X.NUM.INPUT = 0
      X.FILE.DONE = FALSE
      X.BODY.LOC = ''
      LOOP
         READSEQ X.TEMP FROM DLMAIN.F.OUTPUT.FILE ELSE
            X.FILE.DONE = TRUE
         END
      UNTIL X.FILE.DONE
         X.NUM.INPUT += 1
         IF DLMAIN.FORMAT = 'HTML' THEN
            IF INDEX(OCONV(X.TEMP,'MCU'),'</BODY>',1) GT 0 THEN
               X.BODY.LOC = X.NUM.INPUT
            END
         END
      REPEAT
      IF DLMAIN.FORMAT = 'HTML' THEN
         IF X.BODY.LOC GT 0 THEN
            CLOSESEQ DLMAIN.F.OUTPUT.FILE
            OPENSEQ DLMAIN.OUTPUT.FILE.NAME, DLMAIN.OUTPUT.RECORD.NAME TO DLMAIN.F.OUTPUT.FILE THEN
               FOR WHICH.LINE = 1 TO X.BODY.LOC-1
                  READSEQ X.TEMP FROM DLMAIN.F.OUTPUT.FILE ELSE
                     X.TEMP = ''
                  END
               NEXT WHICH.LINE
               WEOFSEQ DLMAIN.F.OUTPUT.FILE
            END
         END
      END
      RETURN


DISPLAY.DICT.FIELD.LIST: 
      CRT
      CRT 'DL.DATA.NUM.DICT.RECS = ':DL.DATA.NUM.DICT.RECS
      FOR DICT.CTR=1 TO DL.DATA.NUM.DICT.RECS
         CRT FMT(DICT.CTR,'2R'):' ':
         CRT FMT(DL.DATA.DICT.REC.FIELD.LIST<DICT.CTR>[1,15],'16L'):
         CRT FMT(DL.DATA.DICT.REC.FILE.NUM(DICT.CTR),'3R'):' ':
         CRT FMT(DL.DATA.DICT.RECS(DICT.CTR)<7>[1,15],'16L'):
         CRT '"':DL.DATA.DICT.PART.OF.ASSOC.LIST(DICT.CTR):'"'
      NEXT DICT.CTR
      INPUT CRT.PAUSE
      RETURN


PRINT.HELP: 
      LOCATE 'MAX' IN ITEM.LIST<1> SETTING MAX.POS THEN
         GOSUB PRINT.MAX
         RETURN
      END
      READ VOC.HELP.REC FROM DLMAIN.F.VOC, 'DOWNLOAD.HELP' THEN
         VOC.TYPE = FIELD(VOC.HELP.REC<1>,' ',1,1)
         IF VOC.TYPE = 'S' OR VOC.TYPE = 'PA' OR VOC.TYPE = 'C' THEN
            EXECUTE 'DOWNLOAD.HELP'
            STOP
         END
      END
      CRT
      CRT 'DOWNLOAD.HELP is not available.  Contact your system administrator.'
      RETURN


PRINT.MAX: 
      PRINT 'The following limits are defined for DOWNLOAD:'
      X.LEADER.SIZE = 45
      X.LEADER = 'Input data files referenced directly'
      PRINT X.LEADER:STR('.',X.LEADER.SIZE-LEN(X.LEADER)):FMT(DLMAX.FILES,'3"."R')
      X.LEADER = 'Dictionary fields referenced directly'
      PRINT X.LEADER:STR('.',X.LEADER.SIZE-LEN(X.LEADER)):FMT(DLMAX.DICT.RECS,'3"."R')
      X.LEADER = 'Literal values'
      X.LEADER = 'EVAL expressions'
      PRINT X.LEADER:STR('.',X.LEADER.SIZE-LEN(X.LEADER)):FMT(DLMAX.EVAL.FORMULAE,'3"."R')
      X.LEADER = 'SUBR expressions'
      PRINT X.LEADER:STR('.',X.LEADER.SIZE-LEN(X.LEADER)):FMT(DLMAX.SUBR.NAMES,'3"."R')
      X.LEADER = 'Subroutine arguments per subroutine'
      PRINT X.LEADER:STR('.',X.LEADER.SIZE-LEN(X.LEADER)):FMT(DLMAX.SUBR.ARGS,'3"."R')
      X.LEADER = 'Output record types (detail lines)'
      PRINT X.LEADER:STR('.',X.LEADER.SIZE-LEN(X.LEADER)):FMT(DLMAX.OUT.RECS,'3"."R')
      X.LEADER = 'Break fields'
      PRINT X.LEADER:STR('.',X.LEADER.SIZE-LEN(X.LEADER)):FMT(DLMAX.BREAK.FIELDS,'3"."R')
      RETURN


FINISH.HEADING: 
      IF NOT(DL.OUTR.DETAIL.OUT.REC) THEN
         RETURN
      END
      IF NOT(HEADING.OUT.REC.USE.FIELD.NAMES) AND NOT(HEADING.OUT.REC.USE.FIELD.LABELS) THEN
         RETURN
      END
      HEADING.CTR = 0
      FOR FIELD.CTR = 1 TO DL.OUTR.NUM.OUT.FIELDS(DL.OUTR.DETAIL.OUT.REC)
         X.ORIGINAL.ITEM = DL.OUTR.FIELD.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
         X.OUT.MV.ORIENTATION = DL.OUTR.MV.ORIENTATION.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
         X.OUT.COL.HDG.VALUE = DL.OUTR.COL.HDG.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
         IF X.OUT.COL.HDG.VALUE THEN
            X.ORIGINAL.ITEM = X.OUT.COL.HDG.VALUE
         END ELSE
            IF HEADING.OUT.REC.USE.FIELD.LABELS THEN
               LOCATE X.ORIGINAL.ITEM IN DL.DATA.DICT.REC.FIELD.LIST<1> SETTING WHICH.DICT.REC.CTR THEN
                  X.ORIGINAL.ITEM = DL.DATA.DICT.RECS(WHICH.DICT.REC.CTR)<4>
                  CONVERT @VM TO ' ' IN X.ORIGINAL.ITEM
               END
            END
         END
         X.NUM.VALUES.VALUE = DL.OUTR.NUM.VALUES.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
         IF NUM(X.NUM.VALUES.VALUE) THEN
            IF X.NUM.VALUES.VALUE LT 1 THEN
               X.NUM.VALUES.VALUE = 1
            END
            IF (X.OUT.MV.ORIENTATION = 'VERTICAL') AND (DLMAIN.RECORD.ORIENTATION = 'HORIZONTAL') THEN
               X.NUM.VALUES.VALUE = 1
            END
            IF DLMAIN.FORMAT = 'HTML' THEN
               X.NUM.VALUES.VALUE = 1
            END
         END ELSE
            X.NUM.VALUES.VALUE = 1
         END
         FOR WHICH.NUM.VALUES.VALUE = 1 TO X.NUM.VALUES.VALUE
            IF X.NUM.VALUES.VALUE GT 1 THEN
               ITEM = X.ORIGINAL.ITEM:'_':WHICH.NUM.VALUES.VALUE
            END ELSE
               ITEM = X.ORIGINAL.ITEM
            END
            CALC.ITEM.LEN = LEN(ITEM)
            DLMAIN.NUM.LITERAL.VALUES += 1
            DLMAIN.LITERAL.VALUE.LIST<DLMAIN.NUM.LITERAL.VALUES> = ITEM
            HEADING.CTR += 1
            DL.OUTR.FIELD.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = 'LITERAL ':ITEM.QUOTED:ITEM:ITEM.QUOTED
            DL.OUTR.TYPE.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = 'LITERAL'
            DL.OUTR.CTR.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = DLMAIN.NUM.LITERAL.VALUES
            IF DLMAIN.FORMAT = 'FIXED' OR DLMAIN.FORMAT = 'DBF' THEN
               DL.OUTR.FMT.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = DL.OUTR.LENGTH.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>:'L'
               DL.OUTR.LENGTH.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = DL.OUTR.LENGTH.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
               DL.OUTR.BEG.COL.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = DL.OUTR.BEG.COL.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
               DL.OUTR.END.COL.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = DL.OUTR.END.COL.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
            END ELSE
               DL.OUTR.FMT.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = CALC.ITEM.LEN:'L'
               DL.OUTR.LENGTH.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = CALC.ITEM.LEN
               IF DLMAIN.RECORD.ORIENTATION = 'HORIZONTAL' THEN
                  DL.OUTR.LINE.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = 1
               END ELSE
                  DL.OUTR.LINE.LIST(DLMAIN.HEADING.OUT.REC)<HEADING.CTR> = HEADING.CTR
               END
            END
         NEXT WHICH.NUM.VALUES.VALUE
      NEXT FIELD.CTR
      DL.OUTR.NUM.OUT.FIELDS(DLMAIN.HEADING.OUT.REC) = HEADING.CTR
      RETURN


CHECK.VARIABLE.FILE.NAME: 
      ITEM = ITEM.LIST<FILE.POS+1>
      IF ITEM # '' THEN
         GOSUB CHECK.AT.VARIABLE.SUBSTRING
         ITEM.LIST<FILE.POS+1> = ITEM
         ITEM = ITEM.LIST<FILE.POS+2>
         IF ITEM # '' THEN
            GOSUB CHECK.AT.VARIABLE.SUBSTRING
            ITEM.LIST<FILE.POS+2> = ITEM
         END
      END
      RETURN


CHECK.AT.VARIABLE.SUBSTRING: 
      FOR WHICH.NUM.AT.VARIABLES = 1 TO NUM.AT.VARIABLES UNTIL INDEX(ITEM,'@',1) = 0
         AT.VARIABLE.ITEM = AT.VARIABLE.LIST<WHICH.NUM.AT.VARIABLES>
         AT.ITEM.INDEX = INDEX(ITEM,AT.VARIABLE.ITEM,1)
         IF AT.ITEM.INDEX GT 0 THEN
            AT.VARIABLE.NAME = AT.VARIABLE.ITEM
            LEN.AT.VARIABLE.NAME = LEN(AT.VARIABLE.NAME)
            GOSUB GET.AT.VARIABLE.VALUE
            BEGIN CASE
               CASE AT.ITEM.INDEX = 1
                  ITEM = AT.VARIABLE.VALUE:ITEM[LEN.AT.VARIABLE.NAME+1,LEN(ITEM)]
               CASE AT.ITEM.INDEX + LEN.AT.VARIABLE.NAME - 1 = LEN(ITEM)
                  ITEM = ITEM[1,AT.ITEM.INDEX-1]:AT.VARIABLE.VALUE
               CASE 1
                  ITEM = ITEM[1,AT.ITEM.INDEX-1]:AT.VARIABLE.VALUE:ITEM[AT.ITEM.INDEX+LEN.AT.VARIABLE.NAME,LEN(ITEM)]
            END CASE
         END
      NEXT WHICH.NUM.AT.VARIABLES
      RETURN


CHECK.FOR.SYNONYMS: 
      LOCATE ITEM IN SYNONYM.LIST<1> SETTING SYNONYM.POS THEN
         ITEM = SYNONYM.VALUE.LIST<SYNONYM.POS>
      END
      RETURN


CHECK.LIT.DICT.EVAL: 
      X.LIT.DICT.EVAL = ''
      X.LIT.DICT.EVAL.TYPE = ''
      VALID.VALUE = TRUE
      TEMP.ERRMSG = ORIGINAL.ITEM:' ':X.CURRENT.TYPE:' must be followed by a literal value, a dictionary field, or an EVAL expression.'
      IF (ITEM.TYPE = '') OR (ITEM = 'EVAL') THEN
         BEGIN CASE
            CASE ITEM = ''
               X.LIT.DICT.EVAL = NULL.CODE
               X.LIT.DICT.EVAL.TYPE = 'LIT'
            CASE 1
               IF ITEM = 'EVAL' THEN
                  GOSUB GET.NEXT.ITEM
                  DLMAIN.NUM.EVAL.FORMULAE += 1
                  DLMAIN.EVAL.FORMULAE(DLMAIN.NUM.EVAL.FORMULAE) = ITEM
                  X.LIT.DICT.EVAL = '$$EVAL':@VM:DLMAIN.NUM.EVAL.FORMULAE
                  X.LIT.DICT.EVAL.TYPE = 'EVAL'
               END ELSE
                  X.LIT.DICT.EVAL = ITEM
                  X.LIT.DICT.EVAL.TYPE = 'LIT'
               END
         END CASE
      END ELSE
         IF ITEM.TYPE = 'FIELD' THEN
            DICT.FIELD.NAME = ITEM
            DICT.FILE.NUM = ITEM.FIELD.FILE.NUM
            GOSUB ADD.DICT.REC
            X.LIT.DICT.EVAL = '$$DICT':@VM:WHICH.DICT.REC.CTR
            X.LIT.DICT.EVAL.TYPE = 'DICT'
         END ELSE
            VALID.VALUE = FALSE
         END
      END
      RETURN


*
   END
