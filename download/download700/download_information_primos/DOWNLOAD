*
* INFO/BASIC PROGRAM
* 11/27/90
* DWS
* TITLE ----- DOWNLOAD
*
*
* PURPOSE: CREATE A DOWNLOAD FILE FROM AN INFO FILE AND DICTIONARY
*
* This software was written by Doug Sjoquist and Dave Rotman at
* Cedarville College.  You may freely distribute this software,
* but this software is not be sold by itself or as part of any
* other software package.  A current version of the software may
* be obtained via anonymous ftp from:
*     ftp.cedarville.edu
*
* You may contact the authors by e-mail:
*      rotmand@cedarville.edu
* We will attempt to answer questions as time allows, but cannot
* guarantee the software nor our answers.
*
*
*************************************************************************
*
* Stamped: p4 rotmand, /usr/local/collive, user #4051, 06 Sep 03, 03:15PM.
* Version 7.00
*
*
*
*
*
*


      $INCLUDE I_DOWNLOAD_MAX_COMMON
      $INCLUDE I_DOWNLOAD_MAIN_COMMON
      $INCLUDE I_DOWNLOAD_DATA_COMMON
      $INCLUDE I_DOWNLOAD_WHEN_COMMON
      $INCLUDE I_DOWNLOAD_WP_COMMON
      $INCLUDE I_DOWNLOAD_DBMS_COMMON
      $INCLUDE I_DOWNLOAD_OP_SYS_COMMON
      $INCLUDE I_WHICH_DBMS
      $INCLUDE I_WHICH_OP_SYS
      $INCLUDE I_DOWNLOAD_OUT_REC_COMMON


      DIM BREAK.VALUE(DLMAX.BREAK.FIELDS)
      DIM PREV.BREAK.VALUE(DLMAX.BREAK.FIELDS)




*
*
* MAIN CONTROL
*

      CRT PROGRAM.NAME:' version ':PROGRAM.VERSION
      GOSUB SET.UP
      CALL DOWNLOAD.INIT
      CALL DOWNLOAD.PARSE
      DEBUG1OR2
      CRT 'INSIDE DOWNLOAD'
      END
      CRT 'Using input file ':DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM)
      IF DLMAIN.OUTPUT.FILE.NAME = '' THEN
         CRT 'Output to screen'
      END ELSE
         CRT 'Output to file ':DLMAIN.OUTPUT.FILE.NAME:' ':DLMAIN.OUTPUT.RECORD.NAME
      END
      CRT
      GOSUB PRE.DOWNLOADING.PROCESSING
*
* MAIN PROCESSING LOOP
*
      DONE.LIST = FALSE
      IF DLMAIN.HAVE.NO.PAGE THEN
         TURN.OFF.PAGING = @(0,0)
      END
      GOSUB GET.NEXT.RECORD
      GOSUB LOAD.RECORD
      GOSUB MOVE.NEW.DATA.TO.CURRENT
      GOSUB START.REPORT
      FOR BREAK.CTR=1 TO DLMAIN.NUM.BREAK.FIELDS
         GOSUB START.BREAK
      NEXT BREAK.CTR
*
      LOOP
      UNTIL DONE.LIST
         BREAK.POINT = ''
         FOR BREAK.CTR=2 TO DLMAIN.NUM.BREAK.FIELDS UNTIL BREAK.POINT
            IF BREAK.VALUE(BREAK.CTR) # PREV.BREAK.VALUE(BREAK.CTR) THEN
               BREAK.POINT = BREAK.CTR
            END
         NEXT BREAK.CTR
         IF BREAK.POINT THEN
            FOR BREAK.CTR=DLMAIN.NUM.BREAK.FIELDS TO BREAK.POINT STEP -1
               GOSUB FINISH.BREAK
            NEXT BREAK.CTR
         END
         GOSUB MOVE.NEW.DATA.TO.CURRENT
         IF BREAK.POINT THEN
            FOR BREAK.CTR=BREAK.POINT TO DLMAIN.NUM.BREAK.FIELDS
               GOSUB START.BREAK
            NEXT BREAK.CTR
         END
         CALL DOWNLOAD.UPDATE(BY.EXP.VALUE.CTR, BY.EXP.SUBVALUE.CTR)
         DEBUG1OR2
         CRT 'BACK INSIDE DOWNLOAD'
      END
      IF NOT(DLMAIN.DET.SUP) THEN
         CALL DOWNLOAD.PROCESS(DL.OUTR.DETAIL.OUT.REC, DETAIL.BREAK.LEVEL, BY.EXP.VALUE.CTR, BY.EXP.SUBVALUE.CTR)
         DEBUG1OR2
         CRT 'BACK INSIDE DOWNLOAD'
      END
      END
      IF NEED.NEW.RECORD THEN
         GOSUB GET.NEXT.RECORD
         IF NOT(DONE.LIST) THEN
            GOSUB LOAD.RECORD
         END
      END ELSE
         IF BY.EXP.FIELD # '' AND NOT(SELECT.LIST.IS.BY.EXP) THEN
            GOSUB GET.NEXT.BY.EXP.VALUE
         END
      END
      REPEAT
*
      FOR BREAK.CTR=DLMAIN.NUM.BREAK.FIELDS TO 1 STEP -1
         GOSUB FINISH.BREAK
      NEXT BREAK.CTR
      GOSUB FINISH.REPORT
*
      GOSUB POST.DOWNLOADING.PROCESSING
      STOP





*******************************************************************************
**
**   SET UP ROUTINES
**
*******************************************************************************
SET.UP: 
      NEW.BY.EXP.VALUE.CTR = 0
      NEW.BY.EXP.SUBVALUE.CTR = 0
      NEED.NEW.RECORD = FALSE
      GOSUB DBMS.SET.UP
      GOSUB OP.SYS.SET.UP
      GOSUB SET.UP.MISC
      $INCLUDE I_WORDPERFECT_5_0_HEADER
      $INCLUDE I_WORDPERFECT_5_1_HEADER
      $INCLUDE I_DBF_HEADER
      RETURN


SET.UP.MISC: 
      DL.OUTR.DETAIL.OUT.REC = 1
      DETAIL.BREAK.LEVEL = -1
      HEADING.BREAK.LEVEL = 0
      FOOTING.BREAK.LEVEL = 0
      RECORD.CTR = 0
      SELECT.LIST.IS.BY.EXP = FALSE
      DLMAIN.RECORD.KEY.LIST = ''
      DLMAIN.VOC.DELETE.LIST = ''
      DLMAIN.SAVEDLISTS.DELETE.LIST = ''
      RECORD.KEY.NOT.FOUND = ''
*
      NEED.NEW.RECORD = TRUE
      NEW.BY.EXP.VALUE.CTR = 1
      NUM.ASSOC.CONTROL.VALUES = 0
*
      MAT BREAK.VALUE = ''
      MAT PREV.BREAK.VALUE = ''
      RETURN






*******************************************************************************
**
**   OPERATING-SYSTEM SPECIFIC SUBROUTINES
**      AN ATTEMPT HAS BEEN MADE TO ISOLATE ALL OPERATING SYSTEM SPECIFIC
**      CHANGES TO THE FOLLOWING SET OF SUBROUTINES
**
*******************************************************************************
DBMS.SET.UP: 
      BEGIN CASE
         CASE DBMS.NAME = 'INFORMATION'
            GOSUB DBMS.INFORMATION.SET.UP
         CASE DBMS.NAME = 'UNIDATA'
            GOSUB DBMS.UNIDATA.SET.UP
         CASE DBMS.NAME = 'UNIVERSE'
            GOSUB DBMS.UNIVERSE.SET.UP
      END CASE
      RETURN

DBMS.INFORMATION.SET.UP: 
      DBMS.HEADING.GAP.OPTION = "'G'"
      OP.SYS.CHAR.ZERO = CHAR(0)
      RETURN

DBMS.UNIDATA.SET.UP: 
      DBMS.HEADING.GAP.OPTION = "'G'"
      X.TEMP = ''
      COMMENT.OUT.EXCEPT.FOR.UNIDATA X.TEMP = GETENV('ZERO_CHAR')
      IF X.TEMP = '' THEN
         OP.SYS.CHAR.ZERO = CHAR(128)
      END ELSE
         OP.SYS.CHAR.ZERO = CHAR(X.TEMP)
      END
      RETURN

DBMS.UNIVERSE.SET.UP: 
      DBMS.HEADING.GAP.OPTION = "'G'"
      OP.SYS.CHAR.ZERO = CHAR(0)
      RETURN

OP.SYS.SET.UP: 
      BEGIN CASE
         CASE OP.SYS.NAME = 'PRIMOS'
            GOSUB OP.SYS.PRIMOS.SET.UP
         CASE OP.SYS.NAME = 'UNIX'
            GOSUB OP.SYS.UNIX.SET.UP
         CASE OP.SYS.NAME = 'WINDOWS'
            GOSUB OP.SYS.WINDOWS.SET.UP
      END CASE
      RETURN

OP.SYS.PRIMOS.SET.UP: 
      RETURN

OP.SYS.UNIX.SET.UP: 
      RETURN

OP.SYS.WINDOWS.SET.UP: 
      RETURN


*
* DETERMINE IF THERE IS AN ACTIVE SELECT LIST
*
DBMS.SELECT.IS.ACTIVE: 
      DEBUG2
      CRT 'GOSUB DBMS.SELECT.IS.ACTIVE'
      END
      BEGIN CASE
         CASE DBMS.NAME = 'INFORMATION'
            GOSUB DBMS.INFORMATION.SELECT.IS.ACTIVE
         CASE DBMS.NAME = 'UNIDATA'
            GOSUB DBMS.UNIDATA.SELECT.IS.ACTIVE
         CASE DBMS.NAME = 'UNIVERSE'
            GOSUB DBMS.UNIVERSE.SELECT.IS.ACTIVE
      END CASE
      RETURN

*
* IK$SLACTIVE IS DETERMINED FROM THE INSERT FILE "SYSCOM>INFO_KEYS.INS.IBAS"
*
DBMS.INFORMATION.SELECT.IS.ACTIVE: 
      IK$SLACTIVE = 1
      COMMENT.OUT.EXCEPT.FOR.INFORMATION SELECT.IS.ACTIVE = SELECTINFO(DLMAIN.FROM.UNIT,IK$SLACTIVE)
      RETURN

DBMS.UNIDATA.SELECT.IS.ACTIVE: 
      SELECT.IS.ACTIVE = FALSE
      IF DLMAIN.FROM.UNIT = 0 AND @SYSTEM.RETURN.CODE > 0 THEN
         SELECT.IS.ACTIVE = TRUE
      END
      RETURN

DBMS.UNIVERSE.SELECT.IS.ACTIVE: 
      SELECT.IS.ACTIVE = FALSE
      IF DLMAIN.FROM.UNIT = 0 AND @SYSTEM.RETURN.CODE > 0 THEN
         SELECT.IS.ACTIVE = TRUE
      END
      RETURN

OP.SYS.FINISH.FILE: 
      DEBUG2
      CRT 'GOSUB OP.SYS.FINISH.FILE'
      END
      BEGIN CASE
         CASE OP.SYS.NAME = 'PRIMOS'
            GOSUB OP.SYS.PRIMOS.FINISH.FILE
         CASE OP.SYS.NAME = 'UNIX'
            GOSUB OP.SYS.UNIX.FINISH.FILE
         CASE OP.SYS.NAME = 'WINDOWS'
            GOSUB OP.SYS.WINDOWS.FINISH.FILE
      END CASE
      RETURN


*
*
* FINISH UP WHATEVER IS IN THE BUFFER
*   IF THERE IS AN ODD NUMBER OF CHARACTERS LEFT TO WRITE,
*   PAD THE END WITH THE NULL CHARACTER 0
*
OP.SYS.PRIMOS.FINISH.FILE: 
      FLUSH.BUFFER = TRUE
      CALL DOWNLOAD.OP.SYS.WRITE('', FLUSH.BUFFER)
      DEBUG2
      CRT 'BACK INSIDE DOWNLOAD'
      END
      CLOSE.ERRMSG = ''
      CALL PRIMOS.CLOSE.FILE(OP.SYS.FILE.FUNIT, OP.SYS.FILE.PATH.NAME, CLOSE.ERRMSG)
      DEBUG2
      CRT 'BACK INSIDE DOWNLOAD'
      END
      IF CLOSE.ERRMSG THEN
         DLMAIN.ERRMSG<-1> = 'Error in closing "':OP.SYS.FILE.PATH.NAME:'"'
         DLMAIN.ERRMSG<-1> = '   ':CLOSE.ERRMSG
         DLMAIN.FATAL.ERROR = TRUE
      END
      RETURN

OP.SYS.UNIX.FINISH.FILE: 
      COMMENT.OUT.EXCEPT.FOR.INFORMATION      OSCLOSE OP.SYS.FILE.FUNIT
      COMMENT.OUT.EXCEPT.FOR.UNIDATA          OSCLOSE OP.SYS.FILE.FUNIT
      COMMENT.OUT.EXCEPT.FOR.UNIVERSE         CLOSESEQ OP.SYS.FILE.FUNIT
      RETURN


OP.SYS.WINDOWS.FINISH.FILE: 
      COMMENT.OUT.EXCEPT.FOR.INFORMATION      OSCLOSE OP.SYS.FILE.FUNIT
      COMMENT.OUT.EXCEPT.FOR.UNIDATA          OSCLOSE OP.SYS.FILE.FUNIT
      COMMENT.OUT.EXCEPT.FOR.UNIVERSE         CLOSESEQ OP.SYS.FILE.FUNIT
      RETURN


*******************************************************************************
**
**   PRE DOWNLOADING PROCESSING, AFTER PROCESSING COMMAND LINE, BUT
**       BEFORE PROCESSING DATA RECORDS
**
*******************************************************************************
PRE.DOWNLOADING.PROCESSING: 
      DEBUG2
      CRT 'GOSUB PRE.DOWNLOADING.PROCESSING'
      CRT 'DLMAIN.FORMAT ':DLMAIN.FORMAT
      END
      IF DLMAIN.RECORD.KEY.LIST # '' THEN
         GOSUB PROCESS.DLMAIN.RECORD.KEY.LIST
      END
      GOSUB CHECK.IF.SELECT.SAMPLE.NEEDED
      IF DLMAIN.FATAL.ERROR THEN
         GOTO HAVE.FATAL.ERROR
      END
      BEGIN CASE
         CASE DLMAIN.FORMAT = 'WP50'
            IF DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS' THEN
               FLUSH.BUFFER = FALSE
               CALL DOWNLOAD.OP.SYS.WRITE(K.WP50.HEADER, FLUSH.BUFFER)
               DEBUG2
               CRT 'BACK INSIDE DOWNLOAD'
            END
         END
         K.WORDPERFECT.DATA.SEP = K.WP50.DATA.SEP
         K.WORDPERFECT.END.RECORD = K.WP50.END.RECORD
         K.WORDPERFECT.FIELD.SEP = K.WP50.FIELD.SEP
      CASE DLMAIN.FORMAT = 'WP51'
         GOSUB PREDL.BUILD.WP51.INFO
         IF DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS' THEN
            FLUSH.BUFFER = FALSE
            CALL DOWNLOAD.OP.SYS.WRITE(K.WP51.HEADER, FLUSH.BUFFER)
            DEBUG2
            CRT 'BACK INSIDE DOWNLOAD'
         END
      END
      K.WORDPERFECT.DATA.SEP = K.WP51.DATA.SEP
      K.WORDPERFECT.END.RECORD = K.WP51.END.RECORD
      K.WORDPERFECT.FIELD.SEP = K.WP51.FIELD.SEP
      CASE DLMAIN.FORMAT = 'DBF'
         GOSUB PREDL.BUILD.DBF.INFO
         IF DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS' THEN
            FLUSH.BUFFER = TRUE
            CALL DOWNLOAD.OP.SYS.WRITE(DBF.BUFFER, FLUSH.BUFFER)
            DEBUG2
            CRT 'BACK INSIDE DOWNLOAD'
         END
      END
      CASE DLMAIN.FORMAT = 'HTML'
         DETAIL.LINES = ''
         IF NOT(DLMAIN.APPEND) THEN
            DETAIL.LINES = '<HTML>'
            DETAIL.LINES<-1> = '<HEADING>'
            DETAIL.LINES<-1> = '<TITLE>'
            X.LIT.DICT.EVAL = DL.OUTR.DOCUMENT.TITLE
            GOSUB GET.LIT.DICT.EVAL
            DETAIL.LINES<-1> = X.LIT.DICT.EVAL.VALUE
            DETAIL.LINES<-1> = '</TITLE>'
            DETAIL.LINES<-1> = '</HEADING>'
            X.LIT.DICT.EVAL = DL.OUTR.DOCUMENT.BODY
            GOSUB GET.LIT.DICT.EVAL
            IF X.LIT.DICT.EVAL.VALUE = '' THEN
               DETAIL.LINES<-1> = '<BODY>'
            END ELSE
               DETAIL.LINES<-1> = '<BODY ':X.LIT.DICT.EVAL.VALUE:'>'
            END
         END
         X.LIT.DICT.EVAL = DL.OUTR.DOCUMENT.TOP
         GOSUB GET.LIT.DICT.EVAL
         IF X.LIT.DICT.EVAL.VALUE NE '' THEN
            DETAIL.LINES<-1> = X.LIT.DICT.EVAL.VALUE
         END
         IF DL.OUTR.DOCUMENT.TABLE = '' THEN
            DETAIL.LINES<-1> = '<TABLE BORDER="1">'
         END ELSE
            X.LIT.DICT.EVAL = DL.OUTR.DOCUMENT.TABLE
            GOSUB GET.LIT.DICT.EVAL
            DETAIL.LINES<-1> = '<TABLE ':X.LIT.DICT.EVAL.VALUE:'>'
         END
         GOSUB PRINT.LINES
      CASE DLMAIN.FORMAT = 'XML'
         IF (DL.OUTR.XML.VERSION NE '') AND NOT(DLMAIN.APPEND) THEN
            DETAIL.LINES = DL.OUTR.XML.VERSION
            GOSUB PRINT.LINES
         END
         IF DLMAIN.HEADING.OUT.REC THEN
            CALL DOWNLOAD.PROCESS(DLMAIN.HEADING.OUT.REC, HEADING.BREAK.LEVEL, BY.EXP.VALUE.CTR, BY.EXP.SUBVALUE.CTR)
            DEBUG1OR2
            CRT 'BACK INSIDE DOWNLOAD'
         END
      END
      DETAIL.LINES = '<'
      X.LIT.DICT.EVAL = DL.OUTR.XML.ROOT.NAME
      GOSUB GET.LIT.DICT.EVAL
      X.SAVE.XML.ROOT.NAME = X.LIT.DICT.EVAL.VALUE
      DETAIL.LINES := X.LIT.DICT.EVAL.VALUE
      IF DL.OUTR.XML.ROOT.ATTRIBUTE THEN
         X.LIT.DICT.EVAL = DL.OUTR.XML.ROOT.ATTRIBUTE
         GOSUB GET.LIT.DICT.EVAL
         DETAIL.LINES := ' ':X.LIT.DICT.EVAL.VALUE
      END
      DETAIL.LINES := '>'
      GOSUB PRINT.LINES
      CASE DLMAIN.FORMAT = 'DIF'
         DETAIL.LINES = 'TABLE'
         DETAIL.LINES<-1> = '0,1'
         DETAIL.LINES<-1> = '"Download"'
         DETAIL.LINES<-1> = 'VECTORS'
         DETAIL.LINES<-1> = '0,':DL.OUTR.NUM.OUT.FIELDS(DL.OUTR.DETAIL.OUT.REC)
         DETAIL.LINES<-1> = '""'
         DETAIL.LINES<-1> = 'TUPLES'
         DETAIL.LINES<-1> = '0,':@SYSTEM.RETURN.CODE
         DETAIL.LINES<-1> = '""'
         DETAIL.LINES<-1> = 'DATA'
         DETAIL.LINES<-1> = '0,0'
         DETAIL.LINES<-1> = '""'
         DETAIL.LINES<-1> = '-1,0'
         GOSUB PRINT.LINES
      CASE 1
      END CASE
      RETURN

*
* BUILD WP51 HEADER INFO (WITH FIELD NAMES)
*

PREDL.BUILD.WP51.INFO: 
      K.WP51.HEADER = K.WP51.HEADER.A
      IF DLMAIN.HEADING.OUT.REC THEN
      DLF.END = DL.OUTR.NUM.OUT.FIELDS(DLMAIN.HEADING.OUT.REC)
      END ELSE
      DLF.END = DL.OUTR.NUM.OUT.FIELDS(DL.OUTR.DETAIL.OUT.REC)
      END
      FOR DLF.CTR = 1 TO DLF.END
         COL.HDG.VALUE = DL.OUTR.COL.HDG.LIST(DL.OUTR.DETAIL.OUT.REC)<DLF.CTR>
         IF COL.HDG.VALUE THEN
            X.VALUE = COL.HDG.VALUE
            K.WP51.HEADER := X.VALUE
         END ELSE
            IF DLMAIN.HEADING.OUT.REC THEN
               OUT.CTR.VALUE = DL.OUTR.CTR.LIST(DLMAIN.HEADING.OUT.REC)<DLF.CTR>
               IF OUT.CTR.VALUE GT 0 THEN
                  X.VALUE = DLMAIN.LITERAL.VALUE.LIST<OUT.CTR.VALUE>
               END ELSE
                  X.VALUE = 'DLField':DLF.CTR
               END
               K.WP51.HEADER := X.VALUE
            END ELSE
               IF DL.OUTR.TYPE.LIST(DL.OUTR.DETAIL.OUT.REC)<DLF.CTR> = 'FIELD' THEN
                  K.WP51.HEADER := DL.OUTR.FIELD.LIST(DL.OUTR.DETAIL.OUT.REC)<DLF.CTR>
               END ELSE
                  K.WP51.HEADER := 'DLField':DLF.CTR
               END
            END
         END
         K.WP51.HEADER := K.WP51.HEADER.B
      NEXT DLF.CTR
      K.WP51.HEADER := K.WP51.HEADER.C
*
      K.WP51.END.RECORD = K.WP51.END.RECORD.A
      LOW.BYTE = MOD(DLF.END,256)
      IF LOW.BYTE = 0 THEN
         LOW.CHAR = OP.SYS.CHAR.ZERO
      END ELSE
         LOW.CHAR = CHAR(LOW.BYTE)
      END
      HIGH.BYTE = INT(DLF.END/256)
      IF HIGH.BYTE = 0 THEN
         HIGH.CHAR = OP.SYS.CHAR.ZERO
      END ELSE
         HIGH.CHAR = CHAR(HIGH.BYTE)
      END
      K.WP51.END.RECORD := LOW.CHAR:HIGH.CHAR
      K.WP51.END.RECORD := K.WP51.END.RECORD.B
      K.WP51.END.RECORD := OP.SYS.CHAR.ZERO:OP.SYS.CHAR.ZERO          ;* DUMMY PAGE #
      K.WP51.END.RECORD := K.WP51.END.RECORD.C
      RETURN



PREDL.BUILD.DBF.INFO: 
      DBF.BUFFER = ''
      DBF.BUFFER.LOC = 0

      DBF.REC.LEN = 0
      FOR FIELD.CTR = 1 TO DL.OUTR.NUM.OUT.FIELDS(DL.OUTR.DETAIL.OUT.REC)
         LENGTH.VALUE = DL.OUTR.LENGTH.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
         IF LENGTH.VALUE = '' THEN
            LENGTH.VALUE = DBF.DEFAULT.LENGTH.VALUE
         END
         DBF.REC.LEN += LENGTH.VALUE
      NEXT FIELD.CTR
      DBF.NUM.RECS = @SYSTEM.RETURN.CODE
      GOSUB DBF.WRITE.HEADER

      DBF.FIELD.NAME.LIST = ''
      FOR FIELD.CTR=1 TO DL.OUTR.NUM.OUT.FIELDS(DL.OUTR.DETAIL.OUT.REC)
         FIELD.NAME = DL.OUTR.FIELD.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
         NUMERIC.FLAG = DL.OUTR.NUMERIC.FLAG.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
         LENGTH.VALUE = DL.OUTR.LENGTH.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
         IF LENGTH.VALUE = '' THEN
            LENGTH.VALUE = DBF.DEFAULT.LENGTH.VALUE
         END
         CONV.VALUE = DL.OUTR.FIELD.CONV.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
         FMT.VALUE = DL.OUTR.FIELD.FMT.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR>
         IF NUMERIC.FLAG THEN
            IF CONV.VALUE[1,1] = 'D' THEN
               FIELD.TYPE = 'D'
               FIELD.LEN = 8
               FIELD.DEC = 0
               DL.OUTR.FIELD.CONV.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR> = 'DBF.DATE'
               DL.OUTR.FIELD.FMT.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR> = '8R'
               DL.OUTR.LENGTH.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR> = 8
            END ELSE
               FIELD.TYPE = 'N'
               FIELD.LEN = LENGTH.VALUE
               IF INDEX(CONV.VALUE,'MD',1) > 0 THEN
                  FIELD.DEC = CONV.VALUE[INDEX(CONV.VALUE,'MD',1)+2,1]
               END ELSE
                  FIELD.DEC = 0
               END
            END
         END ELSE
            IF CONV.VALUE[1,1] = 'D' THEN
               FIELD.TYPE = 'D'
               FIELD.LEN = 8
               FIELD.DEC = 0
               DL.OUTR.FIELD.CONV.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR> = 'DBF.DATE'
               DL.OUTR.FIELD.FMT.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR> = '8R'
               DL.OUTR.LENGTH.LIST(DL.OUTR.DETAIL.OUT.REC)<FIELD.CTR> = 8
            END ELSE
               FIELD.TYPE = 'C'
               FIELD.LEN = LENGTH.VALUE
               FIELD.DEC = 0
            END
         END
         GOSUB DBF.WRITE.FIELD.NAME
      NEXT FIELD.CTR
      GOSUB DBF.WRITE.PRE.DATA.MARK
      RETURN


DBF.WRITE.HEADER: 
      DBF.DATA.REC = CHAR(3):CHAR(91):CHAR(10):CHAR(24)
      MAX.NUM.FIRST.WORD = 256 * 256
      ORIG.NUM = MOD(DBF.NUM.RECS,MAX.NUM.FIRST.WORD)
      GOSUB DBF.ADD.NUM.TO.DBF.DATA.REC
      ORIG.NUM = INT(DBF.NUM.RECS/MAX.NUM.FIRST.WORD)
      GOSUB DBF.ADD.NUM.TO.DBF.DATA.REC
      ORIG.NUM = DL.OUTR.NUM.OUT.FIELDS(DL.OUTR.DETAIL.OUT.REC) * 32 + 33
      GOSUB DBF.ADD.NUM.TO.DBF.DATA.REC
      ORIG.NUM = DBF.REC.LEN
      GOSUB DBF.ADD.NUM.TO.DBF.DATA.REC
      ORIG.NUM = 0
      FOR CTR=1 TO 10
         GOSUB DBF.ADD.NUM.TO.DBF.DATA.REC
      NEXT CTR
      GOSUB DBF.WRITE.RECORD
      RETURN

DBF.ADD.NUM.TO.DBF.DATA.REC: 
      BYTE1 = MOD(ORIG.NUM,256)
      BYTE2 = INT(ORIG.NUM/256)
      DBF.DATA.REC := CHAR(BYTE1):CHAR(BYTE2)
      RETURN


DBF.WRITE.RECORD: 
      DBF.BUFFER := DBF.DATA.REC
      LOOP
         LEN.BUFF = LEN(DBF.BUFFER)
      UNTIL LEN.BUFF < DBF.BUF.SIZE
         WR.BUFF = DBF.BUFFER[1,DBF.BUF.SIZE]
         DBF.BUFFER = DBF.BUFFER[DBF.BUF.SIZE+1,LEN.BUFF]
         FLUSH.BUFFER = FALSE
         CALL DOWNLOAD.OP.SYS.WRITE(WR.BUFF, FLUSH.BUFFER)
         DEBUG2
         CRT 'BACK INSIDE DOWNLOAD'
      END
      DBF.BUFFER.LOC += LEN(WR.BUFF)
      REPEAT
      RETURN

DBF.WRITE.FIELD.NAME: 
      DBF.DATA.REC = STR(CHAR(0),32)
      DBF.USE.FIELD.NAME = FIELD.NAME[1,10]
      DBF.HAVE.UNIQUE.NAME = @FALSE
      LOOP
         LOCATE DBF.USE.FIELD.NAME IN DBF.FIELD.NAME.LIST<1,1> SETTING DBF.POS ELSE
            DBF.HAVE.UNIQUE.NAME = @TRUE
         END
      UNTIL DBF.HAVE.UNIQUE.NAME OR LEN(DBF.USE.FIELD.NAME) < 1
         DBF.USE.FIELD.NAME = DBF.USE.FIELD.NAME[1,LEN(DBF.USE.FIELD.NAME)-1]
      REPEAT
      IF LEN(DBF.USE.FIELD.NAME) < 1 THEN
         DBF.USE.FIELD.NAME = 'FIELD':FMT(FIELD.CTR,'5"0"R')
      END
      DBF.FIELD.NAME.LIST<1,-1> = DBF.USE.FIELD.NAME
      DBF.DATA.REC[1,10] = DBF.USE.FIELD.NAME
      DBF.DATA.REC[12,1] = FIELD.TYPE
      DBF.DATA.REC[17,1] = CHAR(FIELD.LEN)
      DBF.DATA.REC[18,1] = CHAR(FIELD.DEC)
      GOSUB DBF.WRITE.RECORD
      RETURN

DBF.WRITE.PRE.DATA.MARK: 
      DBF.DATA.REC = CHAR(13):' '
      GOSUB DBF.WRITE.RECORD
      RETURN





*
*
* PRINT LINES
*
PRINT.LINES: 
      DEBUG2
      CRT 'GOSUB PRINT.LINES'
      END
      DEBUG5
      CRT 'DETAIL.LINES: ':DETAIL.LINES
      END
      LOOP
         REMOVE PRINT.LINE FROM DETAIL.LINES SETTING DETAIL.LINES.DELIM
         BEGIN CASE
            CASE DLMAIN.PRINT.METHOD = 'CRT'
               CRT PRINT.LINE
            CASE DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS'
               FLUSH.BUFFER = FALSE
               CALL DOWNLOAD.OP.SYS.WRITE(PRINT.LINE, FLUSH.BUFFER)
               DEBUG2
               CRT 'BACK INSIDE DOWNLOAD'
            END
         CASE 1
            GOSUB DO.WRITESEQ
      END CASE
      UNTIL DETAIL.LINES.DELIM = 0
      REPEAT
      RETURN


*
*
* USE 'WRITESEQ' TO WRITE A LINE
*
DO.WRITESEQ: 
      DEBUG2
      CRT 'GOSUB DO.WRITESEQ'
      END
      WRITESEQ PRINT.LINE TO DLMAIN.F.OUTPUT.FILE ELSE
         DLMAIN.ERRMSG<-1> = 'Can not write to "':DLMAIN.OUTPUT.FILE.NAME:'" "':DLMAIN.OUTPUT.RECORD.NAME:'" for record "':@ID:'"'
         DLMAIN.FATAL.ERROR = TRUE
      END
      RETURN



*
*
* PROCESS RECORD.KEY LIST
*
PROCESS.DLMAIN.RECORD.KEY.LIST: 
      DEBUG2
      CRT 'GOSUB PROCESS.DLMAIN.RECORD.KEY.LIST'
      END
      IF DLMAIN.FROM.UNIT = 0 THEN
         READLIST ORIGINAL.LIST ELSE
            ORIGINAL.LIST = ''
         END
      END ELSE
         READLIST ORIGINAL.LIST FROM DLMAIN.FROM.UNIT ELSE
            ORIGINAL.LIST = ''
         END
      END
      CONVERT @IM TO @FM IN ORIGINAL.LIST
      IF ORIGINAL.LIST = '' THEN
         NEW.RECORD.LIST = DLMAIN.RECORD.KEY.LIST
      END ELSE
         NEW.RECORD.LIST = ''
         DLMAIN.RECORD.KEY.LIST = DLMAIN.RECORD.KEY.LIST
         LOOP
            REMOVE RECORD.KEY FROM DLMAIN.RECORD.KEY.LIST SETTING DELIM.RECORD.KEY
            LOCATE RECORD.KEY IN ORIGINAL.LIST<1> SETTING POS THEN
               NEW.RECORD.LIST<-1> = RECORD.KEY
            END ELSE
               RECORD.KEY.NOT.FOUND<-1> = RECORD.KEY
            END
         UNTIL DELIM.RECORD.KEY = 0
         REPEAT
      END
      FORMLIST NEW.RECORD.LIST TO DLMAIN.FROM.UNIT
      NUM.DLMAIN.RECORD.KEY.LIST = @SYSTEM.RETURN.CODE
      RETURN


*
*
* IF USING A SAMPLE AND THERE IS NO ACTIVE LIST, THEN SELECT A SAMPLE
*
CHECK.IF.SELECT.SAMPLE.NEEDED: 
      DEBUG2
      CRT 'GOSUB CHECK.IF.SELECT.SAMPLE.NEEDED'
      END
      IF DLMAIN.SAMPLE.SIZE = '' THEN
         RETURN
      END
      GOSUB DBMS.SELECT.IS.ACTIVE
      IF SELECT.IS.ACTIVE THEN
         RETURN
      END
      SELECT.COMMAND = 'SELECT ':DLMAIN.INFO.FILE.NAME.PART.1(PRIMARY.FILE.NUM):' ':DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM)
      SELECT.COMMAND := ' SAMPLE ':DLMAIN.SAMPLE.SIZE:' TO ':DLMAIN.FROM.UNIT
      EXECUTE SELECT.COMMAND
      RETURN




*******************************************************************************
**
**   DATA RECORD PROCESSING SECTION
**
*******************************************************************************


*
*
* START REPORT
*
START.REPORT: 
      DEBUG2
      CRT 'GOSUB START.REPORT'
      END
      IF DLMAIN.HEADING.OUT.REC THEN
         OKAY.LIST = 'COMMA QUOTE DIF FIXED HTML TAB'
         OKAY.LIST.DISPLAY = OKAY.LIST
         CONVERT ' ' TO @VM IN OKAY.LIST
         LOCATE DLMAIN.FORMAT IN OKAY.LIST<1,1> SETTING OKAY.POS THEN
            CALL DOWNLOAD.PROCESS(DLMAIN.HEADING.OUT.REC, HEADING.BREAK.LEVEL, BY.EXP.VALUE.CTR, BY.EXP.SUBVALUE.CTR)
            DEBUG1OR2
            CRT 'BACK INSIDE DOWNLOAD'
         END
      END
      END
      RETURN


*
*
* START BREAK
*
START.BREAK: 
      DATA.TOTAL(BREAK.CTR) = ''
      DATA.COUNT(BREAK.CTR) = ''
      FOR WHICH.DICT.RECS = 1 TO DL.DATA.NUM.DICT.RECS
         DATA.MIN(BREAK.CTR)<WHICH.DICT.RECS> = CHAR(255)
      NEXT WHICH.DICT.RECS
      DATA.MAX(BREAK.CTR) = ''
      OUT.REC.CTR = DLMAIN.BREAK.HEADING.OUT.REC.LIST<BREAK.CTR>
      IF OUT.REC.CTR THEN
         CALL DOWNLOAD.PROCESS(OUT.REC.CTR, BREAK.CTR, BY.EXP.VALUE.CTR, BY.EXP.SUBVALUE.CTR)
         DEBUG1OR2
         CRT 'BACK INSIDE DOWNLOAD'
      END
      END
      PREV.BREAK.VALUE(BREAK.CTR) = BREAK.VALUE(BREAK.CTR)
      RETURN


*
*
* LOAD RECORD & INFO
*
LOAD.RECORD: 
      IF BY.EXP.FIELD # '' THEN
         IF SELECT.LIST.IS.BY.EXP THEN
            NEED.NEW.RECORD = TRUE
            NEW.BY.EXP.VALUE.CTR = DLMAIN.SELECT.LIST.VALUE.CTR
            NEW.BY.EXP.SUBVALUE.CTR = DLMAIN.SELECT.LIST.SUBVALUE.CTR
         END ELSE
            GOSUB GET.NEXT.BY.EXP.VALUE
         END
      END ELSE
         NEED.NEW.RECORD = TRUE
      END
*
* SKIP BREAK.CTR = 1 (CONTROL FOOTING ALL or FINAL)
*
      IF NOT(DONE.LIST) THEN
         FOR BREAK.CTR=2 TO DLMAIN.NUM.BREAK.FIELDS
            WHICH.DICT.REC.CTR = DLMAIN.BREAK.DICT.CTR.LIST<BREAK.CTR>
            PART.OF.ASSOC.VALUE = DL.DATA.DICT.PART.OF.ASSOC.LIST(WHICH.DICT.REC.CTR)
            IF BY.EXP.FIELD # '' AND PART.OF.ASSOC.VALUE THEN
               DATA.FIELD = DL.DATA.NEW.DATA.ITEMS(WHICH.DICT.REC.CTR)
               BREAK.VALUE(BREAK.CTR) = DATA.FIELD<1,NEW.BY.EXP.VALUE.CTR,NEW.BY.EXP.SUBVALUE.CTR>
            END ELSE
               BREAK.VALUE(BREAK.CTR) = DL.DATA.NEW.DATA.ITEMS(WHICH.DICT.REC.CTR)
            END
         NEXT BREAK.CTR
      END
      RETURN


*
*
* MOVE NEW RECORD TO CURRENT DATA ITEMS
*
MOVE.NEW.DATA.TO.CURRENT: 
      MAT DL.DATA.DATA.ITEMS = MAT DL.DATA.NEW.DATA.ITEMS
      MAT SUBR.RET.VALUES = MAT NEW.SUBR.RET.VALUES
      BY.EXP.VALUE.CTR = NEW.BY.EXP.VALUE.CTR
      BY.EXP.SUBVALUE.CTR = NEW.BY.EXP.SUBVALUE.CTR
      RETURN


*
*
* GET NEXT RECORD
*
GET.NEXT.RECORD: 
      RECORD.OKAY = FALSE
      LOOP
      UNTIL RECORD.OKAY OR DONE.LIST
         IF DLMAIN.FROM.UNIT = 0 THEN
            READNEXT SELECT.LIST.ID ELSE DONE.LIST = TRUE
         END ELSE
            READNEXT SELECT.LIST.ID FROM DLMAIN.FROM.UNIT ELSE DONE.LIST = TRUE
         END
         IF DLMAIN.SAMPLE.SIZE # '' AND RECORD.CTR >= DLMAIN.SAMPLE.SIZE THEN
            DONE.LIST = TRUE
         END
         IF DLMAIN.FATAL.ERROR THEN
            DONE.LIST = TRUE
         END
         IF NOT(DONE.LIST) THEN
            RECORD.CTR += 1
            IF DLMAIN.DISPLAY.COUNT THEN
               IF MOD(RECORD.CTR,DLMAIN.PROGRESS.INTERVAL) = 0 THEN
                  CRT '*':
                  IF MOD(RECORD.CTR,50*DLMAIN.PROGRESS.INTERVAL) = 0 THEN
                     CRT FMT(RECORD.CTR,'8R')
                  END
               END
            END
            GOSUB SPLIT.SELECT.LIST.ID
            GOSUB READ.RECORD
            IF RECORD.OKAY THEN
               CALL DOWNLOAD.LOAD
               DEBUG1OR2
               CRT 'BACK INSIDE DOWNLOAD'
            END
            NEW.BY.EXP.VALUE.CTR = 0
            NEW.BY.EXP.SUBVALUE.CTR = 0
            NEED.NEW.RECORD = FALSE
         END
         IF MOD(RECORD.CTR,DLMAIN.WRITE.INTERVAL) = 0 THEN
            IF DLMAIN.WRITE.SLEEP.TIME GT 0 THEN
               CRT
               CRT OCONV(TIME(),'MTHS'):' Sleeping ':DLMAIN.WRITE.SLEEP.TIME:' seconds...'
               SLEEP DLMAIN.WRITE.SLEEP.TIME
            END
         END
      END
      REPEAT
      RETURN


*
*
* GET NEXT BY.EXP VALUE
*
GET.NEXT.BY.EXP.VALUE: 
      BY.EXP.MATCH.FOUND = FALSE
      LOOP
         NEW.BY.EXP.VALUE.CTR += 1
         IF NEW.BY.EXP.VALUE.CTR <= NUM.ASSOC.CONTROL.VALUES THEN
            IF WHEN.RESULT.LIST<NEW.BY.EXP.VALUE.CTR> OR WHEN.FIELD.LIST = '' THEN
               BY.EXP.MATCH.FOUND = TRUE
            END
         END
      UNTIL NEW.BY.EXP.VALUE.CTR > NUM.ASSOC.CONTROL.VALUES OR BY.EXP.MATCH.FOUND
      REPEAT
      IF BY.EXP.MATCH.FOUND THEN
         IF NEW.BY.EXP.VALUE.CTR >= NUM.ASSOC.CONTROL.VALUES THEN
            NEED.NEW.RECORD = @TRUE
         END
         RETURN
      END
      LOOP
         GOSUB GET.NEXT.RECORD
         IF NOT(DONE.LIST) THEN
            GOSUB LOAD.RECORD
            NEW.BY.EXP.VALUE.CTR = 0
            LOOP
               NEW.BY.EXP.VALUE.CTR += 1
               IF NEW.BY.EXP.VALUE.CTR <= NUM.ASSOC.CONTROL.VALUES THEN
                  IF WHEN.RESULT.LIST<NEW.BY.EXP.VALUE.CTR> OR WHEN.FIELD.LIST = '' THEN
                     BY.EXP.MATCH.FOUND = TRUE
                  END
               END
            UNTIL NEW.BY.EXP.VALUE.CTR > NUM.ASSOC.CONTROL.VALUES OR BY.EXP.MATCH.FOUND
            REPEAT
         END
      UNTIL DONE.LIST OR BY.EXP.MATCH.FOUND
      REPEAT
      RETURN


*
* SPLIT SELECT.LIST.ID (COULD BE BY.EXP SELECT)
*
SPLIT.SELECT.LIST.ID: 
      DEBUG2
      CRT 'GOSUB SPLIT.SELECT.LIST.ID'
      CRT 'SELECT.LIST.ID: ':SELECT.LIST.ID
      END
      @ID = SELECT.LIST.ID<1,1,1>
      IF BY.EXP.FIELD = '' THEN
         DLMAIN.SELECT.LIST.VALUE.CTR = ''
         DLMAIN.SELECT.LIST.SUBVALUE.CTR = ''
      END ELSE
         DLMAIN.SELECT.LIST.VALUE.CTR = SELECT.LIST.ID<1,2,1>
         DLMAIN.SELECT.LIST.SUBVALUE.CTR = SELECT.LIST.ID<1,3,1>
         IF DLMAIN.SELECT.LIST.VALUE.CTR # '' THEN
            SELECT.LIST.IS.BY.EXP = TRUE
         END
      END
      RETURN

*
*
* READ RECORD
*
READ.RECORD: 
      DEBUG2
      CRT 'GOSUB READ.RECORD'
      CRT 'PRIMARY.FILE.NUM ':PRIMARY.FILE.NUM
      CRT '@ID ':@ID
      END
      READ @RECORD FROM DLMAIN.F.INFO.FILE(PRIMARY.FILE.NUM), @ID THEN
         RECORD.OKAY = TRUE
      END ELSE
         RECORD.OKAY = FALSE
         RECORD.KEY.NOT.FOUND<-1> = @ID
      END
      DLMAIN.RECORD = @RECORD
      DLMAIN.RECORD.ID = @ID
      RETURN


*
*
* FINISH BREAK
*
FINISH.BREAK: 
      OUT.REC.CTR = DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.CTR>
      IF OUT.REC.CTR THEN
         CALL DOWNLOAD.PROCESS(OUT.REC.CTR, BREAK.CTR, BY.EXP.VALUE.CTR, BY.EXP.SUBVALUE.CTR)
         DEBUG1OR2
         CRT 'BACK INSIDE DOWNLOAD'
      END
      END
      RETURN


*
*
* FINISH REPORT
*
FINISH.REPORT: 
      DEBUG2
      CRT 'GOSUB FINISH.REPORT'
      END
      IF DLMAIN.FOOTING.OUT.REC THEN
         CALL DOWNLOAD.PROCESS(DLMAIN.FOOTING.OUT.REC, FOOTING.BREAK.LEVEL, BY.EXP.VALUE.CTR, BY.EXP.SUBVALUE.CTR)
         DEBUG1OR2
         CRT 'BACK INSIDE DOWNLOAD'
      END
      END
      IF DLMAIN.FORMAT = 'HTML' THEN
         DETAIL.LINES = '</TABLE>'
         IF DL.OUTR.DOCUMENT.BOTTOM # '' THEN
            X.LIT.DICT.EVAL = DL.OUTR.DOCUMENT.BOTTOM
            GOSUB GET.LIT.DICT.EVAL
            DETAIL.LINES<-1> = X.LIT.DICT.EVAL.VALUE
         END
         GOSUB PRINT.LINES
      END
      GOSUB FINISH.OUTPUTING
      RETURN




*******************************************************************************
**
**   POST DOWNLOADING: AFTER ALL DATA RECORDS HAVE BEEN PROCESSED
**
*******************************************************************************
POST.DOWNLOADING.PROCESSING: 
      DEBUG2
      CRT 'GOSUB POST.DOWNLOADING.PROCESSING'
      END
      CRT
      CRT RECORD.CTR:' record':
      IF RECORD.CTR # 1 THEN
         CRT 's':
      END
      CRT ' processed.'
      GOSUB CHECK.MISSING.RECORD.KEYS
      IF DLMAIN.ERRMSG AND DLMAIN.PRINT.ERRORS THEN
         GOSUB PRINT.ERROR.MESSAGES
      END
      IF DLMAIN.PRINT.LAYOUT THEN
         GOSUB PRINT.LAYOUT.SUB
      END
      CLEARSELECT DLMAIN.FROM.UNIT
      IF DLMAIN.VOC.DELETE.LIST # '' THEN
         GOSUB DELETE.VOC.RECORDS
      END
      IF DLMAIN.SAVEDLISTS.DELETE.LIST # '' THEN
         GOSUB DELETE.SAVEDLISTS.RECORDS
      END
      RETURN

*
*
* PROCESS MISSING RECORD.KEYS
*
CHECK.MISSING.RECORD.KEYS: 
      DEBUG2
      CRT 'GOSUB CHECK.MISSING.RECORD.KEYS'
      END
      IF RECORD.KEY.NOT.FOUND = '' THEN
         RETURN
      END
      RECORD.KEY.NOT.FOUND = RECORD.KEY.NOT.FOUND
      LOOP
         REMOVE RECORD.KEY FROM RECORD.KEY.NOT.FOUND SETTING DELIM.RECORD.KEY
         CRT '"':RECORD.KEY:'" not found.'
      UNTIL DELIM.RECORD.KEY = 0
      REPEAT
      RETURN



*
*
* FINISH DOWNLOADING
*
FINISH.OUTPUTING: 
      BEGIN CASE
         CASE DLMAIN.FORMAT = 'DIF'
            DETAIL.LINES = 'EOD'
            GOSUB PRINT.LINES
         CASE DLMAIN.FORMAT = 'HTML'
            DETAIL.LINES = '</BODY>'
            DETAIL.LINES<-1> = '</HTML>'
            GOSUB PRINT.LINES
         CASE DLMAIN.FORMAT = 'XML'
            DETAIL.LINES = '</':X.SAVE.XML.ROOT.NAME:'>'
            GOSUB PRINT.LINES
         CASE 1
            NULL
      END CASE
      BEGIN CASE
         CASE DLMAIN.PRINT.METHOD = 'WRITE.OP.SYS'
            GOSUB OP.SYS.FINISH.FILE
         CASE DLMAIN.PRINT.METHOD = 'WRITESEQ'
            CLOSESEQ DLMAIN.F.OUTPUT.FILE
      END CASE
      RETURN



DELETE.VOC.RECORDS: 
      DEBUG2
      CRT 'GOSUB DELETE.VOC.RECORDS'
      END
      NUM.DELETE = COUNT(DLMAIN.VOC.DELETE.LIST,@VM) + (DLMAIN.VOC.DELETE.LIST#'')
      FOR WHICH.DELETE = 1 TO NUM.DELETE
         DELETE DLMAIN.F.VOC,DLMAIN.VOC.DELETE.LIST<1,WHICH.DELETE>
      NEXT WHICH.DELETE
      RETURN


DELETE.SAVEDLISTS.RECORDS: 
      DEBUG2
      CRT 'GOSUB DELETE.SAVEDLISTS.RECORDS'
      END
      NUM.DELETE = COUNT(DLMAIN.SAVEDLISTS.DELETE.LIST,@VM) + (DLMAIN.SAVEDLISTS.DELETE.LIST#'')
      FOR WHICH.DELETE = 1 TO NUM.DELETE
         X.LIST.NAME = DLMAIN.SAVEDLISTS.DELETE.LIST<1,WHICH.DELETE>
         X.COMMAND = 'DELETE.LIST ':X.LIST.NAME
         CRT 'Deleting temporary list ':X.LIST.NAME
         EXECUTE X.COMMAND
      NEXT WHICH.DELETE
      RETURN



*
*
* DISPLAY FILE PRINT.LAYOUT
*
PRINT.LAYOUT.SUB: 
      DEBUG2
      CRT 'GOSUB PRINT.LAYOUT.SUB'
      END
      IF DLMAIN.LPTR THEN
         PRINTER ON
      END
      IF DLMAIN.INFO.FILE.NAME.PART.1(PRIMARY.FILE.NUM) = '' THEN
         TEMP.NAME = '"':DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM):'"'
      END ELSE
         TEMP.NAME = '"':DLMAIN.INFO.FILE.NAME.PART.1(PRIMARY.FILE.NUM):' ':DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM):'"'
      END
      NL = "'L'"
      H1 = PROGRAM.NAME:" File layout: ":TEMP.NAME
      H1 := DBMS.HEADING.GAP.OPTION:"Page   'P'":NL
      H1 := "'T'":NL:NL
      H1 := 'Format.......: ':DLMAIN.FORMAT:NL
      IF DLMAIN.OUTPUT.FILE.NAME THEN
         H1 := 'File.........: ':DLMAIN.OUTPUT.FILE.NAME:' ':DLMAIN.OUTPUT.RECORD.NAME:NL
      END
      IF BY.EXP.FIELD THEN
         H1 := 'Expanded on..:':BY.EXP.FIELD:NL
      END
*
      IF DLMAIN.FIELD.GAP # '' THEN
         H1 := 'Field gap....: ':FMT(DLMAIN.FIELD.GAP,'5R'):NL
      END
      IF DLMAIN.NO.LINEFEED THEN
         H1 := 'No linefeed..: TRUE'
      END
      IF DLMAIN.NUM.FILES > 1 THEN
         H1 := NL
         FOR FILE.CTR=2 TO DLMAIN.NUM.FILES
            H1 := 'Related file.: '
            H1 := FMT(DLMAIN.INFO.FILE.NAME.PART.2(FILE.CTR),'30L')
            FIELD.NAME = DL.DATA.DICT.REC.FIELD.LIST<DLMAIN.INFO.FILE.KEY.DICT.CTR(FILE.CTR)>
            H1 := FMT(FIELD.NAME,'25L')
            H1 := DLMAIN.INFO.FILE.ALIAS.LIST<FILE.CTR>
            H1 := NL
         NEXT FILE.CTR
      END
      H3 ='Field  '
      H3 := FMT('Field name','31L')
      H3 := FMT('Value(s)','10L')
      H3 := FMT('Line','8R')
      IF DLMAIN.FORMAT = 'FIXED' OR DLMAIN.FORMAT = 'DBF' THEN
         H3 := FMT('Beg Col','8R')
         H3 := FMT('End Col','8R')
         H3 := FMT('Length','8R')
      END
*
* CHECK HEADING, DETAIL RECORDS, & FOOTINGS
*
      IF DLMAIN.HEADING.OUT.REC THEN
         H2 = 'File Heading Record'
         OUT.REC.CTR = DLMAIN.HEADING.OUT.REC
         GOSUB PRINT.LAYOUT.SINGLE
      END
      FOR BREAK.CTR=1 TO DLMAIN.NUM.BREAK.FIELDS
         OUT.REC.CTR = DLMAIN.BREAK.HEADING.OUT.REC.LIST<BREAK.CTR>
         IF OUT.REC.CTR THEN
            WHICH.DICT.REC.CTR = DLMAIN.BREAK.DICT.CTR.LIST<BREAK.CTR>
            FIELD.NAME = DL.DATA.DICT.REC.FIELD.LIST<WHICH.DICT.REC.CTR>
            H2 = 'Record heading on break field : ':FIELD.NAME
            GOSUB PRINT.LAYOUT.SINGLE
         END
      NEXT BREAK.CTR
      IF NOT(DLMAIN.DET.SUP) THEN
         OUT.REC.CTR = DL.OUTR.DETAIL.OUT.REC
         H2 = 'Detail Record'
         GOSUB PRINT.LAYOUT.SINGLE
      END
      FOR BREAK.CTR=DLMAIN.NUM.BREAK.FIELDS TO 1 STEP -1
         OUT.REC.CTR = DLMAIN.BREAK.FOOTING.OUT.REC.LIST<BREAK.CTR>
         IF OUT.REC.CTR THEN
            IF BREAK.CTR = 1 THEN
               FIELD.NAME = 'ALL (final break footing)'
            END ELSE
               WHICH.DICT.REC.CTR = DLMAIN.BREAK.DICT.CTR.LIST<BREAK.CTR>
               FIELD.NAME = DL.DATA.DICT.REC.FIELD.LIST<WHICH.DICT.REC.CTR>
            END
            H2 = 'Record footing on break field : ':FIELD.NAME
            IF OUT.REC.CTR = DL.OUTR.DETAIL.OUT.REC THEN
               HEADING H1:NL:NL:H2:NL:NL:H3
               PRINT
               PRINT 'Layout is same as detail record'
            END ELSE
               GOSUB PRINT.LAYOUT.SINGLE
            END
         END
      NEXT BREAK.CTR
      IF DLMAIN.FOOTING.OUT.REC THEN
         H2 = 'File Heading Record'
         OUT.REC.CTR = DLMAIN.FOOTING.OUT.REC
         GOSUB PRINT.LAYOUT.SINGLE
      END
      PRINTER OFF
      RETURN


*
*
* PRINT A SINGLE FILE LAYOUT
*
PRINT.LAYOUT.SINGLE: 
      HEADING H1:NL:NL:H2:NL:NL:H3
      OUT.FIELD.CTR = 0
      FOR FIELD.CTR=1 TO DL.OUTR.NUM.OUT.FIELDS(OUT.REC.CTR)
         FIELD.NAME = DL.OUTR.FIELD.LIST(OUT.REC.CTR)<FIELD.CTR>
         PREFIX = DL.OUTR.PREFIX.LIST(OUT.REC.CTR)<FIELD.CTR>
         LENGTH.VALUE = DL.OUTR.LENGTH.LIST(OUT.REC.CTR)<FIELD.CTR>
         LINE.VALUE = DL.OUTR.LINE.LIST(OUT.REC.CTR)<FIELD.CTR>
         MV.ORIENTATION.VALUE = DL.OUTR.MV.ORIENTATION.LIST(OUT.REC.CTR)<FIELD.CTR>
         SM.VALUE = DL.OUTR.SM.LIST(OUT.REC.CTR)<FIELD.CTR>
         BEG.COL.VALUE = DL.OUTR.BEG.COL.LIST(OUT.REC.CTR)<FIELD.CTR>
         END.COL.VALUE = DL.OUTR.END.COL.LIST(OUT.REC.CTR)<FIELD.CTR>
         NUM.VALUES.VALUE = DL.OUTR.NUM.VALUES.LIST(OUT.REC.CTR)<FIELD.CTR>
         BEGIN CASE
            CASE SM.VALUE = 'M' AND (DLMAIN.FORMAT = 'WP50' OR DLMAIN.FORMAT = 'WP51')
               WHICH.VALUE = FMT(NUM.VALUES.VALUE,'3R'):' values separated by hard return'
               WHICH.LINE = LINE.VALUE
               OUT.FIELD.CTR += 1
               GOSUB PFL.PRINT.FIELD
            CASE NUM.VALUES.VALUE = 'ALL'
               WHICH.VALUE = FMT('All values','10L')
               WHICH.LINE = LINE.VALUE
               OUT.FIELD.CTR += 1
               GOSUB PFL.PRINT.FIELD
            CASE SM.VALUE # 'M'
               WHICH.VALUE = FMT('','10L')
               WHICH.LINE = LINE.VALUE
               OUT.FIELD.CTR += 1
               GOSUB PFL.PRINT.FIELD
            CASE 1
               TEMP.FLAG = 'Value '
               FOR VALUE.CTR=1 TO NUM.VALUES.VALUE
                  WHICH.VALUE = FMT(TEMP.FLAG:FMT(VALUE.CTR,'3R'),'10L')
                  IF MV.ORIENTATION.VALUE = 'VERTICAL' THEN
                     WHICH.LINE = LINE.VALUE + VALUE.CTR - 1
                  END ELSE
                     WHICH.LINE = LINE.VALUE
                  END
                  OUT.FIELD.CTR += 1
                  END.COL.VALUE = BEG.COL.VALUE + LENGTH.VALUE - 1
                  GOSUB PFL.PRINT.FIELD
                  TEMP.FLAG = '      '
                  IF MV.ORIENTATION.VALUE = 'HORIZONTAL' THEN
                     BEG.COL.VALUE = END.COL.VALUE + 1
                  END
               NEXT VALUE.CTR
         END CASE
      NEXT FIELD.CTR
      RETURN


*
*
* DISPLAY FILE PRINT.LAYOUT DISPLAY A FIELD
*
PFL.PRINT.FIELD: 
      PRTLIN = FMT(OUT.FIELD.CTR,'5R'):' '
      IF PREFIX THEN
         PRTLIN := FMT(PREFIX:' ':FIELD.NAME,'31L')[1,31]
      END ELSE
         PRTLIN := FMT(FIELD.NAME,'31L')
      END
      PRTLIN := WHICH.VALUE
      PRTLIN := FMT(WHICH.LINE,'8R')
      IF DLMAIN.FORMAT = 'FIXED' OR DLMAIN.FORMAT = 'DBF' THEN
         PRTLIN := FMT(BEG.COL.VALUE,'8R')
         PRTLIN := FMT(END.COL.VALUE,'8R')
         PRTLIN := FMT(LENGTH.VALUE,'8R')
      END
      PRINT PRTLIN
      RETURN


*
*
* DISPLAY ERROR MESSAGES
*
PRINT.ERROR.MESSAGES: 
      DEBUG2
      CRT 'GOSUB PRINT.ERROR.MESSAGES'
      END
      IF DLMAIN.LPTR THEN
         PRINTER ON
      END
      HDG = PROGRAM.NAME:" Error Listing"
      HDG := DBMS.HEADING.GAP.OPTION:"Page   'P'"
      HDG := "'L'":DBMS.HEADING.GAP.OPTION:"'TL'"
      HEADING HDG
      NUM.ERRMSG = COUNT(DLMAIN.ERRMSG,@FM) + 1
      FOR ERRMSG.CTR=1 TO NUM.ERRMSG
         PRINT DLMAIN.ERRMSG<ERRMSG.CTR>
      NEXT ERRMSG.CTR
      PRINTER OFF
      RETURN




*******************************************************************************
**
**   FATAL ERROR TRAP
**
*******************************************************************************
HAVE.FATAL.ERROR: 
      DEBUG2
      CRT 'GOSUB HAVE.FATAL.ERROR'
      END
      DLMAIN.ERRMSG<-1> = @FM:'*** Program stopped due to errors. ***'
      GOSUB PRINT.ERROR.MESSAGES
      CLEARSELECT DLMAIN.FROM.UNIT
      STOP


EVAL.FORMULA: 
      X.COMMAND = 'SELECT'
      X.COMMAND :=' ':DLMAIN.INFO.FILE.NAME.PART.2(PRIMARY.FILE.NUM)
      X.COMMAND := ' "':DLMAIN.RECORD.ID:'"'
      X.COMMAND := ' SAVING EVAL "':X.EVAL.FORMULA:'"'
      X.COMMAND := ' TO ':DLMAIN.EVAL.UNIT
      EXECUTE X.COMMAND CAPTURING XL.COMMAND.OUTPUT
      READNEXT XL.RESULTS FROM DLMAIN.EVAL.UNIT ELSE
         XL.RESULTS = ''
      END
      X.EVAL.RESULTS = XL.RESULTS
      RETURN


GET.LIT.DICT.EVAL: 
      IF X.LIT.DICT.EVAL = '' THEN
         X.LIT.DICT.EVAL.VALUE = ''
      END ELSE
         X.FIRST.PART = FIELD(X.LIT.DICT.EVAL,@VM,1,1)
         X.SECOND.PART = FIELD(X.LIT.DICT.EVAL,@VM,2,1)
         BEGIN CASE
            CASE (X.FIRST.PART = '$$EVAL') AND (X.SECOND.PART NE '')
               X.EVAL.FORMULA = DLMAIN.EVAL.FORMULAE(X.SECOND.PART)
               GOSUB EVAL.FORMULA
               X.LIT.DICT.EVAL.VALUE = X.EVAL.RESULTS
            CASE (X.FIRST.PART = '$$DICT') AND (X.SECOND.PART NE '')
               X.DICT.NUMBER = X.SECOND.PART
               X.LIT.DICT.EVAL.VALUE = DL.DATA.NEW.DATA.ITEMS(X.DICT.NUMBER)
            CASE 1
               X.LIT.DICT.EVAL.VALUE = X.LIT.DICT.EVAL
         END CASE
      END
      RETURN


   END
