*
* INFO/BASIC PROGRAM
* 6/20/90
* DWS
* TITLE ----- VIEW.SPOOL
*
*
* PURPOSE: VIEW SPOOL QUEUE ENTRIES WITH OPTION
*
* Stamped: pty/ttyp2 sjoquist, /disk1/coltest, user #2435, 23 Jun 94, 08:44AM.
* Rewrite for HP
*     Last updated by LIVE (ROTMAN) at 13:47:49 on 08/23/1991.
* Start a rudimentary help paragraph.
*     Last updated by LIVE (ROTMAN) at 12:37:26 on 07/31/1991.
* Shorten queue-entry and attribute columns so that file.name column
* can be longer.
*     Last updated by LIVE (SJOQUIST) at 15:23:26 on 06/20/1990.
*
*************************************************************************
*

      $INCLUDE LOCAL.SOURCE I_C26.STANDARD
      $INSERT I_SPQUEUE.COMMON


*
*
* MAIN CONTROL
*

      GOSUB SET.UP
      GOSUB PROCESS.COMMAND.LINE
      GOSUB LOAD.ITEMS
      BEGIN CASE
         CASE NUM.CL.OPTIONS > 0
            GOSUB PROCESS.OPTION.LIST
         CASE MENU.DISPLAY
            GOSUB DISPLAY.HEADINGS
            CURRENT.PAGE = LAST.PAGE
            GOSUB DISPLAY.PAGE
            GOSUB PROCESS.MENU
         CASE 1
            GOSUB LIST.ITEMS
      END CASE
      STOP



*
*
*
SET.UP: 
      ON.ERROR.RETURN = @FALSE
      ERRMSG = ''
      F.INFO.USERS = ''
      CALL OPEN.FILE(F.INFO.USERS, 'INFO.USERS', ON.ERROR.RETURN, ERRMSG)
      READ INFO.USERS.REC FROM F.INFO.USERS, @LOGNAME ELSE
         INFO.USERS.REC = ''
      END
      IUR.EDIT.SPOOL.QUEUE.OKAY = INFO.USERS.REC<16>
*
      MAX.ITEMS = 999
      DIM ITEM.LINE(MAX.ITEMS)
      LINES.PER.PAGE = 17
      LINE.OFFSET = 3
      NO.ITEMS.MSG = 'There are no items in the spool queue to display.'
      DISPLAY.PROMPT = '(P)age, (R)edisplay, (V)iew, (CA)ncel, (F)orm, (CO)pies'
      IF IUR.EDIT.SPOOL.QUEUE.OKAY THEN
         DISPLAY.PROMPT := ', (ED)it'
      END
      ANSWER.LIST = ''
      DEFAULT.ANSWER = ''
      NULL.ANSWER.LIST = ''
      NULL.DEFAULT.ANSWER = ''
      CRT.COL = 0
      PROMPT.COL = 0
      PROMPT.LINE = 22
      CRT.LINE = 0
      END.PARAM = 2
      MENU.DISPLAY = @FALSE
      PROGRAM = 'VIEW.SPOOL'
      PROGRAM.TITLE = 'Display spool queue entries'
      GAP = 79 - LEN(PROGRAM) - LEN(PROGRAM.TITLE)
      HDG1 = PROGRAM.TITLE:SPACE(GAP):PROGRAM
      HDG2 = 'Request Time   User        File                       No Size    Queue'
      HDG3 = '------- ----- ------------ -------------------------- -- ------- ---------'
      RETURN


*
*
* PROCESS COMMAND.LINE
*
PROCESS.COMMAND.LINE: 
      COMMAND.LINE = @SENTENCE
      PARAM.LIST = ''
      PARAM.QUOTED.LIST = ''
      NUM.PARAMS = 0
      CALL PARSE.LINE(COMMAND.LINE,PARAM.LIST,PARAM.QUOTED.LIST,NUM.PARAMS)
      IF PARAM.LIST<1> = 'RUN' THEN
         PARAM.CTR = 3
      END ELSE
         PARAM.CTR = 1
      END
*
      CURRENT.LIST.TYPE = ''
      PARAM.USER.USED = @FALSE
      CL.USER.LIST = ''
      CL.FORM.LIST = ''
      CL.OPTION.LIST = ''
      NUM.CL.OPTIONS = 0
      LOOP
         PARAM.CTR += 1
      UNTIL PARAM.CTR > NUM.PARAMS
         PARAM = PARAM.LIST<PARAM.CTR>
         ORIG.PARAM = PARAM
         PARAM.QUOTED = PARAM.QUOTED.LIST<PARAM.CTR>
         IF NOT(PARAM.QUOTED) THEN
            PARAM = OCONV(PARAM,'MCU')
         END
         BEGIN CASE
            CASE PARAM = 'HELP' OR PARAM = '-HELP'
               GOSUB DISPLAY.HELP
               STOP
            CASE PARAM.QUOTED
               GOSUB ADD.PARAM.TO.LIST
            CASE PARAM = '-USER'
               CURRENT.LIST.TYPE = 'USER'
               PARAM.USER.USED = @TRUE
            CASE PARAM = '-FORM'
               CURRENT.LIST.TYPE = 'FORM'
            CASE PARAM = '-MENU'
               MENU.DISPLAY = @TRUE
            CASE PARAM = '-OPTION' OR PARAM = '-OPTIONS'
               CURRENT.LIST.TYPE = 'OPTION'
               NUM.CL.OPTIONS += 1
            CASE 1
               GOSUB ADD.PARAM.TO.LIST
         END CASE
      REPEAT
*
      IF PARAM.USER.USED AND CL.USER.LIST = '' THEN
         CL.USER.LIST = @LOGNAME
      END
      NUM.CL.FORMS = COUNT(CL.FORM.LIST,@FM) + (CL.FORM.LIST # '')
      GOSUB DETERMINE.USERS.TO.VIEW
      RETURN


DISPLAY.HELP: 
      CRT
      CRT 'VIEW.SPOOL provides an alternative method to control spool queue entries.'
      CRT
      CRT 'The command may be entered without any options, or the following options'
      CRT 'could be used:'
      CRT '  -USER user [user]       (restricts viewing to those users only)'
      CRT '  -FORM form# [form#]       (restricts viewing to those forms only)'
      CRT '  -MENU'
      CRT '  -OPTIONS FORM form# newFormName'
      CRT '  -OPTIONS COPIES form# #copies'
      CRT '  -OPTIONS CANCEL form# [form#]'
      CRT '  -OPTIONS VIEW form# [form#]'
      CRT '  -OPTIONS LIST'
      IF IUR.EDIT.SPOOL.QUEUE.OKAY THEN
         CRT '  -OPTIONS EDIT form# [form#]'
      END
      RETURN





*
*
* ADD PARAM TO LIST
*
ADD.PARAM.TO.LIST: 
      BEGIN CASE
         CASE CURRENT.LIST.TYPE = 'USER'
            CL.USER.LIST<-1> = ORIG.PARAM
         CASE CURRENT.LIST.TYPE = 'FORM'
            CL.FORM.LIST<-1> = ORIG.PARAM
         CASE CURRENT.LIST.TYPE = 'OPTION'
            CL.OPTION.LIST<NUM.CL.OPTIONS,-1> = ORIG.PARAM
         CASE 1
            CRT 'Not expecting ':PARAM.QUOTED:ORIG.PARAM:PARAM.QUOTED:' here.'
      END CASE
      RETURN


*
*
*
* DETERMIME WHO TO VIEW
*
DETERMINE.USERS.TO.VIEW: 
      VIEW.ALL.USERS = @FALSE
      VS.USER.LIST = CL.USER.LIST
*
      IUR.VS.USER.LIST = INFO.USERS.REC<15>
      CONVERT @VM TO @FM IN IUR.VS.USER.LIST
      LOCATE @LOGNAME IN IUR.VS.USER.LIST<1> SETTING POS ELSE
         IUR.VS.USER.LIST<-1> = @LOGNAME
      END
*
* IF THIS PERSON CAN VIEW ALL (FIELD 15 IN INFO.USERS SET TO $ALL)
* THEN CHECK IF LIST OF USERS SPECIFIED ON COMMAND LINE
* ELSE SET VIEW.ALL.USERS TO TRUE
*
* IF THE PERSON CAN VIEW ONLY SELECTED PEOPLE, THEN CROSS CHECK
* COMMAND LINE ENTRIES (IF ANY) WITH INFO.USERS VS.USER.LIST (F15)
*
      LOCATE '$ALL' IN IUR.VS.USER.LIST<1> SETTING POS THEN
         IF VS.USER.LIST = '' THEN
            VIEW.ALL.USERS = @TRUE
         END
      END ELSE
         IF VS.USER.LIST = '' THEN
            VS.USER.LIST = IUR.VS.USER.LIST
         END ELSE
            NUM.VUL = COUNT(VS.USER.LIST,@FM) + 1
            NEW.VU.LIST = ''
            FOR VUL.CTR=1 TO NUM.VUL
               LOCATE VS.USER.LIST<VUL.CTR> IN IUR.VS.USER.LIST<1> SETTING POS THEN
                  NEW.VU.LIST<-1> = VS.USER.LIST<VUL.CTR>
               END
            NEXT VUL.CTR
            VS.USER.LIST = NEW.VU.LIST
            IF VS.USER.LIST = '' THEN
               VS.USER.LIST = @LOGNAME
            END
         END
      END
      RETURN


*
*
* LOAD ITEMS
*
LOAD.ITEMS: 
      RETURN.STATUS = ''
      CALL LOAD.SPOOL.QUEUE(RETURN.STATUS)
      IF RETURN.STATUS # '' THEN
         BREAK OFF
         MSG = 'ERROR ON SPOOL QUEUE: ':RETURN.STATUS<1>
         CALL LINE.22(MSG)
         STOP
      END
      PREV.DATE = ''
      NUM.ITEMS = 0
      MAT ITEM.LINE = ''
      FOR Q.CTR=1 TO SPQUEUE.NUM.ENTRIES
         GOSUB CHECK.IF.OKAY.TO.VIEW
         IF VIEW.THIS.ENTRY THEN
            GOSUB ADD.QUEUE.ENTRY.TO.ITEMS
            PREV.DATE = SPQUEUE.DATE(Q.CTR)
         END
      NEXT Q.CTR
      LAST.PAGE = INT((NUM.ITEMS - 1)/LINES.PER.PAGE) + 1
      IF NUM.ITEMS = 0 THEN
         MSG = NO.ITEMS.MSG
         GOSUB DISPLAY.MSG
         STOP
      END
      RETURN


*
*
* CHECK LISTS TO SEE IF IT IS OKAY TO VIEW THIS ITEM
*
CHECK.IF.OKAY.TO.VIEW: 
      VIEW.THIS.ENTRY = @FALSE
      IF VIEW.ALL.USERS THEN
         VIEW.THIS.ENTRY = @TRUE
      END ELSE
         LOCATE SPQUEUE.USER.NAME(Q.CTR) IN VS.USER.LIST<1> SETTING POS THEN
            VIEW.THIS.ENTRY = @TRUE
         END
      END
      IF NUM.CL.FORMS > 0 THEN
         LOCATE SPQUEUE.FORM.NAME(Q.CTR) IN CL.FORM.LIST<1> SETTING POS ELSE
            VIEW.THIS.ENTRY = @FALSE
         END
      END
      RETURN


*
*
* ADD THIS QUEUE ENTRY TO THE LIST OF ITEMS TO USE
*
ADD.QUEUE.ENTRY.TO.ITEMS: 
      IF SPQUEUE.DATE(Q.CTR) # PREV.DATE THEN
         LINE = OCONV(SPQUEUE.DATE(Q.CTR),'D')
         LINE = LINE[1,4]:OCONV(LINE[5,99],'MCL')
         NUM.ITEMS += 1
         ITEM.LINE(NUM.ITEMS) = LINE
      END
      LINE = FMT(SPQUEUE.ENTRY.NUMBER.LIST<Q.CTR>,'7R'):' '
      LINE := OCONV(SPQUEUE.TIME(Q.CTR),'MT'):' '
      LINE := FMT(SPQUEUE.USER.NAME(Q.CTR),'12L')[1,12]:' '
      TITLE = SPQUEUE.TITLE(Q.CTR)
      FILE.NAME = SPQUEUE.FILE.NAME(Q.CTR)
      IF TITLE THEN
         DISPLAY.TITLE = TITLE
      END ELSE
         DISPLAY.TITLE = FILE.NAME
      END
      LINE := FMT(DISPLAY.TITLE[26],'26L')
      LINE := FMT(SPQUEUE.COPIES(Q.CTR),'3R')
      LINE := FMT(SPQUEUE.SIZE(Q.CTR),'8R'):' '
      LINE := FMT(SPQUEUE.FORM.NAME(Q.CTR),'9L')[1,9]
      NUM.ITEMS += 1
      ITEM.LINE(NUM.ITEMS) = LINE
      RETURN


*
*
* LIST ITEM
*
LIST.ITEMS: 
*DWS      CRT HDG1
      CRT HDG2
      CRT HDG3
      FOR ITEM.NUM = 1 TO NUM.ITEMS
         CRT ITEM.LINE(ITEM.NUM)
      NEXT ITEM.NUM
      RETURN



*
* DISPLAY HEADINGS
*
DISPLAY.HEADINGS: 
      CRT CLEAR.SCREEN
      CRT @(0,0):HDG1
      CRT @(0,2):HDG2
      CRT @(0,3):HDG3
      RETURN



*
*
* PROCESS COMMANDS
*
PROCESS.MENU: 
      LOOP
         COMMAND = ''
         CALL PROMPT.ANS(COMMAND,DISPLAY.PROMPT,PROMPT.COL,PROMPT.LINE,ANSWER.LIST,DEFAULT.ANSWER,END.PARAM)
         UC.COMMAND = OCONV(COMMAND,'MCU')
      UNTIL UC.COMMAND = 'E' OR UC.COMMAND = 'Q' DO
         GOSUB PROCESS.COMMAND
      REPEAT
      RETURN


PROCESS.OPTION.LIST: 
      FOR OPTION.CTR=1 TO NUM.CL.OPTIONS
         OPTION = OCONV(CL.OPTION.LIST<OPTION.CTR,1>,'MCU')
         REST.OF.LINE = FIELD(CL.OPTION.LIST<OPTION.CTR>,@VM,2,9999)
         CONVERT @VM TO ' ' IN REST.OF.LINE
         GOSUB PROCESS.OPTION
      NEXT OPTION.CTR
      RETURN


*
*
* PROCESS AN OPTION
*
PROCESS.OPTION: 
      BEGIN CASE
         CASE OPTION = 'EDIT' AND IUR.EDIT.SPOOL.QUEUE.OKAY
            GOSUB PROCESS.EDIT
         CASE OPTION = 'VIEW'
            GOSUB PROCESS.VIEW
         CASE OPTION = 'CANCEL'
            GOSUB PROCESS.CANCEL
         CASE OPTION = 'FORM'
            GOSUB PROCESS.FORM
         CASE OPTION = 'LIST'
            GOSUB LIST.ITEMS
         CASE OPTION = 'COPIES'
            GOSUB PROCESS.COPIES
      END CASE
      RETURN



*
*
* PROCESS A COMMAND
*
PROCESS.COMMAND: 
      NEED.REDISPLAY = @FALSE
      CMD1 = UC.COMMAND[1,1]
      REST1 = COMMAND[2,80]
      CMD2 = UC.COMMAND[1,2]
      REST2 = COMMAND[3,80]
      REST.OF.LINE = ''
      BEGIN CASE
         CASE CMD1 = 'P'
            REST.OF.LINE = REST1
            GOSUB PROCESS.PAGE
         CASE UC.COMMAND = 'R'
            NEED.REDISPLAY = @TRUE
         CASE CMD2 = 'ED' AND IUR.EDIT.SPOOL.QUEUE.OKAY
            REST.OF.LINE = REST2
            GOSUB PROCESS.EDIT
         CASE CMD1 = 'V'
            REST.OF.LINE = REST1
            GOSUB PROCESS.VIEW
         CASE CMD2 = 'CA'
            REST.OF.LINE = REST2
            GOSUB PROCESS.CANCEL
         CASE CMD1 = 'F'
            REST.OF.LINE = REST1
            GOSUB PROCESS.FORM
         CASE CMD2 = 'CO'
            REST.OF.LINE = REST2
            GOSUB PROCESS.COPIES
         CASE COMMAND = ''
            GOSUB PROCESS.FORWARD
      END CASE
      IF NEED.REDISPLAY THEN
         GOSUB PROCESS.REDISPLAY
      END
      RETURN


*
*
* PROCESS.FORWARD
*
PROCESS.FORWARD: 
      IF CURRENT.PAGE = LAST.PAGE THEN
         CURRENT.PAGE = 1
      END ELSE
         CURRENT.PAGE += 1
      END
      IF LAST.PAGE # 1 THEN
         GOSUB DISPLAY.PAGE
      END
      RETURN


*
*
* PROCESS.PAGE
*
PROCESS.PAGE: 
      PAGE.NO = REST.OF.LINE
      IF PAGE.NO = '' THEN
         CALL PROMPT.ANS(PAGE.NO,'Page #',PROMPT.COL,PROMPT.LINE,NULL.ANSWER.LIST,NULL.DEFAULT.ANSWER,END.PARAM)
      END
      IF NOT(NUM(PAGE.NO)) THEN
         MSG = '"':PAGE.NO:'" is not a valid page number.'
         CALL LINE.22(MSG)
      END ELSE
         IF PAGE.NO < 1 OR PAGE.NO > LAST.PAGE THEN
            MSG = 'Page number must be from 1 to ':LAST.PAGE:'.'
            CALL LINE.22(MSG)
         END ELSE
            CURRENT.PAGE = PAGE.NO
            GOSUB DISPLAY.PAGE
         END
      END
      RETURN



*
*
* REDISPLAY
*
PROCESS.REDISPLAY: 
      GOSUB LOAD.ITEMS
      GOSUB DISPLAY.HEADINGS
      CURRENT.PAGE = LAST.PAGE
      GOSUB DISPLAY.PAGE
      RETURN


*
*
* VIEW SPOOL FILE
*
PROCESS.VIEW: 
      CONVERT ',' TO ' ' IN REST.OF.LINE
      ENTRY.NUMBER.LIST = TRIM(REST.OF.LINE)
      GOSUB GET.VALID.ENTRY.NUMBERS
      IF VALID.ENTRY.NUMBERS THEN
         IF NUM.ENTRY.NUMBERS = 1 THEN
            OSOPEN SPQUEUE.SPOOL.NAME(ENTRY.POS.LIST<1>) TO F.OS.FILE THEN
               HEADING.TEXT = 'Spool entry #':ENTRY.NUMBER
               OS.POS = 0
               CALL VIEW.OS.FILE(F.OS.FILE, OS.POS, HEADING.TEXT)
               OSCLOSE F.OS.FILE
               NEED.REDISPLAY = @TRUE
            END ELSE
               MSG = 'Can not open "':SPQUEUE.SPOOL.NAME(ENTRY.POS.LIST<1>):'"'
               CALL LINE.22(MSG)
            END
         END ELSE
            MSG = 'You may only view one entry at a time.'
            CALL LINE.22(MSG)
         END
      END
      RETURN



*
*
* GET VALID ENTRY NUMBER
*
GET.VALID.ENTRY.NUMBERS: 
      IF ENTRY.NUMBER.LIST = '' THEN
         CALL PROMPT.ANS(ENTRY.NUMBER.LIST,'Entry number(s)',PROMPT.COL,PROMPT.LINE,NULL.ANSWER.LIST,NULL.DEFAULT.ANSWER,END.PARAM)
         CONVERT ',' TO ' ' IN REST.OF.LINE
         ENTRY.NUMBER.LIST = TRIM(ENTRY.NUMBER.LIST)
      END
      IF ENTRY.NUMBER.LIST = '' THEN
         VALID.ENTRY.NUMBERS = @FALSE
         RETURN
      END
      VALID.ENTRY.NUMBERS = @TRUE
      NUM.ENTRY.NUMBERS = COUNT(ENTRY.NUMBER.LIST,' ') + 1
      ENTRY.POS.LIST = ''
      ENTRY.NAME.LIST = ''
      ENTRY.USER.LIST = ''
      FOR ENTRY.CTR=1 TO NUM.ENTRY.NUMBERS
         ENTRY.NUMBER = FIELD(ENTRY.NUMBER.LIST,' ',ENTRY.CTR,1)
         LOCATE ENTRY.NUMBER IN SPQUEUE.ENTRY.NUMBER.LIST<1> SETTING ENTRY.POS THEN
            ENTRY.POS.LIST<ENTRY.CTR> = ENTRY.POS
            ENTRY.NAME.LIST<ENTRY.CTR> = SPQUEUE.FORM.NAME(ENTRY.POS):'-':ENTRY.NUMBER
            ENTRY.USER.LIST<ENTRY.CTR> = SPQUEUE.USER.NAME(ENTRY.POS)
         END ELSE
            VALID.ENTRY.NUMBERS = @FALSE
            MSG = 'Entry number ':ENTRY.NUMBER:' does not exist.'
            GOSUB DISPLAY.MSG
         END
      NEXT ENTRY.CTR
      RETURN


*
*
* GET FORM NAME
*
GET.FORM.NAME: 
      FORM.NAME = ''
      CALL PROMPT.ANS(FORM.NAME,'Form name',PROMPT.COL,PROMPT.LINE,NULL.ANSWER.LIST,NULL.DEFAULT.ANSWER,END.PARAM)
      RETURN


*
*
* GET VALID NUM.COPIES
*
GET.VALID.NUM.COPIES: 
      VALID.NUM.COPIES = @FALSE
      NUM.COPIES = ''
      CALL PROMPT.ANS(NUM.COPIES,'Number of copies',PROMPT.COL,PROMPT.LINE,NULL.ANSWER.LIST,NULL.DEFAULT.ANSWER,END.PARAM)
      IF NUM.COPIES # '' THEN
         IF NOT(NUM(NUM.COPIES)) OR NUM.COPIES < 1 THEN
            MSG = '"':NUM.COPIES:'" is not a valid number of copies.'
            GOSUB DISPLAY.MSG
         END ELSE
            VALID.NUM.COPIES = @TRUE
         END
      END
      RETURN



*
*
* EDIT JOBS
*
PROCESS.EDIT: 
      CONVERT ',' TO ' ' IN REST.OF.LINE
      ENTRY.NUMBER.LIST = TRIM(REST.OF.LINE)
      GOSUB GET.VALID.ENTRY.NUMBERS
      IF VALID.ENTRY.NUMBERS THEN
         EDIT.COMMAND = 'vi'
         FOR ENTRY.CTR=1 TO NUM.ENTRY.NUMBERS
            EDIT.COMMAND := ' ':SPQUEUE.SPOOL.NAME(ENTRY.POS.LIST<1>)
         NEXT ENTRY.CTR
         PCPERFORM EDIT.COMMAND
         IF NUM.CL.OPTIONS = 0 THEN
            CRT 'Press Return to continue: ':
            INPUT ANS
         END
      END
      NEED.REDISPLAY = @TRUE
      RETURN



*
*
* CANCEL JOBS
*
PROCESS.CANCEL: 
      CONVERT ',' TO ' ' IN REST.OF.LINE
      ENTRY.NUMBER.LIST = TRIM(REST.OF.LINE)
      GOSUB GET.VALID.ENTRY.NUMBERS
      IF VALID.ENTRY.NUMBERS THEN
         FOR ENTRY.CTR=1 TO NUM.ENTRY.NUMBERS
            SPOOL.COMMAND = 'cancel ':ENTRY.NAME.LIST<ENTRY.CTR>
            PCPERFORM SPOOL.COMMAND
         NEXT ENTRY.CTR
         IF NUM.CL.OPTIONS = 0 THEN
            CRT 'Press Return to continue: ':
            INPUT ANS
         END
      END
      NEED.REDISPLAY = @TRUE
      RETURN


*
*
* CHANGE FORM FOR ENTRIES
*
PROCESS.FORM: 
      CONVERT ',' TO ' ' IN REST.OF.LINE
      REST.OF.LINE = TRIM(REST.OF.LINE)
      IF REST.OF.LINE # '' THEN
         ENTRY.NUMBER.LIST = FIELD(REST.OF.LINE,' ',1,1)
         GOSUB GET.VALID.ENTRY.NUMBERS
         IF VALID.ENTRY.NUMBERS THEN
            FORM.NAME = FIELD(REST.OF.LINE,' ',2,1)
            IF FORM.NAME = '' THEN
               GOSUB GET.FORM.NAME
            END
         END
      END ELSE
         ENTRY.NUMBER.LIST = ''
         GOSUB GET.VALID.ENTRY.NUMBERS
         IF VALID.ENTRY.NUMBERS THEN
            GOSUB GET.FORM.NAME
         END
      END
      IF VALID.ENTRY.NUMBERS THEN
         NUM.ERRORS = 0
         SPOOL.ERRORS = ''
         FOR ENTRY.CTR=1 TO NUM.ENTRY.NUMBERS
            LPALT.ENTRY = ENTRY.NAME.LIST<ENTRY.CTR>
            LPALT.USER = ENTRY.USER.LIST<ENTRY.CTR>
            LPALT.OPTIONS = ' -d':FORM.NAME
            GOSUB DO.LPALT
            IF LPALT.MESSAGE[1,18] # 'new request id is ' THEN
               NUM.ERRORS += 1
               SPOOL.ERRORS<NUM.ERRORS> = LPALT.MESSAGE
            END
         NEXT ENTRY.CTR
         IF NUM.ERRORS > 0 THEN
            FOR ERR.CTR=1 TO NUM.ERRORS
               CRT SPOOL.ERRORS<ERR.CTR>
            NEXT ERR.CTR
            IF NUM.CL.OPTIONS = 0 THEN
               CRT 'Press Return to continue: ':
               INPUT ANS
            END
         END
         NEED.REDISPLAY = @TRUE
      END
      RETURN


*
*
* PROCESS COPIES
*
PROCESS.COPIES: 
      CONVERT ',' TO ' ' IN REST.OF.LINE
      REST.OF.LINE = TRIM(REST.OF.LINE)
      IF REST.OF.LINE # '' THEN
         ENTRY.NUMBER.LIST = FIELD(REST.OF.LINE,' ',1,1)
         GOSUB GET.VALID.ENTRY.NUMBERS
         IF VALID.ENTRY.NUMBERS THEN
            NUM.COPIES = FIELD(REST.OF.LINE,' ',2,1)
            VALID.NUM.COPIES = @TRUE
            IF NUM.COPIES # '' THEN
               IF NOT(NUM(NUM.COPIES)) OR NUM.COPIES < 1 THEN
                  VALID.NUM.COPIES = @FALSE
                  MSG = '"':NUM.COPIES:'" is not a valid number of copies'
                  GOSUB DISPLAY.MSG
               END
            END ELSE
               GOSUB GET.VALID.NUM.COPIES
            END
         END
      END ELSE
         ENTRY.NUMBER.LIST = ''
         GOSUB GET.VALID.ENTRY.NUMBERS
         IF VALID.ENTRY.NUMBERS THEN
            GOSUB GET.VALID.NUM.COPIES
         END
      END
      IF VALID.ENTRY.NUMBERS THEN
         IF VALID.NUM.COPIES THEN
            NUM.ERRORS = 0
            SPOOL.ERRORS = ''
            FOR ENTRY.CTR=1 TO NUM.ENTRY.NUMBERS
               LPALT.ENTRY = ENTRY.NAME.LIST<ENTRY.CTR>
               LPALT.USER = ENTRY.USER.LIST<ENTRY.CTR>
               LPALT.OPTIONS = ' -n':NUM.COPIES
               GOSUB DO.LPALT
               IF LPALT.MESSAGE THEN
                  NUM.ERRORS += 1
                  SPOOL.ERRORS<NUM.ERRORS> = LPALT.MESSAGE
               END
            NEXT ENTRY.CTR
            IF NUM.ERRORS > 0 THEN
               FOR ERR.CTR=1 TO NUM.ERRORS
                  CRT SPOOL.ERRORS<ERR.CTR>
               NEXT ERR.CTR
               IF NUM.CL.OPTIONS = 0 THEN
                  CRT 'Press Return to continue: ':
                  INPUT ANS
               END
            END
         END
      END
      NEED.REDISPLAY = @TRUE
      RETURN


*
* Note: by using 'lpalt -dNEWFORM old-job' to change a form name
*       leaves the new job without the appropriate rights set for
*       group lp to access it.  By waiting 1 second, and then executing
*       'lpstat -t', lpstat sets the rights correctly.
*
DO.LPSTAT: 
      SLEEP 1
      SPOOL.COMMAND = 'lpstat -t'
      PCPERFORM SPOOL.COMMAND CAPTURING SPOOL.MESSAGE
      RETURN


DO.LPALT: 
      LPALT.MESSAGE = ''
      IF @LOGNAME # LPALT.USER THEN
         CHQOWN.COMMAND = '/disk1/locsrc/cprogs/chqown ':LPALT.ENTRY:' ':@LOGNAME
         PCPERFORM CHQOWN.COMMAND CAPTURING LPALT.MESSAGE
      END
      IF LPALT.MESSAGE = '' THEN
         LPALT.COMMAND = 'lpalt ':LPALT.OPTIONS:' ':LPALT.ENTRY
         PCPERFORM LPALT.COMMAND CAPTURING LPALT.MESSAGE
         GOSUB DO.LPSTAT
         IF LPALT.MESSAGE[1,18] = 'new request id is ' THEN
            LPALT.NEW.ENTRY = TRIM(LPALT.MESSAGE<1>[19,80])
            IF @LOGNAME # LPALT.USER THEN
               CHQOWN.COMMAND = '/disk1/locsrc/cprogs/chqown ':LPALT.NEW.ENTRY:' ':LPALT.USER
               PCPERFORM CHQOWN.COMMAND CAPTURING CHQOWN.MESSAGE
            END
         END
      END
      RETURN



*
*
*
DISPLAY.PAGE: 
      END.ITEM = CURRENT.PAGE * LINES.PER.PAGE
      START.ITEM = END.ITEM - (LINES.PER.PAGE - 1)
      CRT.LINE = LINE.OFFSET
      CRT @(0,LINE.OFFSET+1):CLEAR.EOS
      IF END.ITEM > NUM.ITEMS THEN
         END.ITEM = NUM.ITEMS
      END
      FOR ITEM.NUM = START.ITEM TO END.ITEM
         CRT.LINE += 1
         CRT @(0,CRT.LINE):ITEM.LINE(ITEM.NUM):
      NEXT ITEM.NUM
      CRT @(PROMPT.COL,PROMPT.LINE-1):'Page ':CURRENT.PAGE:' of ':LAST.PAGE
      RETURN


*
*
* DISPLAY MSG
*
DISPLAY.MSG: 
      IF MENU.DISPLAY THEN
         CALL LINE.22(MSG)
      END ELSE
         CRT MSG
      END
      RETURN

   END
