3332 LINES
*-------------------------- FTP SUBMISSION FORM --------------------------
*--- PROGRAM NAME...: VIEW.SPOOL
*--- 40-CHAR DESC...: Let users view spool entries/change dest/etc.
*--- KEYWORDS.......:
*--- SUBMISSION DATE: 06/30/95
*--- COMPANY NAME...: Cedarville College
*--- CONTACT NAME...: Doug Sjoquist
*--- CONTACT PHONE#.:
*--- CONTACT EMAIL..: sjoquist@cedarville.edu
*--- LONG DESC......: This program allows users to view their
*---                : own spool files and change job characteristics
*---                : such as destination (form), number of copies, etc.
*---                : Installation requires modifying the 'udt' run
*---                : machine to call some C subroutines.
*---                :
*---                : These routines were written for HP/UX.
*---                : Use on other *ix platforms may require some
*---                : modification.
*---                :
*-------------------------------------------------------------------------
FILE/RECORD INFORMATION:
  1 CPROGS............................. c_finfo.c                     
  2 CPROGS............................. c_qchown.c                    
  3 CPROGS............................. c_qclose.c                    
  4 CPROGS............................. c_qnext.c                     
  5 CPROGS............................. c_qopen.c                     
  6 CPROGS............................. chqown.c                      
  7 CPROGS............................. fixoutputq.c                  
  8 CPROGS............................. qchown.c                      
  9 CPROGS............................. qclose.c                      
 10 CPROGS............................. qnext.c                       
 11 CPROGS............................. qopen.c                       
 12 UDTWORK............................ cfuncdef                      
 13 CUSTOM.SOURCE...................... VIEW.SPOOL.SCREEN             
 14 CUSTOM.SOURCE...................... VIEW.SPOOL                    
 15 CUSTOM.SOURCE...................... I_C26.STANDARD                
 16 CUSTOM.SOURCE...................... ATFUNCTIONS.INS.IBAS          
 17 CUSTOM.SUBROUTINES................. OPEN.FILE                     
 18 CUSTOM.SUBROUTINES................. PARSE.LINE                    
 19 CUSTOM.SUBROUTINES................. LOAD.SPOOL.QUEUE              
 20 CUSTOM.SUBROUTINES................. PARSE.COMMAND.LINE            
 21 CUSTOM.SUBROUTINES................. EXPAND.ITEMS                  
 22 CUSTOM.SUBROUTINES................. PROMPT.ANS                    
 23 CUSTOM.SUBROUTINES................. VIEW.OS.FILE                  
 24 CUSTOM.SUBROUTINES................. SEND.SPOOL.FILE.NETWORK       
 25 CUSTOM.SUBROUTINES................. SEND.MAIL.NETWORK             
 ##### FILE CPROGS ################################   11 RECORDS ######
 ======== RECORD c_finfo.c ========================    33 FIELDS ======
 #include <stdio.h>
 #include <time.h>
 #include <sys/stat.h>
  
 int c_finfo(i_file_name, o_buffer)
 char *i_file_name;
 char *o_buffer;
 {
    struct stat statbuf;
    struct tm *mtimebuf;
    struct tm *ctimebuf;
    struct tm *atimebuf;
    int status;
    char FM;
  
    FM = (char) 254;
  
    status = stat(i_file_name, &statbuf);
    if(!status) {
       mtimebuf = localtime(&(statbuf.st_mtime));
       atimebuf = localtime(&(statbuf.st_atime));
       ctimebuf = localtime(&(statbuf.st_ctime));
       sprintf(o_buffer, "%u%c%d%c%02d/%02d/%02d%c%02d/%02d/%02d%c%02d/
C%02d/%02d%c%02d:%02d:%02d%c%02d:%02d:%02d%c%02d:%02d:%02d",
          statbuf.st_mode, FM, statbuf.st_size, FM,
          atimebuf->tm_mon+1, atimebuf->tm_mday, atimebuf->tm_year, FM,
          mtimebuf->tm_mon+1, mtimebuf->tm_mday, mtimebuf->tm_year, FM,
          ctimebuf->tm_mon+1, ctimebuf->tm_mday, ctimebuf->tm_year, FM,
          atimebuf->tm_hour, atimebuf->tm_min, atimebuf->tm_sec, FM,
          mtimebuf->tm_hour, mtimebuf->tm_min, mtimebuf->tm_sec, FM,
          ctimebuf->tm_hour, ctimebuf->tm_min, ctimebuf->tm_sec);
    }
    return(status);
 }
 ======== END OF RECORD ===============================================
 ======== RECORD c_qchown.c =======================    53 FIELDS ======
 #include <stdio.h>
 #define ENTRY_SIZE 332
 
 int c_qchown(i_cur_entry, i_queue_file, i_user_name, i_queue_name, i_j
Cob_number)
 int i_cur_entry;
 long i_queue_file;
 char *i_user_name;
 char *i_queue_name;
 char *i_job_number;
 {
    char temp_queue_name[16];
    short job_number;
    struct QUEUE_ENTRY {
       char filler1[14];
       short job_number;
       short job_status;
       char filler2[4];
       char node_name[16];
       char filler3[244];
       char user_name[16];
       char queue_name[16];
       char queue_printed[16];
       char filler4[2];
    } q_entry;
 
    FILE *q_file;
    int cur_entry;
    long cur_pos;
    size_t num_read;
    size_t num_written;
  
 
    job_number = atoi(i_job_number);
  
    q_file = (FILE *) i_queue_file;
    cur_entry = i_cur_entry;
    cur_pos = cur_entry * ENTRY_SIZE;
    fseek(q_file, cur_pos, SEEK_SET);
    num_read = fread(&q_entry, sizeof(q_entry), 1, q_file);
    if (num_read == 0) 
       return(-1);
  
    strcpy(temp_queue_name, q_entry.queue_name);
    if (strcmp(temp_queue_name, i_queue_name) != 0)
       return(-2);
    if (q_entry.job_number != job_number)
       return(-3);
  
    strcpy(q_entry.user_name, i_user_name);
 
    num_written = fwrite(&q_entry, sizeof(q_entry), 1, q_file);
    return((int) num_written);
 }
 ======== END OF RECORD ===============================================
 ======== RECORD c_qclose.c =======================     8 FIELDS ======
 #include <stdio.h>
  
 int c_qclose(q_file)
 long q_file;
 {
    fclose((FILE *) q_file);
    return(1);
 }
 ======== END OF RECORD ===============================================
 ======== RECORD c_qnext.c ========================    45 FIELDS ======
 #include <stdio.h>
 #define ENTRY_SIZE 332
 
 int c_qnext(i_last_entry, i_queue_file, o_node_name, o_user_name, o_qu
Ceue_name, o_job_number,o_job_status)
 int i_last_entry;
 long i_queue_file;
 char *o_node_name;
 char *o_user_name;
 char *o_queue_name;
 char *o_job_number;
 char *o_job_status;
 {
    struct QUEUE_ENTRY {
       char filler1[14];
       short job_number;
       short job_status;
       char filler2[4];
       char node_name[16];
       char filler3[244];
       char user_name[16];
       char queue_name[16];
       char queue_printed[16];
       char filler4[2];
    } q_entry;
 
    FILE *q_file;
    int cur_entry;
    long cur_pos;
    size_t num_read;
  
    q_file = (FILE *) i_queue_file;
    cur_entry = i_last_entry;
    cur_pos = cur_entry * ENTRY_SIZE;
    fseek(q_file, cur_pos, SEEK_SET);
    num_read = fread(&q_entry, sizeof(q_entry), 1, q_file);
    strcpy(o_node_name, q_entry.node_name);
    strcpy(o_user_name, q_entry.user_name);
    strcpy(o_queue_name, q_entry.queue_name);
    sprintf(o_job_number, "%d", q_entry.job_number);
    sprintf(o_job_status, "%d", q_entry.job_status);
    if (num_read == 0) 
       return(-1);
    else
       return(cur_entry+1);
 }
 ======== END OF RECORD ===============================================
 ======== RECORD c_qopen.c ========================    10 FIELDS ======
 #include <stdio.h>
  
 long c_qopen(i_file_name)
 char *i_file_name;
 {
    FILE *q_file;
  
    q_file = fopen(i_file_name, "rb+");
    return((long) q_file);
 }
 ======== END OF RECORD ===============================================
 ======== RECORD chqown.c =========================   103 FIELDS ======
 /*
   Program: chqown.c
   Date...: 08/03/94
  
   Purpose:
     This program is necessary to change the owner of a lp queue job.  
COnly
     the owner (the user name stored in the outputq file) and root can 
Cchange
     certain characteristics of the job.
  
     Complicating this is that in order to write back out the queue ent
Cry,
     the user needs write access.  Our users are already in the LP grou
Cp, so
     we need to give group write access to the file outputq.  Everytime
C lp
     modifies the queue, the permissions get set back to group read onl
Cy.
     So for the function qchown.c to do it's job it does:
        1. chmod 664 /usr/spool/lp/outputq
        2. locks the record for the entry
        3. rereads the entry
        4. changes the entry
        5. writes the entry
        6. unlocks the record
  
     Also, in order for the chmod function to work, this program must h
Cave
     special rights (since the user can not use the chmod by itself.)  
CAfter
     compiling this program, root must issue the following 2 commands:
        1. chown lp:lp chqown
        2. chmod u+s chqown
     which says, make lp the owner of the program, and let the program 
Cassume
     then owners security when it is run (so this program acts as if it
C is
     the user lp, so it can do the chmod & the write)
  
 */
  
 #include <stdio.h>
 
 int main(argc, argv)
 int argc;
 char **argv;
 {
    short job_status;
    int numwritten;
    int next_ctr;
    int cur_ctr;
    char q_node[40];
    char q_user[40];
    char q_name[40];
    char q_job_number[8];
    char q_job_status[8];
    int q_file;
    char entry_queue[32];
    char *entry_job;
    char new_owner[16];
    int match;
    char outputq_name[40];
    strcpy(outputq_name, "/usr/spool/lp/outputq");
    if(argc != 3) {
       printf("\nSyntax:\n\n");
       printf("  cho queue-entry new-owner\n\n");
       printf("Eg.\n");
       printf("  cho hold-135 jonesp\n\n");
       exit(-1);
    } 
    match = 0;
  
    strncpy(entry_queue, argv[1], 32);
    strncpy(new_owner, argv[2], 16);
    entry_job = strchr(entry_queue, '-');
    if(entry_job == 0) {
       printf("Invalid entry name: %s\n", entry_queue);
       exit(-2);
    }
 
    *entry_job = '\0';
    entry_job += 1;
   
    q_file = qopen(outputq_name);
    if (q_file < 0) {
       printf("Can not open %s\n", outputq_name);
       exit(-3);
    }
    cur_ctr = 0;
    next_ctr = qnext(cur_ctr, q_file, q_node, q_user, q_name, q_job_num
Cber, q_job_status);
    while((next_ctr != -1) && (match == 0)) {
       job_status = atoi(q_job_status);
       if((job_status & 1) == 0) {  
          if ((strcmp(entry_queue, q_name) == 0) && (strcmp(entry_job,q
C_job_number) == 0)) {
             numwritten = qchown(cur_ctr, q_file, new_owner, entry_queu
Ce, entry_job);
             if (numwritten == 0) {
                printf("Can not change entry: %s-%s\n", entry_queue, en
Ctry_job);
                exit(-4);
             }
             match = 1;
          }
       }
       cur_ctr = next_ctr;
       next_ctr = qnext(cur_ctr, q_file, q_node, q_user, q_name, q_job_
Cnumber, q_job_status);
    }
    qclose(q_file);
    if (!match) {
       printf("Job %s-%s not found.\n", entry_queue, entry_job);
       exit(-5);
    }
    exit();
 }
 ======== END OF RECORD ===============================================
 ======== RECORD fixoutputq.c =====================     9 FIELDS ======
 #include <stdio.h>
 #include <fcntl.h>
 #include <sys/stat.h>
  
 int main()
 {
    chmod("/usr/spool/lp/outputq", S_IRUSR | S_IWUSR | S_IRGRP | S_IWGR
CP | S_IROTH);
    return(0);
 }
 ======== END OF RECORD ===============================================
 ======== RECORD qchown.c =========================    48 FIELDS ======
 #include <stdio.h>
 #include <unistd.h>
 #include "queue.h"
 
 int qchown(i_cur_entry, i_queue_file, i_user_name, i_queue_name, i_job
C_number)
 int i_cur_entry;
 long i_queue_file;
 char *i_user_name;
 char *i_queue_name;
 char *i_job_number;
 {
    char temp_queue_name[16];
    short job_number;
    struct QUEUE_ENTRY q_entry;
 
    long cur_pos;
    size_t num_read;
    size_t num_written;
  
 
    job_number = atoi(i_job_number);
  
    cur_pos = i_cur_entry * ENTRY_SIZE;
    lseek(i_queue_file, cur_pos, SEEK_SET);
    if(lockf(i_queue_file, F_LOCK, ENTRY_SIZE)) {
       return(-1);
    }
    num_read = read(i_queue_file, &q_entry, sizeof(q_entry));
    if (num_read == 0)  {
       lseek(i_queue_file, cur_pos, SEEK_SET);
       lockf(i_queue_file, F_ULOCK, ENTRY_SIZE);
       return(-2);
    }
  
    strcpy(temp_queue_name, q_entry.queue_name);
    if (strcmp(temp_queue_name, i_queue_name) != 0)
       return(-3);
    if (q_entry.job_number != job_number)
       return(-4);
  
    strncpy(q_entry.user_name, i_user_name, 16);
 
    lseek(i_queue_file, cur_pos, SEEK_SET);
    num_written = write(i_queue_file, &q_entry, sizeof(q_entry));
    lseek(i_queue_file, cur_pos, SEEK_SET);
    lockf(i_queue_file, F_ULOCK, ENTRY_SIZE);
    return((int) num_written);
 }
 ======== END OF RECORD ===============================================
 ======== RECORD qclose.c =========================     7 FIELDS ======
 #include <stdio.h>
  
 int qclose(q_file)
 int q_file;
 {
    return(close(q_file));
 }
 ======== END OF RECORD ===============================================
 ======== RECORD qnext.c ==========================    31 FIELDS ======
 #include <stdio.h>
 #include "queue.h"
 
 int qnext(i_last_entry, i_queue_file, o_node_name, o_user_name, o_queu
Ce_name, o_job_number,o_job_status)
 int i_last_entry;
 int i_queue_file;
 char *o_node_name;
 char *o_user_name;
 char *o_queue_name;
 char *o_job_number;
 char *o_job_status;
 {
    struct QUEUE_ENTRY q_entry;
    int cur_entry;
    long cur_pos;
    size_t num_read;
  
    cur_entry = i_last_entry;
    cur_pos = cur_entry * ENTRY_SIZE;
    lseek(i_queue_file, cur_pos, SEEK_SET);
    num_read = read(i_queue_file, &q_entry, sizeof(q_entry));
    strcpy(o_node_name, q_entry.node_name);
    strcpy(o_user_name, q_entry.user_name);
    strcpy(o_queue_name, q_entry.queue_name);
    sprintf(o_job_number, "%d", q_entry.job_number);
    sprintf(o_job_status, "%d", q_entry.job_status);
    if (num_read == 0) 
       return(-1);
    else
       return(cur_entry+1);
 }
 ======== END OF RECORD ===============================================
 ======== RECORD qopen.c ==========================    10 FIELDS ======
 #include <stdio.h>
 #include <fcntl.h>
 #include <sys/stat.h>
  
 int qopen(i_file_name)
 char *i_file_name;
 {
    chmod(i_file_name, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH)
C;
    return(open(i_file_name, O_RDWR));
 }
 ======== END OF RECORD ===============================================
 ### END OF FILE ######################################################
 ##### FILE UDTWORK ###############################    1 RECORDS ######
 ======== RECORD cfuncdef =========================    28 FIELDS ======
 /* this is a file for adding C function to the RUN Machine */
 /* typically, this file is in /usr/ud/work and             */
 /* is called 'cfuncdef'                                    */
 /* C function declaration format:
 function-name:return-type:number-of-argument:arg1,arg2,...,argn
 */
 $$FUN	/* begining of C function */
 XOSDIO_COUNT_ARGS:int:1:string
 XOSDIO_NEXT_ARG:int:1:string
 XOSDIO_STATUS_RECORD:int:1:int
 XOSDIO_ERROR_RECORD:int:1:string
 XOSDIO_SUB_PARM_RECORD:int:17:int,string,string,string,string,string,s
Ctring,string,string,string,string,string,string,string,string,string,s
Ctring
 XOSDIO_NULL_RECORD:int:0:
 XOSDIO_WRITE:int:1:string
 uni_get_userid:int:2:string,string
 c_qopen:long:1:string
 c_qclose:int:1:long
 c_qnext:int:7:int,int,string,string,string,string,string
 c_finfo:int:2:string,string
 $$OBJ	/* *.o come here */
 xbasic.o
 uni_get_userid.o
 dummy.o
 /disk1/locsrc/cprogs/c_qopen.o
 /disk1/locsrc/cprogs/c_qclose.o
 /disk1/locsrc/cprogs/c_qnext.o
 /disk1/locsrc/cprogs/c_finfo.o
 $$LIB	/* library comes here */
 ======== END OF RECORD ===============================================
 ### END OF FILE ######################################################
 ##### FILE CUSTOM.SOURCE #########################    4 RECORDS ######
 ======== RECORD VIEW.SPOOL.SCREEN ================    26 FIELDS ======
 SAMPLE VIEW.SPOOL SCREEN
  
 :VS -MENU
 Display spool queue entries                                          V
CIEW.SPOOL
 
 Request Time   User        File                      No Size    Queue 
C Status
 ------- ----- ------------ ------------------------- -- ------- ------
C --------
 30 Jun 1995
    6062 19:04 kingj        ERRORS                     1     458 hold
    6357 19:04 westn        /tmp/PRT0a22683            1   61496 hold
    6366 19:04 westn        VOUREP                     1     109 hold
    6468 19:04 colel        COLEL                      1     514 hold
    6469 19:04 colel        COLEL                      1     514 hold
    6538 07:18 rotmand      BALDTL                     1  107932 hold
 03 Jul 1995
    6539 07:18 rotmand      REVDTL                     1   60921 hold
    6540 07:19 rotmand      ARBLUE                     1   80671 hold
    6546 07:32 rotmand      AR_RECONCILE.ALL           1  322871 GREEN2
    6605 09:21 sjoquist     BLANK3                     1   20726 BLANK3
    6606 09:21 sjoquist     BLANK3                     1    2740 BLANK3
    6610 09:23 rotmand      REVSCH                     1   28567 BLANK2
C printing
    6611 09:23 rotmand      BALDTL                     1   12420 BLANK2
    6612 09:23 rotmand      REVDTL                     1   13500 BLANK2
    6613 09:23 rotmand      BALSHE                     1   17694 BLANK2
 Page 1 of 2
 (M)ail, (P)age, (R)edisplay, (V)iew, (CA)ncel, (F)orm, (CO)pies, (ED)i
Ct:
 ======== END OF RECORD ===============================================
 ======== RECORD VIEW.SPOOL =======================   862 FIELDS ======
 *
 * INFO/BASIC PROGRAM
 * 6/20/90
 * DWS
 * TITLE ----- VIEW.SPOOL
 *
 *
 * PURPOSE: VIEW SPOOL QUEUE ENTRIES WITH OPTION
 *
 * Stamped: pty/ttyp2 sjoquist, /disk1/coltest, user #2435, 23 Jun 94, 
C08:44AM.
 * Rewrite for HP
 *     Last updated by LIVE (ROTMAN) at 13:47:49 on 08/23/1991.
 * Start a rudimentary help paragraph.
 *     Last updated by LIVE (ROTMAN) at 12:37:26 on 07/31/1991.
 * Shorten queue-entry and attribute columns so that file.name column
 * can be longer.
 *     Last updated by LIVE (SJOQUIST) at 15:23:26 on 06/20/1990.
 *
 **********************************************************************
C***
 *
 
       $INCLUDE LOCAL.SOURCE I_C26.STANDARD
       $INSERT I_SPQUEUE.COMMON
 
 
 *
 *
 * MAIN CONTROL
 *
 
       GOSUB SET.UP
       GOSUB PROCESS.COMMAND.LINE
       GOSUB LOAD.ITEMS
       BEGIN CASE
          CASE NUM.CL.OPTIONS > 0
             GOSUB PROCESS.OPTION.LIST
          CASE MENU.DISPLAY
             GOSUB DISPLAY.HEADINGS
             CURRENT.PAGE = LAST.PAGE
             GOSUB DISPLAY.PAGE
             GOSUB PROCESS.MENU
          CASE 1
             GOSUB LIST.ITEMS
       END CASE
       STOP
 
 
 
 *
 *
 *
 SET.UP: 
       ON.ERROR.RETURN = @FALSE
       ERRMSG = ''
       F.INFO.USERS = ''
       CALL OPEN.FILE(F.INFO.USERS, 'INFO.USERS', ON.ERROR.RETURN, ERRM
CSG)
       READ INFO.USERS.REC FROM F.INFO.USERS, @LOGNAME ELSE
          INFO.USERS.REC = ''
       END
       IUR.EDIT.SPOOL.QUEUE.OKAY = INFO.USERS.REC<16>
 *
       MAX.ITEMS = 999
       DIM ITEM.LINE(MAX.ITEMS)
       LINES.PER.PAGE = 17
       LINE.OFFSET = 3
       NO.ITEMS.MSG = 'There are no items in the spool queue to display
C.'
       DISPLAY.PROMPT = '(M)ail, (P)age, (R)edisplay, (V)iew, (CA)ncel,
C (F)orm, (CO)pies'
       IF IUR.EDIT.SPOOL.QUEUE.OKAY THEN
          DISPLAY.PROMPT := ', (ED)it'
       END
       ANSWER.LIST = ''
       DEFAULT.ANSWER = ''
       NULL.ANSWER.LIST = ''
       NULL.DEFAULT.ANSWER = ''
       CRT.COL = 0
       PROMPT.COL = 0
       PROMPT.LINE = 22
       CRT.LINE = 0
       END.PARAM = 2
       MENU.DISPLAY = @FALSE
       PROGRAM = 'VIEW.SPOOL'
       PROGRAM.TITLE = 'Display spool queue entries'
       GAP = 79 - LEN(PROGRAM) - LEN(PROGRAM.TITLE)
       HDG1 = PROGRAM.TITLE:SPACE(GAP):PROGRAM
       HDG2 = 'Request Time   User        File                      No 
CSize    Queue  Status'
       HDG3 = '------- ----- ------------ ------------------------- -- 
C------- ------ --------'
       RETURN
 
 
 *
 *
 * PROCESS COMMAND.LINE
 *
 PROCESS.COMMAND.LINE: 
       COMMAND.LINE = @SENTENCE
       PARAM.LIST = ''
       PARAM.QUOTED.LIST = ''
       NUM.PARAMS = 0
       CALL PARSE.LINE(COMMAND.LINE,PARAM.LIST,PARAM.QUOTED.LIST,NUM.PA
CRAMS)
       IF PARAM.LIST<1> = 'RUN' THEN
          PARAM.CTR = 3
       END ELSE
          PARAM.CTR = 1
       END
 *
       CURRENT.LIST.TYPE = ''
       PARAM.USER.USED = @FALSE
       CL.USER.LIST = ''
       CL.FORM.LIST = ''
       CL.OPTION.LIST = ''
       NUM.CL.OPTIONS = 0
       LOOP
          PARAM.CTR += 1
       UNTIL PARAM.CTR > NUM.PARAMS
          PARAM = PARAM.LIST<PARAM.CTR>
          ORIG.PARAM = PARAM
          PARAM.QUOTED = PARAM.QUOTED.LIST<PARAM.CTR>
          IF NOT(PARAM.QUOTED) THEN
             PARAM = OCONV(PARAM,'MCU')
          END
          BEGIN CASE
             CASE PARAM = 'HELP' OR PARAM = '-HELP'
                GOSUB DISPLAY.HELP
                STOP
             CASE PARAM.QUOTED
                GOSUB ADD.PARAM.TO.LIST
             CASE PARAM = '-USER'
                CURRENT.LIST.TYPE = 'USER'
                PARAM.USER.USED = @TRUE
             CASE PARAM = '-FORM'
                CURRENT.LIST.TYPE = 'FORM'
             CASE PARAM = '-MENU'
                MENU.DISPLAY = @TRUE
             CASE PARAM = '-OPTION' OR PARAM = '-OPTIONS'
                CURRENT.LIST.TYPE = 'OPTION'
                NUM.CL.OPTIONS += 1
             CASE 1
                GOSUB ADD.PARAM.TO.LIST
          END CASE
       REPEAT
 *
       IF PARAM.USER.USED AND CL.USER.LIST = '' THEN
          CL.USER.LIST = @LOGNAME
       END
       NUM.CL.FORMS = COUNT(CL.FORM.LIST,@FM) + (CL.FORM.LIST # '')
       GOSUB DETERMINE.USERS.TO.VIEW
       RETURN
 
 
 DISPLAY.HELP: 
       CRT
       CRT 'VIEW.SPOOL provides an alternative method to control spool 
Cqueue entries.'
       CRT
       CRT 'The command may be entered without any options, or the foll
Cowing options'
       CRT 'could be used:'
       CRT '  -USER user [user]       (restricts viewing to those users
C only)'
       CRT '  -FORM form# [form#]       (restricts viewing to those for
Cms only)'
       CRT '  -MENU'
       CRT '  -OPTIONS FORM form# newFormName'
       CRT '  -OPTIONS COPIES form# #copies'
       CRT '  -OPTIONS CANCEL form# [form#]'
       CRT '  -OPTIONS VIEW form# [form#]'
       CRT '  -OPTIONS LIST'
       IF IUR.EDIT.SPOOL.QUEUE.OKAY THEN
          CRT '  -OPTIONS EDIT form# [form#]'
       END
       RETURN
 
 
 
 
 
 *
 *
 * ADD PARAM TO LIST
 *
 ADD.PARAM.TO.LIST: 
       BEGIN CASE
          CASE CURRENT.LIST.TYPE = 'USER'
             CL.USER.LIST<-1> = ORIG.PARAM
          CASE CURRENT.LIST.TYPE = 'FORM'
             CL.FORM.LIST<-1> = ORIG.PARAM
          CASE CURRENT.LIST.TYPE = 'OPTION'
             CL.OPTION.LIST<NUM.CL.OPTIONS,-1> = ORIG.PARAM
          CASE 1
             CRT 'Not expecting ':PARAM.QUOTED:ORIG.PARAM:PARAM.QUOTED:
C' here.'
       END CASE
       RETURN
 
 
 *
 *
 *
 * DETERMIME WHO TO VIEW
 *
 DETERMINE.USERS.TO.VIEW: 
       VIEW.ALL.USERS = @FALSE
       VS.USER.LIST = CL.USER.LIST
 *
       IUR.VS.USER.LIST = INFO.USERS.REC<15>
       CONVERT @VM TO @FM IN IUR.VS.USER.LIST
       LOCATE @LOGNAME IN IUR.VS.USER.LIST<1> SETTING POS ELSE
          IUR.VS.USER.LIST<-1> = @LOGNAME
       END
 *
 * IF THIS PERSON CAN VIEW ALL (FIELD 15 IN INFO.USERS SET TO $ALL)
 * THEN CHECK IF LIST OF USERS SPECIFIED ON COMMAND LINE
 * ELSE SET VIEW.ALL.USERS TO TRUE
 *
 * IF THE PERSON CAN VIEW ONLY SELECTED PEOPLE, THEN CROSS CHECK
 * COMMAND LINE ENTRIES (IF ANY) WITH INFO.USERS VS.USER.LIST (F15)
 *
       LOCATE '$ALL' IN IUR.VS.USER.LIST<1> SETTING POS THEN
          IF VS.USER.LIST = '' THEN
             VIEW.ALL.USERS = @TRUE
          END
       END ELSE
          IF VS.USER.LIST = '' THEN
             VS.USER.LIST = IUR.VS.USER.LIST
          END ELSE
             NUM.VUL = COUNT(VS.USER.LIST,@FM) + 1
             NEW.VU.LIST = ''
             FOR VUL.CTR=1 TO NUM.VUL
                LOCATE VS.USER.LIST<VUL.CTR> IN IUR.VS.USER.LIST<1> SET
CTING POS THEN
                   NEW.VU.LIST<-1> = VS.USER.LIST<VUL.CTR>
                END
             NEXT VUL.CTR
             VS.USER.LIST = NEW.VU.LIST
             IF VS.USER.LIST = '' THEN
                VS.USER.LIST = @LOGNAME
             END
          END
       END
       RETURN
 
 
 *
 *
 * LOAD ITEMS
 *
 LOAD.ITEMS: 
       RETURN.STATUS = ''
       CALL LOAD.SPOOL.QUEUE(RETURN.STATUS)
       IF RETURN.STATUS # '' THEN
          MSG = 'ERROR ON SPOOL QUEUE: ':RETURN.STATUS<1>
          CALL LINE.22(MSG)
          STOP
       END
 *
 * CHECK FOR PRINTING JOBS
 *
       SEARCH.TEXT = 'now printing'
       LPSTAT.COMMAND = 'lpstat -p|grep "':SEARCH.TEXT:'"'
       PCPERFORM LPSTAT.COMMAND CAPTURING LPSTAT.TEXT
       CONVERT CHAR(10) TO @FM IN LPSTAT.TEXT
       NUM.TEXT.LINES = COUNT(LPSTAT.TEXT,@FM)
       PRINTING.JOB.LIST = ''
       FOR LINE.CTR=1 TO NUM.TEXT.LINES
          TEXT.LINE = LPSTAT.TEXT<LINE.CTR>
          JOB.POS = INDEX(TEXT.LINE, SEARCH.TEXT, 1) + LEN(SEARCH.TEXT)
C + 1
          JOB.NAME = FIELD(TEXT.LINE[JOB.POS,100],'.',1,1)
          PRINTING.JOB.LIST<-1> = JOB.NAME
       NEXT LINE.CTR
 *
       PREV.DATE = ''
       NUM.ITEMS = 0
       MAT ITEM.LINE = ''
       FOR Q.CTR=1 TO SPQUEUE.NUM.ENTRIES
          GOSUB CHECK.IF.OKAY.TO.VIEW
          IF VIEW.THIS.ENTRY THEN
             GOSUB ADD.QUEUE.ENTRY.TO.ITEMS
             PREV.DATE = SPQUEUE.DATE(Q.CTR)
          END
       NEXT Q.CTR
       LAST.PAGE = INT((NUM.ITEMS - 1)/LINES.PER.PAGE) + 1
       IF NUM.ITEMS = 0 THEN
          MSG = NO.ITEMS.MSG
          GOSUB DISPLAY.MSG
          STOP
       END
       RETURN
 
 
 *
 *
 * CHECK LISTS TO SEE IF IT IS OKAY TO VIEW THIS ITEM
 *
 CHECK.IF.OKAY.TO.VIEW: 
       VIEW.THIS.ENTRY = @FALSE
       IF VIEW.ALL.USERS THEN
          VIEW.THIS.ENTRY = @TRUE
       END ELSE
          LOCATE SPQUEUE.USER.NAME(Q.CTR) IN VS.USER.LIST<1> SETTING PO
CS THEN
             VIEW.THIS.ENTRY = @TRUE
          END
       END
       IF NUM.CL.FORMS > 0 THEN
          LOCATE SPQUEUE.FORM.NAME(Q.CTR) IN CL.FORM.LIST<1> SETTING PO
CS ELSE
             VIEW.THIS.ENTRY = @FALSE
          END
       END
       RETURN
 
 
 *
 *
 * ADD THIS QUEUE ENTRY TO THE LIST OF ITEMS TO USE
 *
 ADD.QUEUE.ENTRY.TO.ITEMS: 
       IF SPQUEUE.DATE(Q.CTR) # PREV.DATE THEN
          LINE = OCONV(SPQUEUE.DATE(Q.CTR),'D')
          LINE = LINE[1,4]:OCONV(LINE[5,99],'MCL')
          NUM.ITEMS += 1
          ITEM.LINE(NUM.ITEMS) = LINE
       END
       LINE = FMT(SPQUEUE.ENTRY.NUMBER.LIST<Q.CTR>,'7R'):' '
       LINE := OCONV(SPQUEUE.TIME(Q.CTR),'MT'):' '
       LINE := FMT(SPQUEUE.USER.NAME(Q.CTR),'12L')[1,12]:' '
       TITLE = SPQUEUE.TITLE(Q.CTR)
       FILE.NAME = SPQUEUE.FILE.NAME(Q.CTR)
       IF TITLE THEN
          DISPLAY.TITLE = TITLE
       END ELSE
          DISPLAY.TITLE = FILE.NAME
       END
       LINE := FMT(DISPLAY.TITLE[25],'25L')
       LINE := FMT(SPQUEUE.COPIES(Q.CTR),'3R')
       LINE := FMT(SPQUEUE.SIZE(Q.CTR),'8R'):' '
       LINE := FMT(SPQUEUE.FORM.NAME(Q.CTR),'6L')[1,6]:' '
       JOB.NAME = SPQUEUE.FORM.NAME(Q.CTR):'-':SPQUEUE.ENTRY.NUMBER.LIS
CT<Q.CTR>
       LOCATE JOB.NAME IN PRINTING.JOB.LIST<1> SETTING POS THEN
          LINE := 'printing'
       END
       NUM.ITEMS += 1
       ITEM.LINE(NUM.ITEMS) = LINE
       RETURN
 
 
 *
 *
 * LIST ITEM
 *
 LIST.ITEMS: 
 *DWS      CRT HDG1
       CRT HDG2
       CRT HDG3
       FOR ITEM.NUM = 1 TO NUM.ITEMS
          CRT ITEM.LINE(ITEM.NUM)
       NEXT ITEM.NUM
       RETURN
 
 
 
 *
 * DISPLAY HEADINGS
 *
 DISPLAY.HEADINGS: 
       CRT CLEAR.SCREEN
       CRT @(0,0):HDG1
       CRT @(0,2):HDG2
       CRT @(0,3):HDG3
       RETURN
 
 
 
 *
 *
 * PROCESS COMMANDS
 *
 PROCESS.MENU: 
       LOOP
          COMMAND = ''
          CALL PROMPT.ANS(COMMAND,DISPLAY.PROMPT,PROMPT.COL,PROMPT.LINE
C,ANSWER.LIST,DEFAULT.ANSWER,END.PARAM)
          UC.COMMAND = OCONV(COMMAND,'MCU')
       UNTIL UC.COMMAND = 'E' OR UC.COMMAND = 'Q' DO
          GOSUB PROCESS.COMMAND
       REPEAT
       RETURN
 
 
 PROCESS.OPTION.LIST: 
       FOR OPTION.CTR=1 TO NUM.CL.OPTIONS
          OPTION = OCONV(CL.OPTION.LIST<OPTION.CTR,1>,'MCU')
          REST.OF.LINE = FIELD(CL.OPTION.LIST<OPTION.CTR>,@VM,2,9999)
          CONVERT @VM TO ' ' IN REST.OF.LINE
          GOSUB PROCESS.OPTION
       NEXT OPTION.CTR
       RETURN
 
 
 *
 *
 * PROCESS AN OPTION
 *
 PROCESS.OPTION: 
       BEGIN CASE
          CASE OPTION = 'EDIT' AND IUR.EDIT.SPOOL.QUEUE.OKAY
             GOSUB PROCESS.EDIT
          CASE OPTION = 'VIEW'
             GOSUB PROCESS.VIEW
          CASE OPTION = 'CANCEL'
             GOSUB PROCESS.CANCEL
          CASE OPTION = 'FORM'
             GOSUB PROCESS.FORM
          CASE OPTION = 'LIST'
             GOSUB LIST.ITEMS
          CASE OPTION = 'COPIES'
             GOSUB PROCESS.COPIES
       END CASE
       RETURN
 
 
 
 *
 *
 * PROCESS A COMMAND
 *
 PROCESS.COMMAND: 
       NEED.REDISPLAY = @FALSE
       CMD1 = UC.COMMAND[1,1]
       REST1 = COMMAND[2,80]
       CMD2 = UC.COMMAND[1,2]
       REST2 = COMMAND[3,80]
       REST.OF.LINE = ''
       BEGIN CASE
          CASE CMD1 = 'P'
             REST.OF.LINE = REST1
             GOSUB PROCESS.PAGE
          CASE UC.COMMAND = 'R'
             NEED.REDISPLAY = @TRUE
          CASE CMD2 = 'ED' AND IUR.EDIT.SPOOL.QUEUE.OKAY
             REST.OF.LINE = REST2
             GOSUB PROCESS.EDIT
          CASE CMD1 = 'V'
             REST.OF.LINE = REST1
             GOSUB PROCESS.VIEW
          CASE CMD1 = 'M'
             REST.OF.LINE = REST1
             GOSUB PROCESS.MAIL
          CASE CMD2 = 'CA'
             REST.OF.LINE = REST2
             GOSUB PROCESS.CANCEL
          CASE CMD1 = 'F'
             REST.OF.LINE = REST1
             GOSUB PROCESS.FORM
          CASE CMD2 = 'CO'
             REST.OF.LINE = REST2
             GOSUB PROCESS.COPIES
          CASE COMMAND = ''
             GOSUB PROCESS.FORWARD
       END CASE
       IF NEED.REDISPLAY THEN
          GOSUB PROCESS.REDISPLAY
       END
       RETURN
 
 
 *
 *
 * PROCESS.FORWARD
 *
 PROCESS.FORWARD: 
       IF CURRENT.PAGE = LAST.PAGE THEN
          CURRENT.PAGE = 1
       END ELSE
          CURRENT.PAGE += 1
       END
       IF LAST.PAGE # 1 THEN
          GOSUB DISPLAY.PAGE
       END
       RETURN
 
 
 *
 *
 * PROCESS.PAGE
 *
 PROCESS.PAGE: 
       PAGE.NO = REST.OF.LINE
       IF PAGE.NO = '' THEN
          CALL PROMPT.ANS(PAGE.NO,'Page #',PROMPT.COL,PROMPT.LINE,NULL.
CANSWER.LIST,NULL.DEFAULT.ANSWER,END.PARAM)
       END
       IF NOT(NUM(PAGE.NO)) THEN
          MSG = '"':PAGE.NO:'" is not a valid page number.'
          CALL LINE.22(MSG)
       END ELSE
          IF PAGE.NO < 1 OR PAGE.NO > LAST.PAGE THEN
             MSG = 'Page number must be from 1 to ':LAST.PAGE:'.'
             CALL LINE.22(MSG)
          END ELSE
             CURRENT.PAGE = PAGE.NO
             GOSUB DISPLAY.PAGE
          END
       END
       RETURN
 
 
 
 *
 *
 * REDISPLAY
 *
 PROCESS.REDISPLAY: 
       GOSUB LOAD.ITEMS
       GOSUB DISPLAY.HEADINGS
       CURRENT.PAGE = LAST.PAGE
       GOSUB DISPLAY.PAGE
       RETURN
 
 
 *
 *
 * VIEW SPOOL FILE
 *
 PROCESS.VIEW: 
       CONVERT ',' TO ' ' IN REST.OF.LINE
       ENTRY.NUMBER.LIST = TRIM(REST.OF.LINE)
       GOSUB GET.VALID.ENTRY.NUMBERS
       IF VALID.ENTRY.NUMBERS THEN
          IF NUM.ENTRY.NUMBERS = 1 THEN
             OSOPEN SPQUEUE.SPOOL.NAME(ENTRY.POS.LIST<1>) TO F.OS.FILE 
CTHEN
                HEADING.TEXT = 'Spool entry #':ENTRY.NUMBER
                OS.POS = 0
                CALL VIEW.OS.FILE(F.OS.FILE, OS.POS, HEADING.TEXT)
                OSCLOSE F.OS.FILE
                NEED.REDISPLAY = @TRUE
             END ELSE
                MSG = 'Can not open "':SPQUEUE.SPOOL.NAME(ENTRY.POS.LIS
CT<1>):'"'
                CALL LINE.22(MSG)
             END
          END ELSE
             MSG = 'You may only view one entry at a time.'
             CALL LINE.22(MSG)
          END
       END
       RETURN
 
 
 *
 *
 * MAIL SPOOL FILE
 *
 PROCESS.MAIL: 
       CONVERT ',' TO ' ' IN REST.OF.LINE
       TEMP.LINE = TRIM(REST.OF.LINE)
       ENTRY.NUMBER.LIST = FIELD(TEMP.LINE,' ',1,1)
       GOSUB GET.VALID.ENTRY.NUMBERS
       IF VALID.ENTRY.NUMBERS THEN
          IF NUM.ENTRY.NUMBERS = 1 THEN
             ADDRESSEE = FIELD(TEMP.LINE,' ',2,1)
             IF ADDRESSEE = '' THEN
                GOSUB GET.ADDRESSEE
             END
             IF ADDRESSEE # '' THEN
                SENDER = @LOGNAME
                CALL SEND.SPOOL.FILE.NETWORK(RETURN.MESSAGE, ADDRESSEE,
C SENDER, ENTRY.NUMBER.LIST)
             END
          END ELSE
             MSG = 'You may only mail one entry at a time.'
             CALL LINE.22(MSG)
          END
       END
       RETURN
 
 
 
 *
 *
 * GET VALID ENTRY NUMBER
 *
 GET.VALID.ENTRY.NUMBERS: 
       IF ENTRY.NUMBER.LIST = '' THEN
          CALL PROMPT.ANS(ENTRY.NUMBER.LIST,'Entry number(s)',PROMPT.CO
CL,PROMPT.LINE,NULL.ANSWER.LIST,NULL.DEFAULT.ANSWER,END.PARAM)
          CONVERT ',' TO ' ' IN REST.OF.LINE
          ENTRY.NUMBER.LIST = TRIM(ENTRY.NUMBER.LIST)
       END
       IF ENTRY.NUMBER.LIST = '' THEN
          VALID.ENTRY.NUMBERS = @FALSE
          RETURN
       END
       VALID.ENTRY.NUMBERS = @TRUE
       NUM.ENTRY.NUMBERS = COUNT(ENTRY.NUMBER.LIST,' ') + 1
       ENTRY.POS.LIST = ''
       ENTRY.NAME.LIST = ''
       ENTRY.USER.LIST = ''
       FOR ENTRY.CTR=1 TO NUM.ENTRY.NUMBERS
          ENTRY.NUMBER = FIELD(ENTRY.NUMBER.LIST,' ',ENTRY.CTR,1)
          LOCATE ENTRY.NUMBER IN SPQUEUE.ENTRY.NUMBER.LIST<1> SETTING E
CNTRY.POS THEN
             ENTRY.POS.LIST<ENTRY.CTR> = ENTRY.POS
             ENTRY.NAME.LIST<ENTRY.CTR> = SPQUEUE.FORM.NAME(ENTRY.POS):
C'-':ENTRY.NUMBER
             ENTRY.USER.LIST<ENTRY.CTR> = SPQUEUE.USER.NAME(ENTRY.POS)
          END ELSE
             VALID.ENTRY.NUMBERS = @FALSE
             MSG = 'Entry number ':ENTRY.NUMBER:' does not exist.'
             GOSUB DISPLAY.MSG
          END
       NEXT ENTRY.CTR
       RETURN
 
 
 *
 *
 * GET FORM NAME
 *
 GET.FORM.NAME: 
       FORM.NAME = ''
       CALL PROMPT.ANS(FORM.NAME,'Form name',PROMPT.COL,PROMPT.LINE,NUL
CL.ANSWER.LIST,NULL.DEFAULT.ANSWER,END.PARAM)
       RETURN
 
 
 *
 *
 * GET ADDRESSEE
 *
 GET.ADDRESSEE: 
       ADDRESSEE = ''
       CALL PROMPT.ANS(ADDRESSEE,'To',PROMPT.COL,PROMPT.LINE,NULL.ANSWE
CR.LIST,NULL.DEFAULT.ANSWER,END.PARAM)
       RETURN
 
 
 *
 *
 * GET VALID NUM.COPIES
 *
 GET.VALID.NUM.COPIES: 
       VALID.NUM.COPIES = @FALSE
       NUM.COPIES = ''
       CALL PROMPT.ANS(NUM.COPIES,'Number of copies',PROMPT.COL,PROMPT.
CLINE,NULL.ANSWER.LIST,NULL.DEFAULT.ANSWER,END.PARAM)
       IF NUM.COPIES # '' THEN
          IF NOT(NUM(NUM.COPIES)) OR NUM.COPIES < 1 THEN
             MSG = '"':NUM.COPIES:'" is not a valid number of copies.'
             GOSUB DISPLAY.MSG
          END ELSE
             VALID.NUM.COPIES = @TRUE
          END
       END
       RETURN
 
 
 
 *
 *
 * EDIT JOBS
 *
 PROCESS.EDIT: 
       CONVERT ',' TO ' ' IN REST.OF.LINE
       ENTRY.NUMBER.LIST = TRIM(REST.OF.LINE)
       GOSUB GET.VALID.ENTRY.NUMBERS
       IF VALID.ENTRY.NUMBERS THEN
          EDIT.COMMAND = 'vi'
          FOR ENTRY.CTR=1 TO NUM.ENTRY.NUMBERS
             EDIT.COMMAND := ' ':SPQUEUE.SPOOL.NAME(ENTRY.POS.LIST<1>)
          NEXT ENTRY.CTR
          PCPERFORM EDIT.COMMAND
          IF NUM.CL.OPTIONS = 0 THEN
             CRT 'Press Return to continue: ':
             INPUT ANS
          END
       END
       NEED.REDISPLAY = @TRUE
       RETURN
 
 
 
 *
 *
 * CANCEL JOBS
 *
 PROCESS.CANCEL: 
       CONVERT ',' TO ' ' IN REST.OF.LINE
       ENTRY.NUMBER.LIST = TRIM(REST.OF.LINE)
       GOSUB GET.VALID.ENTRY.NUMBERS
       IF VALID.ENTRY.NUMBERS THEN
          FOR ENTRY.CTR=1 TO NUM.ENTRY.NUMBERS
             SPOOL.COMMAND = 'cancel ':ENTRY.NAME.LIST<ENTRY.CTR>
             PCPERFORM SPOOL.COMMAND
          NEXT ENTRY.CTR
          IF NUM.CL.OPTIONS = 0 THEN
             CRT 'Press Return to continue: ':
             INPUT ANS
          END
       END
       NEED.REDISPLAY = @TRUE
       RETURN
 
 
 *
 *
 * CHANGE FORM FOR ENTRIES
 *
 PROCESS.FORM: 
       CONVERT ',' TO ' ' IN REST.OF.LINE
       REST.OF.LINE = TRIM(REST.OF.LINE)
       IF REST.OF.LINE # '' THEN
          ENTRY.NUMBER.LIST = FIELD(REST.OF.LINE,' ',1,1)
          GOSUB GET.VALID.ENTRY.NUMBERS
          IF VALID.ENTRY.NUMBERS THEN
             FORM.NAME = FIELD(REST.OF.LINE,' ',2,1)
             IF FORM.NAME = '' THEN
                GOSUB GET.FORM.NAME
             END
          END
       END ELSE
          ENTRY.NUMBER.LIST = ''
          GOSUB GET.VALID.ENTRY.NUMBERS
          IF VALID.ENTRY.NUMBERS THEN
             GOSUB GET.FORM.NAME
          END
       END
       IF VALID.ENTRY.NUMBERS THEN
          NUM.ERRORS = 0
          SPOOL.ERRORS = ''
          FOR ENTRY.CTR=1 TO NUM.ENTRY.NUMBERS
             LPALT.ENTRY = ENTRY.NAME.LIST<ENTRY.CTR>
             LPALT.USER = ENTRY.USER.LIST<ENTRY.CTR>
             LPALT.OPTIONS = ' -d':FORM.NAME
             GOSUB DO.LPALT
             IF LPALT.MESSAGE[1,18] # 'new request id is ' THEN
                NUM.ERRORS += 1
                SPOOL.ERRORS<NUM.ERRORS> = LPALT.MESSAGE
             END
          NEXT ENTRY.CTR
          IF NUM.ERRORS > 0 THEN
             FOR ERR.CTR=1 TO NUM.ERRORS
                CRT SPOOL.ERRORS<ERR.CTR>
             NEXT ERR.CTR
             IF NUM.CL.OPTIONS = 0 THEN
                CRT 'Press Return to continue: ':
                INPUT ANS
             END
          END
          NEED.REDISPLAY = @TRUE
       END
       RETURN
 
 
 *
 *
 * PROCESS COPIES
 *
 PROCESS.COPIES: 
       CONVERT ',' TO ' ' IN REST.OF.LINE
       REST.OF.LINE = TRIM(REST.OF.LINE)
       IF REST.OF.LINE # '' THEN
          ENTRY.NUMBER.LIST = FIELD(REST.OF.LINE,' ',1,1)
          GOSUB GET.VALID.ENTRY.NUMBERS
          IF VALID.ENTRY.NUMBERS THEN
             NUM.COPIES = FIELD(REST.OF.LINE,' ',2,1)
             VALID.NUM.COPIES = @TRUE
             IF NUM.COPIES # '' THEN
                IF NOT(NUM(NUM.COPIES)) OR NUM.COPIES < 1 THEN
                   VALID.NUM.COPIES = @FALSE
                   MSG = '"':NUM.COPIES:'" is not a valid number of cop
Cies'
                   GOSUB DISPLAY.MSG
                END
             END ELSE
                GOSUB GET.VALID.NUM.COPIES
             END
          END
       END ELSE
          ENTRY.NUMBER.LIST = ''
          GOSUB GET.VALID.ENTRY.NUMBERS
          IF VALID.ENTRY.NUMBERS THEN
             GOSUB GET.VALID.NUM.COPIES
          END
       END
       IF VALID.ENTRY.NUMBERS THEN
          IF VALID.NUM.COPIES THEN
             NUM.ERRORS = 0
             SPOOL.ERRORS = ''
             FOR ENTRY.CTR=1 TO NUM.ENTRY.NUMBERS
                LPALT.ENTRY = ENTRY.NAME.LIST<ENTRY.CTR>
                LPALT.USER = ENTRY.USER.LIST<ENTRY.CTR>
                LPALT.OPTIONS = ' -n':NUM.COPIES
                GOSUB DO.LPALT
                IF LPALT.MESSAGE THEN
                   NUM.ERRORS += 1
                   SPOOL.ERRORS<NUM.ERRORS> = LPALT.MESSAGE
                END
             NEXT ENTRY.CTR
             IF NUM.ERRORS > 0 THEN
                FOR ERR.CTR=1 TO NUM.ERRORS
                   CRT SPOOL.ERRORS<ERR.CTR>
                NEXT ERR.CTR
                IF NUM.CL.OPTIONS = 0 THEN
                   CRT 'Press Return to continue: ':
                   INPUT ANS
                END
             END
          END
       END
       NEED.REDISPLAY = @TRUE
       RETURN
 
 
 *
 * Note: by using 'lpalt -dNEWFORM old-job' to change a form name
 *       leaves the new job without the appropriate rights set for
 *       group lp to access it.  By waiting 1 second, and then executin
Cg
 *       'lpstat -t', lpstat sets the rights correctly.
 *
 DO.LPSTAT: 
       SLEEP 1
       SPOOL.COMMAND = 'lpstat -t'
       PCPERFORM SPOOL.COMMAND CAPTURING SPOOL.MESSAGE
       RETURN
 
 
 DO.LPALT: 
       LPALT.MESSAGE = ''
       IF @LOGNAME # LPALT.USER THEN
          CHQOWN.COMMAND = '/disk1/locsrc/cprogs/chqown ':LPALT.ENTRY:'
C ':@LOGNAME
          PCPERFORM CHQOWN.COMMAND CAPTURING LPALT.MESSAGE
       END
       IF LPALT.MESSAGE = '' THEN
          LPALT.COMMAND = 'lpalt ':LPALT.OPTIONS:' ':LPALT.ENTRY
          PCPERFORM LPALT.COMMAND CAPTURING LPALT.MESSAGE
          GOSUB DO.LPSTAT
          IF LPALT.MESSAGE[1,18] = 'new request id is ' THEN
             LPALT.NEW.ENTRY = TRIM(LPALT.MESSAGE<1>[19,80])
             IF @LOGNAME # LPALT.USER THEN
                CHQOWN.COMMAND = '/disk1/locsrc/cprogs/chqown ':LPALT.N
CEW.ENTRY:' ':LPALT.USER
                PCPERFORM CHQOWN.COMMAND CAPTURING CHQOWN.MESSAGE
             END
          END
       END
       RETURN
 
 
 
 *
 *
 *
 DISPLAY.PAGE: 
       END.ITEM = CURRENT.PAGE * LINES.PER.PAGE
       START.ITEM = END.ITEM - (LINES.PER.PAGE - 1)
       CRT.LINE = LINE.OFFSET
       CRT @(0,LINE.OFFSET+1):CLEAR.EOS
       IF END.ITEM > NUM.ITEMS THEN
          END.ITEM = NUM.ITEMS
       END
       FOR ITEM.NUM = START.ITEM TO END.ITEM
          CRT.LINE += 1
          CRT @(0,CRT.LINE):ITEM.LINE(ITEM.NUM):
       NEXT ITEM.NUM
       CRT @(PROMPT.COL,PROMPT.LINE-1):'Page ':CURRENT.PAGE:' of ':LAST
C.PAGE
       RETURN
 
 
 *
 *
 * DISPLAY MSG
 *
 DISPLAY.MSG: 
       IF MENU.DISPLAY THEN
          CALL LINE.22(MSG)
       END ELSE
          CRT MSG
       END
       RETURN
 
    END
 ======== END OF RECORD ===============================================
 ======== RECORD I_C26.STANDARD ===================    14 FIELDS ======
 *
 * I_C26.STANDARD
 *
 * Standard insert for any program
 *
 *     Last updated by LIVE (SJOQUIST) at 09:59:23 on 04/04/1990.
 *
       CLEAR.SCREEN = @(-1)
       CLEAR.EOS = @(-3)
       CLEAR.EOL = @(-4)
       START.REVERSE = @(-13)
       END.REVERSE = @(-14)
       BKSP = @(-9)
       PROMPT ''
 ======== END OF RECORD ===============================================
 ======== RECORD ATFUNCTIONS.INS.IBAS =============   157 FIELDS ======
 * ATFUNCTIONS.INS.IBAS, INFORMATION>SYSCOM, INFORMATION GROUP, 04/05/8
C9
 * Mnemonic symbols for negative arguments to @ function.
 * Copyright (c) 1985, Prime Computer, Inc., Natick, MA 01760
 *                     All Rights Reserved
 *
 *  TITLE:   ATFUNCTIONS.INS
 *
 *
 *  START-HISTORY:
 *
 *  05 APR 89  edit 4 - PITS 3432 (8.1.D21) PARRY (Int. INTEGRATOR)
 *  Move lock and unlock line atfunctions from 72 and 73 to 77 and 78 t
Co stop
 *  clash with Connections undocumented use.
 *  08 DEC 88  edit 3 - PITS 3182 (8.1.D3) INTEGRATOR (Int. INTEGRATOR)
 *  Added new tokens for EDIT (72 - 76). Dave Brown, UKRD.
 *  04 NOV 88  edit 2 - PITS 3097 (8.0.D386) DBROWN (Int. PMILLER)
 *                  [Spar none, PITS3097]
 *                  Added missing equate tokens IT$SLT and IT$RLT.
 *                  These were documented in INFO/BASIC guide.
 *  31 Dec 87  edit 1 - NO PITS, creation of SC database (8.0.Dnn)
 *  -------------------------------------------------------------------
C---
 *  *****       CREATION OF SC DATABASE FOR INFORMATION SOURCE       **
C***
 *  -------------------------------------------------------------------
C---
 *  28 Oct 87 - 003 [Spar none, PITS1759] 1686 Mark Worrall
 *                  Extended @-functions from 16 up to 128.
 *                  Added video attributes.
 *                  Added Colours.
 *  05 Aug 87 - 002 *** Release 7.0 signed off ***
 *  22 Aug 86 - 001 *** Release 6.1 signed off ***
 *  11 Jul 85 - 000 Stephen Edwards
 *                  Initial code
 *
 *  END-HISTORY
 *
 *  START-DESCRIPTION:
 *
 *  Insert file containing symbols equated to negative numbers for use 
Cwith
 *  the single argument @ function.
 *
 *  END-DESCRIPTION
 *
 *  START-CODE:
 *
       EQU   IT$CS        TO    -1    ;* Clear screen
       EQU   IT$CAH       TO    -2    ;* Cursor absolute home
       EQU   IT$CLEOS     TO    -3    ;* Clear to end of screen
       EQU   IT$CLEOL     TO    -4    ;* Clear to end of line
       EQU   IT$SBLINK    TO    -5    ;* Start blinking field
       EQU   IT$EBLINK    TO    -6    ;* End blinking field
       EQU   IT$SPA       TO    -7    ;* Start protected area
       EQU   IT$EPA       TO    -8    ;* End protected area
       EQU   IT$CUB       TO    -9    ;* Cursor backward
       EQU   IT$CUU       TO   -10    ;* Cursor up
       EQU   IT$SHALF     TO   -11    ;* Start half-intensity field
       EQU   IT$EHALF     TO   -12    ;* End half-intensity field
       EQU   IT$SREV      TO   -13    ;* Start reverse video field
       EQU   IT$EREV      TO   -14    ;* End reverse video field
       EQU   IT$SUL       TO   -15    ;* Start underlined field
       EQU   IT$EUL       TO   -16    ;* End underlined field
       EQU   IT$IL        TO   -17    ;* insert line                   
C    *003*
       EQU   IT$DL        TO   -18    ;* delete line                   
C    *003*
       EQU   IT$ICH       TO   -19    ;* insert character              
C    *003*
       EQU   IT$SIRM      TO   -20    ;* set insertion/replacement mode
C    *003*
       EQU   IT$RIRM      TO   -21    ;* reset insertion/replacement mo
Cde  *003*
       EQU   IT$DCH       TO   -22    ;* delete character              
C    *003*
       EQU   IT$AUXON     TO   -23    ;* auxiliary port on             
C    *003*
       EQU   IT$AUXOFF    TO   -24    ;* auxiliary port off            
C    *003*
       EQU   IT$TRON      TO   -25    ;* transparent auxiliary port on 
C    *003*
       EQU   IT$TROFF     TO   -26    ;* transparent auxiliary port off
C    *003*
       EQU   IT$AUXDLY    TO   -27    ;* auxiliary delay time          
C    *003*
       EQU   IT$PRSCRN    TO   -28    ;* print screen                  
C    *003*
       EQU   IT$E80       TO   -29    ;* enter 80 column mode          
C    *003*
       EQU   IT$E132      TO   -30    ;* enter 132 column mode         
C    *003*
       EQU   IT$RIC       TO   -31    ;* reset inhibit cursor          
C    *003*
       EQU   IT$SIC       TO   -32    ;* set inhibit cursor            
C    *003*
       EQU   IT$CUD       TO   -33    ;* cursor down                   
C    *003*
       EQU   IT$CUF       TO   -34    ;* cursor forward                
C    *003*
       EQU   IT$VIDEO     TO   -35    ;* set video attributes          
C    *003*
 * RESERVED                    -36                                     
C    *003*
       EQU   IT$FCOLOR    TO   -37    ;* set foreground color          
C    *003*
       EQU   IT$BCOLOR    TO   -38    ;* set background color          
C    *003*
 * RESERVED                    -39                                     
C    *003*
 * RESERVED                    -40                                     
C    *003*
 * RESERVED                    -41                                     
C    *003*
       EQU   IT$DMI       TO   -42    ;* disable manual input          
C    *003*
       EQU   IT$EMI       TO   -43    ;* enable manual input           
C    *003*
       EQU   IT$BSCN      TO   -44    ;* blank screen                  
C    *003*
       EQU   IT$UBS       TO   -45    ;* unblank screen                
C    *003*
 * RESERVED                    -46                                     
C    *003*
 * RESERVED                    -47                                     
C    *003*
       EQU   IT$SU        TO   -48    ;* scroll up                     
C    *003*
       EQU   IT$SD        TO   -49    ;* scroll down                   
C    *003*
       EQU   IT$SR        TO   -50    ;* scroll right                  
C    *003*
       EQU   IT$SL        TO   -51    ;* scroll left                   
C    *003*
 * RESERVED                    -52                                     
C    *003*
 * RESERVED                    -53                                     
C    *003*
       EQU   IT$SLT       TO   -54    ;* set line truncate - PITS3097
       EQU   IT$RLT       TO   -55    ;* reset line truncate - PITS3097
       EQU   IT$SNK       TO   -56    ;* set numeric keypad            
C    *003*
       EQU   IT$RNK       TO   -57    ;* reset numeric keypad          
C    *003*
 * RESERVED                    -58                                     
C    *003*
 * RESERVED                    -59                                     
C    *003*
 * RESERVED                    -60                                     
C    *003*
 * RESERVED                    -61                                     
C    *003*
 * RESERVED                    -62                                     
C    *003*
 * RESERVED                    -63                                     
C    *003*
       EQU   IT$SLD       TO   -64    ;* system line display (display s
Cystem line)*003*
       EQU   IT$SLR       TO   -65    ;* system line reset (display sta
Ctus line)*003*
       EQU   IT$SLS       TO   -66    ;* system line set (define system
C line)*003*
 * RESERVED                    -67                                     
C    *003*
 * RESERVED                    -68                                     
C    *003*
 * RESERVED                    -69                                     
C    *003*
       EQU   IT$CHA       TO   -70    ;* cursor horizontal absolute    
C    *003*
       EQU   IT$ECH       TO   -71    ;* erase character               
C    *003*
 * RESERVED                    -72
 * RESERVED                    -73
       EQU   IT$NPC       TO   -74    ;* character to substitute for no
Cn-printing character
       EQU   IT$DISPLAY   TO   -75    ;* EDFS main display attributes
       EQU   IT$MINIBUF   TO   -76    ;* EDFS mini-buffer display attri
Cbutes
       EQU   IT$LOKL      TO   -77    ;* lock display line
       EQU   IT$UNLL      TO   -78    ;* unlock display line
 * RESERVED                    -79
       EQU   IT$PRIMELAST TO   -100   ;* last Prime-reserved @-function
C    *003*
       EQU   IT$USERFIRST TO   -101   ;* first user-allocated @-functio
Cn   *003*
       EQU   IT$USERLAST  TO   -128   ;* last user-allocated @-function
C    *003*
 *
 * Additive video attributes, for   IT$VIDEO argument 2: @(-35,n)
 *
       EQU   IT$NORMAL    TO    0    ;* normal                         
C    *003*
       EQU   IT$BOLD      TO    1    ;* bold                           
C    *003*
       EQU   IT$HALF      TO    2    ;* half intensity                 
C    *003*
       EQU   IT$ITALIC    TO    4    ;* italic                         
C    *003*
       EQU   IT$ULINE     TO    8    ;* underline                      
C    *003*
       EQU   IT$SLOWBLINK TO   16    ;* slow blink rate                
C    *003*
       EQU   IT$FASTBLINK TO   32    ;* fast blink rate                
C    *003*
       EQU   IT$REVERSE   TO   64    ;* reverse video                  
C    *003*
       EQU   IT$BLANK     TO  128    ;* concealed                      
C    *003*
 *
 * Colours, type of display
 *
      EQU    IT$COLOR     TO    1    ;* use colour                     
C    *003*
      EQU    IT$MONO      TO    2    ;* don't use colour               
C    *003*
      EQU    IT$GETCOLOR  TO    3    ;*                                
C    *003*
 *
 * Colours, for   IT$FCOLOR and   IT$BCOLOR argument 2: @(-37,n)/@(-38,
Cn)
 *
       EQU   IT$NOCOLOR   TO   -1    ;* nocolour                       
C    *003*
       EQU   IT$BLACK     TO    0    ;* black                          
C    *003*
       EQU   IT$RED       TO    1    ;* red                            
C    *003*
       EQU   IT$GREEN     TO    2    ;* green                          
C    *003*
       EQU   IT$YELLOW    TO    3    ;* yellow                         
C    *003*
       EQU   IT$BLUE      TO    4    ;* blue                           
C    *003*
       EQU   IT$MAGENTA   TO    5    ;* magenta                        
C    *003*
       EQU   IT$CYAN      TO    6    ;* cyan                           
C    *003*
       EQU   IT$WHITE     TO    7    ;* white                          
C    *003*
 *
 *  END-CODE
 ======== END OF RECORD ===============================================
 ### END OF FILE ######################################################
 ##### FILE CUSTOM.SUBROUTINES ####################    7 RECORDS ######
 ======== RECORD OPEN.FILE ========================    99 FIELDS ======
       SUBROUTINE OPEN.FILE(F.FILE, FILE.NAME, ON.ERROR.RETURN, ERROR.M
CSG)
 *
 * INFO/BASIC SUBROUTINE
 * 11/18/88
 * DWS
 * TITLE -----OPEN.FILE
 *
 *
 * PURPOSE: ONLY OPEN EACH FILE ONCE DURING A SESSION
 *          STORE OPEN FILE.VARS IN COMMON
 *
 *     Last updated by LIVE (ROTMAND) at 15:58:11 on 02/12/1993.
 * Call our own version of FATAL.ERROR so that we don't leave
 * the terminal in half duplex.
 *     Last updated by LIVE (SJOQUIST) at 08:43:02 on 11/18/1988.
 *
 **********************************************************************
C***
 *
 
       EQU MAX.FILES TO 200
       COMMON/OPENFIL/ OPENFIL.NUM.FILES,
       OPENFIL.FILE.NAME.LIST,
       OPENFIL.FILE.VARS(MAX.FILES)
 
 *
 *
 * ON.ERROR.RETURN USED TO DETERMINE WHAT HAPPENS IF THERE IS AN ERROR
 *   = 0, SET ERROR.MSG AND STOPS
 *   # 0, SET ERROR.MSG AND RETURN
 *
 *
 * STEPS TO CHECK:
 *  1. CHECK IF FILE.VAR PASSED IN ALREADY ASSIGNED TO OPEN FILE
 *  2. CHECK IF FILE.NAME IS IN LIST OF FILES OPENED BY THIS SUBR
 *  3. OPEN THE FILE & STORE IT IN THE LIST
 *
 
 
       ERROR.MSG = ''
       TEST.FILE.NAME = TRIM(FILE.NAME)
 
 *
 * STEP 1:
 *
 * IF @LOGNAME = 'rotmand' THEN CRT 'FILE ':FILE.NAME
       IF FILEINFO(F.FILE,0) = 1 THEN
 * IF @LOGNAME = 'rotmand' THEN CRT '   ALREADY OPEN'
          RETURN
       END
 
 
 *
 * STEP 2:
 *
       LOCATE TEST.FILE.NAME IN OPENFIL.FILE.NAME.LIST<1> SETTING POS T
CHEN
          F.FILE = OPENFIL.FILE.VARS(POS)
          RETURN
       END
 
 
 *
 * STEP 3:
 *
       IF OPENFIL.NUM.FILES >= MAX.FILES THEN
          ERROR.MSG = '** TOO MANY FILES OPEN IN "OPEN.FILES" **'
          IF NOT(ON.ERROR.RETURN) THEN
 *DWS            CALL FATAL.ERROR('MISC.ERROR',ERROR.MSG)
             STOP ERROR.MSG
             STOP
          END ELSE
             RETURN
          END
       END
 *
       FILE.OPEN.OKAY = 0
       IF TEST.FILE.NAME[1,5] = 'DICT ' THEN
          DATA.FILE.NAME = TEST.FILE.NAME[6,80]
          OPEN 'DICT', DATA.FILE.NAME TO F.FILE THEN
             FILE.OPEN.OKAY = 1
          END
       END ELSE
          OPEN '', TEST.FILE.NAME TO F.FILE THEN
             FILE.OPEN.OKAY = 1
          END
       END
       IF FILE.OPEN.OKAY THEN
          OPENFIL.NUM.FILES += 1
          OPENFIL.FILE.NAME.LIST<OPENFIL.NUM.FILES> = TEST.FILE.NAME
          OPENFIL.FILE.VARS(OPENFIL.NUM.FILES) = F.FILE
       END ELSE
          ERROR.MSG = '** CAN NOT OPEN "':FILE.NAME:'" IN "OPEN.FILES"'
          IF NOT(ON.ERROR.RETURN) THEN
             STOP '"':FILE.NAME:'" NOT FOUND'
          END ELSE
             RETURN
          END
       END
       RETURN
    END
 ======== END OF RECORD ===============================================
 ======== RECORD PARSE.LINE =======================    30 FIELDS ======
       SUBROUTINE PARSE.LINE(COMMAND.LINE, ITEM.LIST, ITEM.QUOTED.LIST,
C NUM.ITEMS)
 *
 * INFO/BASIC SUBROUTINE
 * 4/16/91
 * DWS
 * TITLE ----- PARSE.LINE
 *
 *
 * PURPOSE: PARSE A STRING INTO SEPARATE ITEMS
 *              (OFTEN USED FOR COMMAND LINES)
 *
 *     Last updated by LIVE (SJOQUIST) at 10:56:12 on 04/16/1991.
 * Split into 2 subroutines PARSE.COMMAND.LINE & EXPAND.ITEMS, so have
 * this shell simply call those two routines.  It was split so that
 * the calling program could have more control over expanding VOC
 * phrases, marking items as used, expanding dictionary phrases, etc.,
 * to mimic INFORM's style
 *
 **********************************************************************
C***
 *
 
       OTHER.SEPARATORS = ''
       CALL PARSE.COMMAND.LINE(COMMAND.LINE, ITEM.LIST, ITEM.QUOTED.LIS
CT, NUM.ITEMS, OTHER.SEPARATORS)
       ITEM.USED.LIST = ''
       DICT.FILE.NAME = ''
       EXPAND.VOC.PHRASES = 1
       CALL EXPAND.ITEMS(ITEM.LIST, ITEM.QUOTED.LIST, ITEM.USED.LIST, N
CUM.ITEMS, DICT.FILE.NAME, EXPAND.VOC.PHRASES, OTHER.SEPARATORS)
       RETURN
 
    END
 ======== END OF RECORD ===============================================
 ======== RECORD LOAD.SPOOL.QUEUE =================   191 FIELDS ======
       SUBROUTINE LOAD.SPOOL.QUEUE(RETURN.STATUS)
 *
 * INFO/BASIC SUBROUTINE
 * 4/27/90
 * DWS
 * TITLE ----- LOAD.SPOOL.QUEUE
 *
 *
 * PURPOSE: LOAD CURRENT SPOOL QUEUE ENTRIES INTO LABELLED COMMON
 *
 * Stamped: pty/ttyp6 testuser, /disk1/coltest, user #3736, 14 Jun 94, 
C04:44PM.
 * rewritten for HP-UX
 *     Last updated by LIVE (SJOQUIST) at 11:27:46 on 04/27/1990.
 *
 **********************************************************************
C***
 *
 
       $INCLUDE LOCAL.SOURCE I_SPQUEUE.COMMON
 
 *
 *
 * MAIN CONTROL
 *
 
       RETURN.STATUS = ''
       GOSUB SET.UP
       IF RETURN.STATUS THEN
          RETURN
       END
       LOOP
          NEXT.QCTR = CALLC c_qnext(CUR.QCTR, F.QUEUE, Q.NODE, Q.USER, 
CQ.NAME, Q.JOB.NUMBER, Q.JOB.STATUS)
       UNTIL NEXT.QCTR = -1
 * CHECK TO SEE IF THE JOB HAS ALREADY BEEN PRINTED OR CANCELLED
          IF BITAND(Q.JOB.STATUS,1) = 0 THEN
 *CRT Q.NODE:' ':Q.USER:' ':Q.NAME:' ':Q.JOB.NUMBER:' ':Q.JOB.STATUS
             GOSUB INITIALIZE.ENTRY
             GOSUB READ.ENTRY
             GOSUB SPLIT.ENTRY
             GOSUB BUILD.ENTRY
          END
          CUR.QCTR = NEXT.QCTR
       REPEAT
       CALLC c_qclose(F.QUEUE)
 *INPUT JUNK
       RETURN
 
 
 
 *
 *
 * SET UP
 *
 SET.UP: 
       ROOT.PATH = '/usr/spool/lp/'
       REQUEST.PATH = ROOT.PATH:'request/'
       QUEUE.FILE.NAME = ROOT.PATH:'outputq'
 * fix rights on outputq
 PCPERFORM '/disk1/locsrc/cprogs/fixoutputq' CAPTURING TEMP.OUTPUT
       F.QUEUE = CALLC c_qopen(QUEUE.FILE.NAME)
       IF F.QUEUE = 0 THEN
          RETURN.STATUS = 'Can not open spool queue: ':QUEUE.FILE.NAME
          RETURN
       END
 *
       CUR.QCTR = 0
       Q.NODE = ''
       Q.USER = ''
       Q.NAME = ''
       Q.JOB.NUMBER = ''
       Q.JOB.STATUS = ''
 *
       SPQUEUE.NUM.ENTRIES = 0
       SPQUEUE.ENTRY.NUMBER.LIST = ''
       MAT SPQUEUE.USER.NAME = ''
       MAT SPQUEUE.DATE = ''
       MAT SPQUEUE.TIME = ''
       MAT SPQUEUE.SPOOL.NAME = ''
       MAT SPQUEUE.FILE.NAME = ''
       MAT SPQUEUE.FORM.NAME = ''
       MAT SPQUEUE.SIZE = ''
       MAT SPQUEUE.COPIES = ''
       RETURN
 
 
 
 *
 *
 * INITIALIZE ENTRY FIELDS
 *
 INITIALIZE.ENTRY: 
       ENTRY.USER.NAME = ''
       ENTRY.SPOOL.NAME = ''
       ENTRY.FILE.NAME = ''
       ENTRY.TITLE = ''
       ENTRY.DATE = ''
       ENTRY.TIME = ''
       ENTRY.SIZE = ''
       ENTRY.COPIES = ''
       RETURN
 
 
 *
 *
 * READ ENTRY FROM FILE
 *
 READ.ENTRY: 
       REQUEST.FILE.NAME = REQUEST.PATH:Q.NAME:'/':'cA':FMT(Q.JOB.NUMBE
CR,'4"0"R'):Q.NODE
       OSREAD ENTRY FROM REQUEST.FILE.NAME ELSE
          REQUEST.FILE.NAME = REQUEST.PATH:Q.NAME:'/':'cfA':FMT(Q.JOB.N
CUMBER,'3"0"R'):Q.NODE
          OSREAD ENTRY FROM REQUEST.FILE.NAME ELSE
             REQUEST.FILE.NAME = ''
             ENTRY = 'Jinaccessible':CHAR(10)
          END
       END
       CONVERT CHAR(10) TO @FM IN ENTRY
       RETURN
 
 
 
 *
 *
 * SPLIT ENTRY
 *
 SPLIT.ENTRY: 
       NUM.LINES = COUNT(ENTRY,@FM)
       FOR LINE.CTR=1 TO NUM.LINES
          LINE.TYPE = ENTRY<LINE.CTR>[1,1]
          LINE.DATA = ENTRY<LINE.CTR>[2,32000]
          BEGIN CASE
             CASE LINE.TYPE = 'P'
                ENTRY.USER.NAME = LINE.DATA
             CASE LINE.TYPE = 'B'
                ENTRY.TITLE = LINE.DATA
             CASE LINE.TYPE = 'K'
                ENTRY.COPIES = LINE.DATA
             CASE LINE.TYPE = 'T'
                ENTRY.FILE.NAME = LINE.DATA
             CASE LINE.TYPE = 'F'
                ENTRY.SPOOL.NAME = REQUEST.PATH:Q.NAME:'/':LINE.DATA
 GOSUB GET.FILE.INFO
          END CASE
       NEXT LINE.CTR
       RETURN
 
 
 *
 *
 * GET FILE INFO
 *
 GET.FILE.INFO: 
       IF ENTRY.SPOOL.NAME = '' THEN
          RETURN
       END
       BUFFER = ''
       RESULT = CALLC c_finfo(ENTRY.SPOOL.NAME, BUFFER)
       IF RESULT THEN
          RETURN
       END
       ENTRY.SIZE = BUFFER<2>
       ENTRY.DATE = ICONV(BUFFER<5>,'D2')
       ENTRY.TIME = ICONV(BUFFER<8>,'MT')
 *IF @LOGNAME = 'sjoquist' THEN
 *   CRT ENTRY.SPOOL.NAME
 *CRT BUFFER
 *INPUT JUNK
 *END
       RETURN
 
 
 *
 *
 * BUILD ENTRY
 *
 BUILD.ENTRY: 
       SPQUEUE.NUM.ENTRIES += 1
       SPQUEUE.ENTRY.NUMBER.LIST<SPQUEUE.NUM.ENTRIES> = Q.JOB.NUMBER
       SPQUEUE.USER.NAME(SPQUEUE.NUM.ENTRIES) = Q.USER
       SPQUEUE.TITLE(SPQUEUE.NUM.ENTRIES) = ENTRY.TITLE
       SPQUEUE.SPOOL.NAME(SPQUEUE.NUM.ENTRIES) = ENTRY.SPOOL.NAME
       SPQUEUE.FILE.NAME(SPQUEUE.NUM.ENTRIES) = ENTRY.FILE.NAME
       SPQUEUE.DATE(SPQUEUE.NUM.ENTRIES) = ENTRY.DATE
       SPQUEUE.TIME(SPQUEUE.NUM.ENTRIES) = ENTRY.TIME
       SPQUEUE.FORM.NAME(SPQUEUE.NUM.ENTRIES) = Q.NAME
       SPQUEUE.SIZE(SPQUEUE.NUM.ENTRIES) = ENTRY.SIZE
       SPQUEUE.COPIES(SPQUEUE.NUM.ENTRIES) = ENTRY.COPIES
       RETURN
 
 
 
 
    END
 ======== END OF RECORD ===============================================
 ======== RECORD PARSE.COMMAND.LINE ===============   113 FIELDS ======
       SUBROUTINE PARSE.COMMAND.LINE(LINE,PARAMS,PARAM.QUOTED,NUM.PARAM
CS,OTHER.SEPARATORS)
 *
 * INFO/BASIC SUBROUTINE
 * 4/11/91
 * DWS
 * TITLE ----- PARSE.COMMAND.LINE
 *
 *
 * PURPOSE: PARSE COMMAND LINE, NO EXPANSION OF ITEMS IS DONE
 *
 * Version 2.1, miscellaneous changes
 *     Last updated by LIVE (SJOQUISTD) at 13:42:17 on 10/27/1993.
 * Set up new distributable copy (version 2.1)
 *     Last updated by LIVE (SJOQUIST) at 12:23:06 on 04/11/1991.
 * Adapted from PARSE.LINE
 *
 **********************************************************************
C***
 *
 
 *
 *
 * MAIN
 *
 
       GOSUB SET.UP
       GOSUB PROCESS.LINE
       RETURN
 
 
 *
 *
 * SET UP
 *
 SET.UP:
       SGL.SPACE = ' '
       TRUE = 1
       FALSE = 0
 *
 *  PARSE LINE INTO LIST OF SEPARATE ITEMS & FLAG THEM AS QUOTED OR NOT
 *
       NUM.PARAMS = 0
       PARAMS = ''
       PARAM.QUOTED = ''
 *
       PREV.CHAR = SGL.SPACE
       QUOTE = ''
       NEXT.ITEM.IS.NEW = FALSE
       RETURN
 
 
 
 
 *
 *   READ THROUGH COMMAND LINE AND PARSE IT
 *
 PROCESS.LINE:
       LEN.LINE = LEN(LINE)
       FOR ITEM.CTR=1 TO LEN.LINE
          CUR.CHAR = LINE[ITEM.CTR,1]
 *
 *     IF THE QUOTE FLAG IS ON, THEN TAKE EVERYTHING UP TO THE
 *       MATCHING END QUOTE AS PART OF THE ITEM
 *       THE MATCHING END QUOTE ENDS THIS ITEM, IF THERE IS ANY OTHER I
CTEM,
 *          THEN IT IS A NEW ITEM (THE FLAG NEXT.ITEM.IS.NEW IS SET TO 
CTRUE)
 *
          IF QUOTE THEN
             BEGIN CASE
                CASE CUR.CHAR = QUOTE
                   QUOTE = ''
                   NEXT.ITEM.IS.NEW = TRUE
                CASE 1
                   PARAMS<NUM.PARAMS> = PARAMS<NUM.PARAMS>:CUR.CHAR
             END CASE
 *
 *    IF THE CUR.CHARACTER IS A QUOTE, TURN ON QUOTE MODE
 *      OTHERWISE ADD IT THE CURRENT ITEM
 *
          END ELSE
             BEGIN CASE
                CASE CUR.CHAR = SGL.SPACE
                   NULL
                CASE CUR.CHAR = '"' OR CUR.CHAR = "'" OR CUR.CHAR = '~'
                   QUOTE = CUR.CHAR
                   NUM.PARAMS += 1
                   PARAM.QUOTED<NUM.PARAMS> = QUOTE
                   NEXT.ITEM.IS.NEW = FALSE
 *
 * IF THE CHARACTER IS IN THE LIST "OTHER.SEPARATORS", THEN
 *   FINISH THE OLD ITEM, MAKE A NEW ITEM JUST FOR THE CHARACTER,
 *   AND FORCE THE NEXT CHARACTER TO START A NEW ITEM
 * OTHERWISE, CHECK IF THERE IS A NEW ITEM, OTHERWISE JUST ADD THE
 *   CHARACTER TO THE CURRENT ITEM
 *
                CASE 1
                   LOCATE CUR.CHAR IN OTHER.SEPARATORS<1> SETTING OTHER
C.POS THEN
                      NUM.PARAMS += 1
                      PARAMS<NUM.PARAMS> = CUR.CHAR
                      NEXT.ITEM.IS.NEW = TRUE
                   END ELSE
                      IF PREV.CHAR = SGL.SPACE OR NEXT.ITEM.IS.NEW THEN
                         NUM.PARAMS += 1
                         PARAM.QUOTED<NUM.PARAMS> = ''
                         NEXT.ITEM.IS.NEW = FALSE
                      END
                      PARAMS<NUM.PARAMS> = PARAMS<NUM.PARAMS>:CUR.CHAR
                   END
             END CASE
          END
          PREV.CHAR = CUR.CHAR
       NEXT ITEM.CTR
       RETURN
 
    END
 ======== END OF RECORD ===============================================
 ======== RECORD EXPAND.ITEMS =====================   204 FIELDS ======
       SUBROUTINE EXPAND.ITEMS(ITEM.LIST,ITEM.QUOTED.LIST,ITEM.USED.LIS
CT,NUM.ITEMS,DICT.FILE.NAME,EXPAND.PHRASES,OTHER.SEPARATORS)
 *
 * INFO/BASIC SUBROUTINE
 * 4/11/91
 * DWS
 * TITLE ----- EXPAND.ITEMS
 *
 *
 * PURPOSE: EXPAND STRING OF ITEMS, CHECKING DICTIONARY & VOC FOR PHRAS
CES
 *
 *     Last updated by LIVE (SJOQUIST) at 12:23:06 on 04/11/1991.
 * Adapted from PARSE.LINE
 *
 **********************************************************************
C***
 *
 
       COMMON/EXPITEM/ EXPITEM.F.VOC,
          EXPITEM.VOC.OPENED,
          EXPITEM.F.DICT,
          EXPITEM.DICT.FILE.NAME
 
 *
 *
 * MAIN
 *
 
       IF NOT(EXPITEM.VOC.OPENED) THEN
          GOSUB OPEN.VOC
       END
       IF DICT.FILE.NAME AND EXPITEM.DICT.FILE.NAME # DICT.FILE.NAME TH
CEN
          GOSUB OPEN.DICT
       END
       GOSUB SET.UP
       GOSUB MAKE.PARAM
       ITEM.LIST = PARAM.LIST
       ITEM.QUOTED.LIST = PARAM.QUOTED.LIST
       ITEM.USED.LIST = PARAM.USED.LIST
       NUM.ITEMS = NUM.PARAMS
       RETURN
 
 
 *
 *
 * OPEN VOC FILE
 *
 OPEN.VOC:
       ON.ERROR.RETURN = 0
       ERRMSG = ''
       EXPITEM.F.VOC = ''
       CALL OPEN.FILE(EXPITEM.F.VOC,'VOC',ON.ERROR.RETURN,ERRMSG)
       EXPITEM.VOC.OPENED = 1
       RETURN
 
 
 *
 *
 * OPEN DICT FILE
 *
 OPEN.DICT:
       ON.ERROR.RETURN = 0
       ERRMSG = ''
       EXPITEM.F.DICT = ''
       EXPITEM.DICT.FILE.NAME = ''
       CALL OPEN.FILE(EXPITEM.F.DICT,DICT.FILE.NAME,ON.ERROR.RETURN,ERR
CMSG)
       EXPITEM.DICT.FILE.NAME = DICT.FILE.NAME
       RETURN
 
 
 *
 *
 * SET UP
 *
 SET.UP:
       TRUE = 1
       FALSE = 0
       PARAM.LIST = ''
       PARAM.QUOTED.LIST = ''
       PARAM.USED.LIST = ''
       NUM.PARAMS = 0
       DICT.REC.TYPES.NOT.TO.EXPAND.IN.VOC = 'D':@FM:'I':@FM:'PH'
       RETURN
 
 
 *
 *
 * COPY ITEMS LIST TO PARAMS LIST, EXPANDING ANY PHRASES IN THE
 *  VOC FILE TO ALL THE ITEMS
 *
 MAKE.PARAM:
       FOR ITEM.CTR=1 TO NUM.ITEMS
          ITEM.USED = ITEM.USED.LIST<ITEM.CTR>
          ITEM = ITEM.LIST<ITEM.CTR>
          ITEM.QUOTED = ITEM.QUOTED.LIST<ITEM.CTR>
          PHRASE.FOUND = FALSE
          IF NOT(ITEM.QUOTED) AND NOT(ITEM.USED) THEN
             OKAY.TO.CHECK.VOC = TRUE
             IF DICT.FILE.NAME THEN
                GOSUB CHECK.DICT.FOR.PHRASE
             END
             IF EXPAND.PHRASES AND OKAY.TO.CHECK.VOC THEN
                GOSUB CHECK.VOC.FOR.PHRASE
             END
          END
          IF NOT(PHRASE.FOUND) THEN
             NUM.PARAMS += 1
             PARAM.LIST<NUM.PARAMS> = ITEM
             PARAM.QUOTED.LIST<NUM.PARAMS> = ITEM.QUOTED
             PARAM.USED.LIST<NUM.PARAMS> = ITEM.USED
          END
       NEXT ITEM.CTR
       RETURN
 
 
 *
 *
 * CHECK DICT FILE FOR A PHRASE TO BE EXPANDED
 *
 CHECK.DICT.FOR.PHRASE:
       READ DICT.REC FROM EXPITEM.F.DICT, ITEM ELSE
          RETURN
       END
       IF DICT.REC<1>[1,1] = 'P' THEN
          DICT.REC.TYPE = DICT.REC<1>[1,2]
       END ELSE
          DICT.REC.TYPE = DICT.REC<1>[1,1]
       END
 *
 * IF THIS ITEM IS A PHRASE, THEN EXPAND THE DICTIONARY PHRASE.
 * IF IT IS NOT A PHRASE, THEN CHECK IF IT IS OKAY TO CHECK THE VOC
 *   FOR A PHRASE NAME TO EXPAND
 * SINCE WE ARE CHECKING THE DICTIONARY FOR PHRASES, IT IS REASONABLE T
CO ASSUME
 *   THAT WE DO NOT WANT TO CHECK THE VOC FOR A PHRASE IF THE ITEM IN
 *   QUESTION IS A DATA FIELD OR I-DESC FIELD IN THE DICTIONARY
 *
       IF DICT.REC.TYPE = 'PH' THEN
          OKAY.TO.CHECK.VOC = FALSE
          PHRASE.FOUND = TRUE
       END ELSE
          LOCATE DICT.REC.TYPE IN DICT.REC.TYPES.NOT.TO.EXPAND.IN.VOC<1
C> SETTING POS THEN
             OKAY.TO.CHECK.VOC = FALSE
          END
          RETURN
       END
 *
       PHRASE.TO.CHECK = DICT.REC<2>
       PHRASE.ITEM.LIST = ''
       PHRASE.QUOTED.LIST = ''
       NUM.PHRASE.ITEMS = 0
       CALL PARSE.COMMAND.LINE(PHRASE.TO.CHECK,PHRASE.ITEM.LIST,PHRASE.
CQUOTED.LIST,NUM.PHRASE.ITEMS,OTHER.SEPARATORS)
 *
       PHRASE.USED.LIST = ''
       CALL EXPAND.ITEMS(PHRASE.ITEM.LIST,PHRASE.QUOTED.LIST,PHRASE.USE
CD.LIST,NUM.PHRASE.ITEMS,DICT.FILE.NAME,EXPAND.PHRASES,OTHER.SEPARATORS
C)
       GOSUB CHECK.CIRCULAR
       PARAM.LIST<NUM.PARAMS+1> = PHRASE.ITEM.LIST
       PARAM.QUOTED.LIST<NUM.PARAMS+1> = PHRASE.QUOTED.LIST
       PARAM.USED.LIST<NUM.PARAMS+1> = PHRASE.USED.LIST
       NUM.PARAMS += NUM.PHRASE.ITEMS
       RETURN
 
 
 *
 *
 * CHECK VOC FILE FOR A PHRASE TO BE EXPANDED
 *
 CHECK.VOC.FOR.PHRASE:
       READ VOC.REC FROM EXPITEM.F.VOC, ITEM ELSE
          RETURN
       END
       IF VOC.REC<1>[1,2] # 'PH' THEN
          RETURN
       END
       PHRASE.FOUND = TRUE
       PHRASE.TO.CHECK = VOC.REC<2>
       PHRASE.ITEM.LIST = ''
       PHRASE.QUOTED.LIST = ''
       NUM.PHRASE.ITEMS = 0
       CALL PARSE.COMMAND.LINE(PHRASE.TO.CHECK,PHRASE.ITEM.LIST,PHRASE.
CQUOTED.LIST,NUM.PHRASE.ITEMS,OTHER.SEPARATORS)
 *
       PHRASE.USED.LIST = ''
       CALL EXPAND.ITEMS(PHRASE.ITEM.LIST,PHRASE.QUOTED.LIST,PHRASE.USE
CD.LIST,NUM.PHRASE.ITEMS,DICT.FILE.NAME,EXPAND.PHRASES,OTHER.SEPARATORS
C)
       GOSUB CHECK.CIRCULAR
       PARAM.LIST<NUM.PARAMS+1> = PHRASE.ITEM.LIST
       PARAM.QUOTED.LIST<NUM.PARAMS+1> = PHRASE.QUOTED.LIST
       PARAM.USED.LIST<NUM.PARAMS+1> = PHRASE.USED.LIST
       NUM.PARAMS += NUM.PHRASE.ITEMS
       RETURN
 
 *
 *
 * DO A SIMPLE CHECK FOR A CIRCULAR REFERENCE IN A VOC PHRASE
 *
 CHECK.CIRCULAR:
       FOR PHRASE.ITEM.CTR=1 TO NUM.PHRASE.ITEMS
          PHRASE.QUOTED = PHRASE.QUOTED.LIST<PHRASE.ITEM.CTR>
          IF NOT(PHRASE.QUOTED) THEN
             PHRASE.ITEM = PHRASE.ITEM.LIST<PHRASE.ITEM.CTR>
             IF PHRASE.ITEM = ITEM THEN
                STOP 'Circular Reference: Phrase "':ITEM:'" references 
Citself'
             END
          END
       NEXT PHRASE.ITEM.CTR
       RETURN
 
    END
 ======== END OF RECORD ===============================================
 ======== RECORD PROMPT.ANS =======================   114 FIELDS ======
       SUBROUTINE PROMPT.ANS(RETURN.ANSWER,PROMPT.STRINGS,COL.NO,LINE.N
CO,ANSWER.LIST,DEFAULT.ANSWER,END.PARAM)
 *
 * INFO/BASIC SUBROUTINE
 * 4/13/88
 * DWS
 * TITLE ----- PROMPT.ANS
 *
 *
 * PURPOSE: ASK A QUESTION
 *
 *     Last updated by LIVE (ROTMAN) at 09:22:39 on 07/22/1988.
 * REARRANGE PARAMETERS AND ADD 'END.PARAM' TO HANDLE ENTRY
 * OF 'END' AT PROMPT
 *     Last updated by LIVE (ROTMAN) at 11:52:13 on 07/20/1988.
 * ALLOW MULTI-LINE PROMPTING (USED FOR MENUS)
 *     Last updated by LIVE (SJOQUIST) at 12:56:47 on 04/13/1988.
 *
 **********************************************************************
C***
 *
 *
 
       IF COL.NO = '' OR LINE.NO = '' THEN
          SCREEN.POS = @FALSE
          CLEAR.EOL = ''
       END ELSE
          SCREEN.POS = @TRUE
          CLEAR.EOL = @(-4)
       END
 
 
 
 *
 * SET UP
 *
       MV.ANSWER.LIST = ANSWER.LIST
       CONVERT '}' TO @VM IN MV.ANSWER.LIST
       CONVERT '~' TO @VM IN MV.ANSWER.LIST
       CONVERT @FM TO @VM IN MV.ANSWER.LIST
       CONVERT ',' TO @VM IN MV.ANSWER.LIST
 
       COUNT.STRINGS = COUNT(PROMPT.STRINGS,@VM) + (PROMPT.STRINGS#'')
       MENU.STRINGS = FIELD(PROMPT.STRINGS,@VM,1,COUNT.STRINGS-1)
 
       DISPLAY.PROMPT = PROMPT.STRINGS<1,COUNT.STRINGS>
       DISPLAY.PROMPT := ': '
       LEN.PROMPT = LEN(DISPLAY.PROMPT)
 
 
 *
 * DISPLAY MENU (PROMPT STRINGS 1 THROUGH N-1)
 *
       FOR WHICH.MENU = 1 TO COUNT.STRINGS - 1
          CRT @(COL.NO,LINE.NO+WHICH.MENU-1):CLEAR.EOL:MENU.STRINGS<1,W
CHICH.MENU>:
       NEXT WHICH.MENU
 
 
 *
 * GET ANSWER
 *
       IF SCREEN.POS THEN
          CRT @(COL.NO,LINE.NO+COUNT.STRINGS-1):CLEAR.EOL:
       END
       CRT DISPLAY.PROMPT:
       IF DEFAULT.ANSWER # '' THEN
          MASK = DEFAULT.ANSWER
       END ELSE
          MASK = "#"
       END
       LOOP
          IF SCREEN.POS THEN
             CRT @(COL.NO+LEN.PROMPT,LINE.NO+COUNT.STRINGS-1):MASK:CLEA
CR.EOL:@(COL.NO+LEN.PROMPT):
          END
          INPUT ANS
          IF DEFAULT.ANSWER # '' AND ANS = '' THEN
             ANS = DEFAULT.ANSWER
          END
          GOSUB VALIDATE.ANS
       UNTIL VALID.ANSWER
       REPEAT
       RETURN.ANSWER = ANS
       IF SCREEN.POS THEN
          CRT @(COL.NO+LEN.PROMPT,LINE.NO+COUNT.STRINGS-1):CLEAR.EOL:
       END
       CRT RETURN.ANSWER
       RETURN
 
 
 
 *
 * VALIDATION ROUTINE
 *
 VALIDATE.ANS: 
       VALID.ANSWER = 1
       IF MV.ANSWER.LIST THEN
          LOCATE ANS IN MV.ANSWER.LIST<1,1> SETTING VALID.ANSWER ELSE
             VALID.ANSWER = 0
          END
       END
       IF OCONV(ANS,'MCU') = 'END' THEN
          BEGIN CASE
             CASE END.PARAM = 0 OR END.PARAM = ''
                NULL
             CASE END.PARAM = 1
                VALID.ANSWER = 1
             CASE END.PARAM = 2
                STOP
             CASE 1
                NULL
          END CASE
       END
 
 
       RETURN
    END
 ======== END OF RECORD ===============================================
 ======== RECORD VIEW.OS.FILE =====================   615 FIELDS ======
       SUBROUTINE VIEW.OS.FILE(F.OS.FILE, OS.POS, HEADING.MSG)
 *
 * INFO/BASIC PROGRAM
 * 6/27/90
 * DWS
 * TITLE ----- VIEW.OS.FILE
 *
 *
 * PURPOSE: VIEW A TEXT FILE ON THE SCREEN
 *
 *     Last updated by LIVE (SJOQUIST) at 14:49:25 on 06/27/1990.
 *
 **********************************************************************
C***
 *
 
       $INCLUDE LOCAL.SOURCE I_C26.STANDARD
       $INCLUDE LOCAL.SOURCE ATFUNCTIONS.INS.IBAS
 
       GOSUB SET.UP
       GOSUB DISPLAY.PAGE
       GOSUB PROCESS.COMMANDS
       RETURN
 
 
 *
 *
 * SET.UP
 *
 SET.UP: 
       CRT @(IT$CS):
       TEMP = @(0,0)
       PROMPT ''
       LINES = ''
       PAGE.SIZE = 21
       TOP.LINE.CTR = 0
       PREV.TOP.LINE.CTR = 0
       NUM.LINES = 0
       LINE.CTR = 0
       MAX.LEN = 0
       END.OF.FILE = @FALSE
       EOF.LINE = '*** END OF FILE ***'
       LOCATE.DIRECTION = ''
       LOCATE.TEXT = ''
       OS.BUFFER = ''
       OS.BUFFER.SIZE = 1024
 *
       PROMPT.TEXT = ''
       PROMPT.TEXT<-1> = '(T)op, (B)ottom, (Q)uit, (O)ther'
       PROMPT.TEXT<-1> = '(U)p #, (D)own #, (L)eft #, (R)ight #, (RE)di
Csplay, (O)ther'
       PROMPT.TEXT<-1> = '(G)oto line# col#, (GC) Goto col#, (GL) Goto 
Cline#, (O)ther'
       PROMPT.TEXT<-1> = '(FL) Forward locate, (BL) Backward locate, (L
CA) Locate again, (O)ther'
       NUM.PROMPT.TEXTS = COUNT(PROMPT.TEXT,@FM) + 1
       CUR.PROMPT.TEXT = 1
       VALID.ANS.LIST = ''
       DEFAULT.ANS = ''
       END.PARAM = 2
       DEFAULT.COMMAND = 'O'
       DISPLAY.WIDTH = 79
       BEG.COL = 1
       PREV.BEG.COL = BEG.COL
       COL.SHIFT = 20
       PROMPT.COL = 0
       PROMPT.LINE = 22
       RETURN
 
 
 *
 *
 * PROCESS COMMANDS
 *
 PROCESS.COMMANDS: 
       COMMAND = ''
       LOOP
          CALL PROMPT.ANS(COMMAND,PROMPT.TEXT<CUR.PROMPT.TEXT>,PROMPT.C
COL,PROMPT.LINE,VALID.ANS.LIST,DEFAULT.COMMAND,END.PARAM)
          UC.COMMAND = OCONV(COMMAND,'MCU')
       UNTIL UC.COMMAND = 'Q'
          CMD1 = UC.COMMAND[1,1]
          CMD2 = UC.COMMAND[1,2]
          BEGIN CASE
             CASE COMMAND = 'T'
                GOSUB PROCESS.TOP
             CASE COMMAND = 'RE'
                GOSUB PROCESS.REDISPLAY
             CASE COMMAND = 'B'
                GOSUB PROCESS.BOTTOM
             CASE CMD1 = 'U'
                REST.OF.LINE = COMMAND[2,99]
                GOSUB PROCESS.PAGE.UP
                DEFAULT.COMMAND = COMMAND
             CASE CMD1 = 'D'
                REST.OF.LINE = COMMAND[2,99]
                GOSUB PROCESS.PAGE.DOWN
                DEFAULT.COMMAND = COMMAND
             CASE CMD1 = 'L' AND CMD2 # 'LA'
                REST.OF.LINE = COMMAND[2,99]
                GOSUB PROCESS.LEFT
                DEFAULT.COMMAND = COMMAND
             CASE CMD1 = 'R' AND COMMAND # 'RE'
                REST.OF.LINE = COMMAND[2,99]
                GOSUB PROCESS.RIGHT
                DEFAULT.COMMAND = COMMAND
             CASE COMMAND = 'O'
                CUR.PROMPT.TEXT += 1
                IF CUR.PROMPT.TEXT > NUM.PROMPT.TEXTS THEN
                   CUR.PROMPT.TEXT = 1
                END
                DEFAULT.COMMAND = COMMAND
             CASE CMD1 = 'G' AND CMD2 # 'GC' AND CMD2 # 'GL'
                REST.OF.LINE = COMMAND[2,99]
                GOSUB PROCESS.GOTO
             CASE CMD2 = 'GC'
                REST.OF.LINE = COMMAND[3,99]
                GOSUB PROCESS.GOTO.COL
             CASE CMD2 = 'GL'
                REST.OF.LINE = COMMAND[3,99]
                GOSUB PROCESS.GOTO.LINE
             CASE CMD2 = 'FL'
                REST.OF.LINE = COMMAND[3,99]
                GOSUB PROCESS.LOCATE.FORWARD
                DEFAULT.COMMAND = 'LA'
             CASE CMD2 = 'BL'
                REST.OF.LINE = COMMAND[3,99]
                GOSUB PROCESS.LOCATE.BACKWARD
                DEFAULT.COMMAND = 'LA'
             CASE COMMAND = 'LA'
                GOSUB PROCESS.LOCATE.AGAIN
                DEFAULT.COMMAND = 'LA'
          END CASE
       REPEAT
       RETURN
 
 
 
 
 *
 *
 * DISPLAY.PAGE
 *
 DISPLAY.PAGE: 
       IF LINE.CTR <= 0 THEN
          LINE.CTR = 0
          PREV.TOP.LINE.CTR = -PAGE.SIZE
       END
       IF BEG.COL # PREV.BEG.COL THEN
          PREV.TOP.LINE.CTR = TOP.LINE.CTR - PAGE.SIZE
       END
       TOP.LINE.CTR = LINE.CTR + 1
       PAGE.HEADING = HEADING.MSG
       PAGE.HEADING := '  Line ':TOP.LINE.CTR
       IF END.OF.FILE THEN
          PAGE.HEADING := ' of ':NUM.LINES
       END
       IF BEG.COL > 1 THEN
          PAGE.HEADING := '  Column ':BEG.COL
       END
       IF END.OF.FILE THEN
          PAGE.HEADING := '  Max line length: ':MAX.LEN
       END
       CRT @(0,0):PAGE.HEADING:@(IT$CLEOL)
       LINES.NEEDED = PAGE.SIZE
       GOSUB READ.LINES.IF.NEEDED
 *
       TOP.LINE.CTR.DIF = TOP.LINE.CTR - PREV.TOP.LINE.CTR
       BEGIN CASE
          CASE ABS(TOP.LINE.CTR.DIF) >= PAGE.SIZE
             NUM.LINES.TO.DISPLAY = PAGE.SIZE
             GOSUB DISPLAY.LINES
          CASE TOP.LINE.CTR.DIF > 0
             CRT @(0,PROMPT.LINE):@(IT$CLEOS):
             CRT @(0,1):@(IT$DL,TOP.LINE.CTR.DIF):
             LINES.KEPT = PAGE.SIZE - TOP.LINE.CTR.DIF
             CRT @(0,LINES.KEPT+1):
             LINE.CTR += LINES.KEPT
             NUM.LINES.TO.DISPLAY = TOP.LINE.CTR.DIF
             GOSUB DISPLAY.LINES
          CASE TOP.LINE.CTR.DIF < 0
             CRT @(0,PROMPT.LINE):@(IT$CLEOS):
             CRT @(0,1):@(IT$IL,-TOP.LINE.CTR.DIF):
             CRT @(0,PROMPT.LINE):@(IT$CLEOS):
             NUM.LINES.TO.DISPLAY = ABS(TOP.LINE.CTR.DIF)
             CRT @(0,1):
             GOSUB DISPLAY.LINES
             LINES.KEPT = PAGE.SIZE - ABS(TOP.LINE.CTR.DIF)
             LINE.CTR += LINES.KEPT
       END CASE
       PREV.TOP.LINE.CTR = TOP.LINE.CTR
       PREV.BEG.COL = BEG.COL
       RETURN
 
 
 *
 *
 * DISPLAY LINES
 *  (ASSUMES CURSOR IS ALREADY POSITIONED)
 *
 DISPLAY.LINES: 
       FOR DISPLAY.CTR=1 TO NUM.LINES.TO.DISPLAY
          LINE.CTR += 1
          DISPLAY.LINE = LINES<LINE.CTR>
          IF LINE.CTR = (NUM.LINES+1) AND END.OF.FILE THEN
             CRT EOF.LINE:@(IT$CLEOL)
          END ELSE
             CRT DISPLAY.LINE[BEG.COL,DISPLAY.WIDTH]:@(IT$CLEOL)
          END
       NEXT DISPLAY.CTR
       RETURN
 
 
 *
 *
 * PAGE.UP
 *
 PROCESS.PAGE.UP: 
       IF LINE.CTR = PAGE.SIZE THEN
          RETURN
       END
       IF REST.OF.LINE > 0 AND NUM(REST.OF.LINE) THEN
          NUM.TO.MOVE = REST.OF.LINE + PAGE.SIZE
       END ELSE
          NUM.TO.MOVE = PAGE.SIZE + PAGE.SIZE
       END
       LINE.CTR -= NUM.TO.MOVE
       GOSUB DISPLAY.PAGE
       RETURN
 
 
 *
 *
 * PAGE.DOWN
 *
 PROCESS.PAGE.DOWN: 
       IF END.OF.FILE AND LINE.CTR >= NUM.LINES THEN
          RETURN
       END
       IF REST.OF.LINE > 0 AND NUM(REST.OF.LINE) THEN
          LINES.NEEDED = REST.OF.LINE
          LINE.CTR += REST.OF.LINE - PAGE.SIZE
       END ELSE
          LINES.NEEDED = PAGE.SIZE
       END
       IF LINE.CTR > NUM.LINES THEN
          LINE.CTR = NUM.LINES - PAGE.SIZE + 1
       END
       GOSUB READ.LINES.IF.NEEDED
       GOSUB DISPLAY.PAGE
       RETURN
 
 
 *
 *
 * REDISPLAY SCREEN
 *
 PROCESS.REDISPLAY: 
       LINE.CTR -= PAGE.SIZE
       PREV.TOP.LINE.CTR = LINE.CTR - PAGE.SIZE
       CRT @(IT$CS):
       GOSUB DISPLAY.PAGE
       RETURN
 
 
 *
 *
 * TOP OF FILE
 *
 PROCESS.TOP: 
       LINE.CTR = 0
       BEG.COL = 1
       GOSUB DISPLAY.PAGE
       RETURN
 
 
 *
 *
 * BOTTOM OF FILE
 *
 PROCESS.BOTTOM: 
       LINES.NEEDED = 'ALL'
       GOSUB READ.LINES.IF.NEEDED
       LINE.CTR = NUM.LINES - PAGE.SIZE + 1
       PREV.LINE.CTR = LINE.CTR - PAGE.SIZE
       BEG.COL = 1
       GOSUB DISPLAY.PAGE
       RETURN
 
 
 *
 *
 * READ LINES IN IF IT IS NEEDED
 READ.LINES.IF.NEEDED: 
       IF END.OF.FILE THEN
          RETURN
       END
       IF LINES.NEEDED = 'ALL' THEN
          NUM.TO.READ = 'ALL'
          GOSUB READ.LINES
       END ELSE
          IF (LINE.CTR + LINES.NEEDED) > NUM.LINES THEN
             NUM.TO.READ = (LINE.CTR + LINES.NEEDED) - NUM.LINES
             GOSUB READ.LINES
          END
       END
       RETURN
 
 
 *
 *
 * READ GROUP OF LINES
 *
 READ.LINES: 
       IF END.OF.FILE THEN
          RETURN
       END
       READ.CTR = 0
       LOOP
       UNTIL END.OF.FILE OR (NUM.TO.READ # 'ALL' AND READ.CTR >= NUM.TO
C.READ)
          GOSUB READ.OS.LINE
          IF NOT(END.OF.FILE) THEN
             NUM.LINES += 1
             READ.CTR += 1
             LINES := OS.LINE:@FM
          END
       REPEAT
       RETURN
 
 
 *
 *
 * READ OS LINE FROM FILE
 *
 READ.OS.LINE: 
       IF (INDEX(OS.BUFFER,@FM,1) = 0) AND NOT(END.OF.FILE) THEN
 *
 * READ IN MORE FROM FILE
 *
          OSBREAD OS.RECORD FROM F.OS.FILE AT OS.POS LENGTH OS.BUFFER.S
CIZE
          LEN.RECORD = LEN(OS.RECORD)
          IF LEN.RECORD = 0 THEN
             END.OF.FILE = @TRUE
          END
          CONVERT CHAR(10) TO @FM IN OS.RECORD
          OS.POS += LEN.RECORD
          OS.BUFFER := OS.RECORD
       END
       OS.LINE = OS.BUFFER<1>
       DEL OS.BUFFER<1>
       LEN.LINE = LEN(OS.LINE)
       IF LEN.LINE > MAX.LEN THEN
          MAX.LEN = LEN.LINE
       END
       FOR CH.CTR=1 TO LEN.LINE
          CH = BITAND(SEQ(OS.LINE[CH.CTR]), 127)
          IF CH < 32 OR CH > 126 THEN OS.LINE[CH.CTR,1] = '.'
       NEXT CH.CTR
       RETURN
 
 
 *
 *
 * PROCESS RIGHT
 *
 PROCESS.RIGHT: 
       IF REST.OF.LINE > 0 AND NUM(REST.OF.LINE) THEN
          BEG.COL += REST.OF.LINE
       END ELSE
          BEG.COL += COL.SHIFT
       END
       LINE.CTR -= PAGE.SIZE
       GOSUB DISPLAY.PAGE
       RETURN
 
 
 *
 *
 * PROCESS LEFT
 *
 PROCESS.LEFT: 
       IF REST.OF.LINE > 0 AND NUM(REST.OF.LINE) THEN
          BEG.COL -= REST.OF.LINE
       END ELSE
          BEG.COL -= COL.SHIFT
       END
       IF BEG.COL < 1 THEN
          BEG.COL = 1
       END
       LINE.CTR -= PAGE.SIZE
       GOSUB DISPLAY.PAGE
       RETURN
 
 
 
 *
 *
 * PROCESS GOTO
 *
 PROCESS.GOTO: 
       LINE.COL = TRIM(REST.OF.LINE)
       CONVERT ' ' TO ',' IN LINE.COL
       G.LINE = FIELD(LINE.COL,',',1,1)
       IF G.LINE # '' AND NOT(NUM(G.LINE)) THEN
          RETURN
       END
       G.COL = FIELD(LINE.COL,',',2,1)
       IF G.COL # '' AND NOT(NUM(G.COL)) THEN
          RETURN
       END
       IF G.LINE = '' THEN
          IF G.COL # BEG.COL AND G.COL > 0 THEN
             BEG.COL = G.COL
             LINE.CTR -= PAGE.SIZE
             GOSUB DISPLAY.PAGE
          END
       END ELSE
          IF G.LINE > 0 THEN
             IF G.COL > 0 THEN
                BEG.COL = G.COL
             END
             LINE.CTR = G.LINE - 1
             GOSUB DISPLAY.PAGE
          END
       END
       RETURN
 
 
 
 *
 *
 * PROCESS GOTO COL
 *
 PROCESS.GOTO.COL: 
       G.COL = TRIM(REST.OF.LINE)
       IF G.COL # '' AND NOT(NUM(G.COL)) THEN
          RETURN
       END
       IF G.COL # BEG.COL AND G.COL > 0 THEN
          BEG.COL = G.COL
          LINE.CTR -= PAGE.SIZE
          GOSUB DISPLAY.PAGE
       END
       RETURN
 
 
 
 *
 *
 * PROCESS GOTO.LINE
 *
 PROCESS.GOTO.LINE: 
       G.LINE = TRIM(REST.OF.LINE)
       IF G.LINE # '' AND NOT(NUM(G.LINE)) THEN
          RETURN
       END
       IF G.LINE > 0 THEN
          LINE.CTR = G.LINE - 1
          GOSUB DISPLAY.PAGE
       END
       RETURN
 
 
 *
 *
 * PROCESS LOCATE FORWARD
 *
 PROCESS.LOCATE.FORWARD: 
       IF REST.OF.LINE = '' THEN
          GOSUB GET.LOCATE.TEXT
       END ELSE
          LOCATE.TEXT = REST.OF.LINE
       END
       IF LOCATE.TEXT = '' THEN
          RETURN
       END
 *
       LOCATE.OCCURENCE = 1
       START.LOCATE.LINE.CTR = TOP.LINE.CTR
       LOCATE.DIRECTION = 'FORWARD'
       GOSUB SEARCH.FOR.LOCATE.TEXT
       RETURN
 
 
 *
 *
 * GET LOCATE TEXT
 *
 GET.LOCATE.TEXT: 
       DEFAULT.ANS = ''
       LOCATE.PROMPT = 'Locate text'
       CALL PROMPT.ANS(LOCATE.TEXT,LOCATE.PROMPT,PROMPT.COL,PROMPT.LINE
C,VALID.ANS.LIST,DEFAULT.ANS,END.PARAM)
       RETURN
 
 
 *
 *
 * LOCATE THE TEXT
 *
 SEARCH.FOR.LOCATE.TEXT: 
       PRE.LOCATE.LINE.CTR = LINE.CTR
       LINE.CTR = START.LOCATE.LINE.CTR
       LOCATE.BEG.COL = 0
       REACHED.END = @FALSE
       LOOP
          LOCATE.BEG.COL = INDEX(LINES<LINE.CTR>,LOCATE.TEXT,LOCATE.OCC
CURENCE)
       UNTIL LOCATE.BEG.COL OR REACHED.END
          IF LOCATE.DIRECTION = 'FORWARD' THEN
             LINES.NEEDED = 1
             GOSUB READ.LINES.IF.NEEDED
             LINE.CTR += 1
             IF END.OF.FILE AND LINE.CTR > NUM.LINES THEN
                REACHED.END = @TRUE
             END
          END ELSE
             LINE.CTR -= 1
             IF LINE.CTR < 1 THEN
                REACHED.END = @TRUE
             END
          END
          LOCATE.OCCURENCE = 1
       REPEAT
       IF LOCATE.BEG.COL THEN
          GOSUB DISPLAY.LOCATED.TEXT
       END ELSE
          MSG = 'Could not find "':LOCATE.TEXT:'" -- Press RETURN to co
Cntinue'
          ANS = ''
          DEFAULT.ANS = ''
          CALL PROMPT.ANS(ANS,MSG,PROMPT.COL,PROMPT.LINE,VALID.ANS.LIST
C,DEFAULT.ANS,END.PARAM)
          LINE.CTR = PRE.LOCATE.LINE.CTR
       END
       RETURN
 
 
 *
 *
 * DISPLAY LOCATED TEXT
 *
 DISPLAY.LOCATED.TEXT: 
       LOCATE.LINE.CTR = LINE.CTR
       REDISPLAY.NEEDED = @TRUE
       IF LINE.CTR >= TOP.LINE.CTR AND LINE.CTR <= (TOP.LINE.CTR + PAGE
C.SIZE - 1) THEN
          REDISPLAY.NEEDED = @FALSE
       END
       LEN.LOCATE.TEXT = LEN(LOCATE.TEXT)
       LOCATE.END.COL = LOCATE.BEG.COL + LEN.LOCATE.TEXT - 1
       END.COL = BEG.COL + DISPLAY.WIDTH - 1
       IF LOCATE.BEG.COL < BEG.COL OR LOCATE.END.COL > END.COL THEN
          BEG.COL = INT((LOCATE.BEG.COL-1)/10)*10 + 1
          REDISPLAY.NEEDED = @TRUE
       END
       IF REDISPLAY.NEEDED THEN
          LINE.CTR -= 2
          GOSUB DISPLAY.PAGE
       END
       SCREEN.ROW = LOCATE.LINE.CTR - TOP.LINE.CTR + 1
       SCREEN.COL = LOCATE.BEG.COL - BEG.COL
       SCREEN.TEXT = LOCATE.TEXT[1,DISPLAY.WIDTH]
       LEN.SCREEN.TEXT = LEN(SCREEN.TEXT)
       CRT @(SCREEN.COL+LEN.SCREEN.TEXT,SCREEN.ROW):@(IT$EREV):
       IF SCREEN.COL = 0 THEN
          CRT @(SCREEN.COL,SCREEN.ROW):@(IT$SREV):SCREEN.TEXT[2,LEN.SCR
CEEN.TEXT-1]:
       END ELSE
          CRT @(SCREEN.COL-1,SCREEN.ROW):@(IT$SREV):SCREEN.TEXT:
       END
       MSG = 'Found "':LOCATE.TEXT:'" at line ':LOCATE.LINE.CTR:' colum
Cn ':LOCATE.BEG.COL
       ANS = ''
       DEFAULT.ANS = ''
       CALL PROMPT.ANS(ANS,MSG,PROMPT.COL,PROMPT.LINE,VALID.ANS.LIST,DE
CFAULT.ANS,END.PARAM)
       IF SCREEN.COL = 0 THEN
          ORIG.SCREEN.TEXT = LINES<LOCATE.LINE.CTR>[LOCATE.BEG.COL,LEN.
CSCREEN.TEXT+1]
          CRT @(SCREEN.COL,SCREEN.ROW):ORIG.SCREEN.TEXT:
       END ELSE
          ORIG.SCREEN.TEXT = LINES<LOCATE.LINE.CTR>[LOCATE.BEG.COL-1,LE
CN.SCREEN.TEXT+2]
          CRT @(SCREEN.COL-1,SCREEN.ROW):ORIG.SCREEN.TEXT:
       END
       RETURN
 
 
 *
 *
 * PROCESS LOCATE BACKWARD
 *
 PROCESS.LOCATE.BACKWARD: 
       IF REST.OF.LINE = '' THEN
          GOSUB GET.LOCATE.TEXT
       END ELSE
          LOCATE.TEXT = REST.OF.LINE
       END
       IF LOCATE.TEXT = '' THEN
          RETURN
       END
 *
       LOCATE.OCCURENCE = 1
       START.LOCATE.LINE.CTR = TOP.LINE.CTR + PAGE.SIZE - 1
       IF START.LOCATE.LINE.CTR > NUM.LINES THEN
          START.LOCATE.LINE.CTR = NUM.LINES
       END
       LOCATE.DIRECTION = 'BACKWARD'
       GOSUB SEARCH.FOR.LOCATE.TEXT
       RETURN
 
 
 *
 *
 * PROCESS LOCATE AGAIN
 *
 PROCESS.LOCATE.AGAIN: 
       IF LOCATE.DIRECTION = '' THEN
          RETURN
       END
       START.LOCATE.LINE.CTR = LOCATE.LINE.CTR
       LOCATE.OCCURENCE += 1
       GOSUB SEARCH.FOR.LOCATE.TEXT
       RETURN
 
 
 
 
    END
 ======== END OF RECORD ===============================================
 ### END OF FILE ######################################################
 ##### FILE CUSTOM.SUBROUTINES ####################    2 RECORDS ######
 ======== RECORD SEND.SPOOL.FILE.NETWORK ==========    68 FIELDS ======
       SUBROUTINE SEND.SPOOL.FILE.NETWORK(RETURN.MESSAGE, ADDRESSEE, SE
CNDER, SPOOL.ENTRY.NUMBER)
 *
 * INFO/BASIC PROGRAM
 * 01/26/95
 * DWS
 * TITLE ----- SEND.SPOOL.FILE.NETWORK
 *
 * MODULE : I-MAIL
 * PURPOSE: SEND A SPOOL FILE TO A NETWORK ADDRESS
 *
 *     Last updated by LIVE (SJOQUISTD) at 10:14:02 on 04/29/1993.
 *
 **********************************************************************
C***
 *
 
       $INSERT I_I.MAIL
       $INCLUDE LOCAL.SOURCE I_SPQUEUE.COMMON
 
 
 
       GOSUB SET.UP
       GOSUB LOAD.ITEMS
       GOSUB READ.SPOOL.FILE
       IF SPOOL.RECORD THEN
          GOSUB SEND.MESSAGE
       END
       RETURN
 
 
 
 SET.UP: 
       RETURN
 
 
 LOAD.ITEMS: 
       RETURN.STATUS = ''
       CALL LOAD.SPOOL.QUEUE(RETURN.STATUS)
       IF RETURN.STATUS # '' THEN
          MSG = 'ERROR ON SPOOL QUEUE: ':RETURN.STATUS<1>
          CRT
          CRT MSG
          STOP
       END
       RETURN
 
 
 
 READ.SPOOL.FILE: 
       SPOOL.RECORD = ''
       LOCATE SPOOL.ENTRY.NUMBER IN SPQUEUE.ENTRY.NUMBER.LIST<1> SETTIN
CG ENTRY.POS THEN
          SPOOL.FILE.NAME = SPQUEUE.SPOOL.NAME(ENTRY.POS)
          OSREAD SPOOL.RECORD FROM SPOOL.FILE.NAME ON ERROR
             MSG = 'FATAL ERROR READING ':SPOOL.FILE.NAME
             CRT MSG
             STOP
          END ELSE
             SPOOL.RECORD = ''
          END
       END
       RETURN
 
 SEND.MESSAGE: 
       SUBJECT = SPQUEUE.TITLE(ENTRY.POS)
       CALL SEND.MAIL.NETWORK(RETURN.MESSAGE, ADDRESSEE, SENDER, SUBJEC
CT, SPOOL.RECORD)
       RETURN
 
 
    END
 ======== END OF RECORD ===============================================
 ======== RECORD SEND.MAIL.NETWORK ================   136 FIELDS ======
       SUBROUTINE SEND.MAIL.NETWORK(RETURN.MESSAGE, PASSED.ADDRESSEE, P
CASSED.SENDER, SUBJECT, MAIL.MESSAGE)
 *
 * INFO/BASIC PROGRAM
 * 4/27/93
 * DWS
 * TITLE ----- SEND.MAIL.NETWORK
 *
 * MODULE : I-MAIL
 * PURPOSE: SEND MAIL TO A NETWORK ADDRESS
 *
 * Stamped: pty/ttyp2 rotmand, /disk1/collive, user #2123, 23 Jul 94, 0
C9:57AM.
 * HP-UX conversion
 *     Last updated by LIVE (SJOQUISTD) at 10:14:02 on 04/29/1993.
 *
 **********************************************************************
C***
 *
 
       $INSERT I_I.MAIL
 
 
 
       GOSUB SET.UP
       RETURN.MESSAGE = ''
       NUM.ADDRESSEES = COUNT(PASSED.ADDRESSEE,@VM) + (PASSED.ADDRESSEE
C # '')
       FOR ADDRESSEE.CTR=1 TO NUM.ADDRESSEES
          ADDRESSEE = PASSED.ADDRESSEE<1,ADDRESSEE.CTR>
          IF COUNT(ADDRESSEE,'@') = 0 THEN
             ADDRESSEE := '@':IMAILCM.TCP.ROUTER
          END
          ADDRESSEE = OCONV(ADDRESSEE,'MCL')
          GOSUB GENERATE.KEY
          GOSUB BUILD.HEADER
          GOSUB SEND.MESSAGE
       NEXT ADDRESSEE.CTR
       RETURN
 
 
 
 SET.UP: 
       ACTUAL.SENDER = OCONV(PASSED.SENDER<1,1>,'MCL')
       FULL.NAME = PASSED.SENDER<1,2>
       RETURN
 
 BUILD.HEADER: 
 * P1151
 * T780865698
 * DdfAA10212
 * Sroot
 * Rrotmand@cedarville.edu
 * Hreceived: by cdrvil.cedarville.edu
 *    (1.38.193.5/16.2) id AA10212; Thu, 29 Sep 1994 15:08:18 -0400
 * H?F?from: System Administrator <root>
 * H?x?full-name: System Administrator
 * H?P?return-path: <root>
 * Hsubject: sdfsdfsd
 * HTo: rotmand@cedarville.edu
 * Hdate: Thu, 29 Sep 94 15:08:18 EDT
 * HReply-To: sadfsdf@adfsdfsd.edu
 * Hmailer: Elm [revision: 70.85.2.1]
       SMTP.MAIL.REC = ''
       SMTP.MAIL.REC<-1> = 'P2374'
       SMTP.MAIL.REC<-1> = 'T774908950'
       SMTP.MAIL.REC<-1> = 'D':MESSAGE.KEY
       IF ACTUAL.SENDER THEN
          USE.SENDER = ACTUAL.SENDER
       END ELSE
          USE.SENDER = 'S':OCONV(@LOGNAME,'MCU'):'@':IMAILCM.TCP.ROUTER
       END
       SMTP.MAIL.REC<-1> = 'S':USE.SENDER
       SMTP.MAIL.REC<-1> = 'R':ADDRESSEE
       IF ACTUAL.SENDER THEN
          SMTP.MAIL.REC<-1> = 'HReturn-Path: <':ACTUAL.SENDER:'>'
          SMTP.MAIL.REC<-1> = 'HReply-To: <':USE.SENDER:'>'
          SMTP.MAIL.REC<-1> = 'HReceived: (from user ':ACTUAL.SENDER:')
C by ':IMAILCM.TCP.ROUTER
          SMTP.MAIL.REC := ' ':OCONV(DATE(),'D2 DMY[,A,]')
          SMTP.MAIL.REC := ' ':OCONV(TIME(),'MTH')
          SMTP.MAIL.REC<-1> = 'H?F?from:'
          IF FULL.NAME THEN
             SMTP.MAIL.REC := ' ':FULL.NAME
          END
          SMTP.MAIL.REC := ' <':ACTUAL.SENDER:'>'
          IF FULL.NAME THEN
             SMTP.MAIL.REC<-1> = 'H?F?full-name: ':FULL.NAME
          END
       END
       IF SUBJECT THEN
          SMTP.MAIL.REC<-1> = 'HSubject: ':SUBJECT
       END
       SMTP.MAIL.REC<-1> = 'HTo: ':ADDRESSEE
       IF ACTUAL.SENDER THEN
          SMTP.MAIL.REC<-1> = 'HFrom: ':USE.SENDER
       END
       SMTP.MAIL.REC<-1> = 'HDate:':' ':OCONV(DATE(),'D2 DMY[,A,]')
       SMTP.MAIL.REC := ' ':OCONV(TIME(),'MTH')
       RETURN
 
 
 *
 
 
 
 
 *
 GENERATE.KEY: 
       FOUND.SMTP.KEY = FALSE
       LOOP.COUNT = 0
       LOOP
          SMTP.KEY = 'qfAA':FMT(RND(99999),'5"0"R')
          READV TEST FROM IMAILCM.F.TCP.OUTGOING, SMTP.KEY, 0 ELSE
             FOUND.SMTP.KEY = TRUE
          END
       UNTIL FOUND.SMTP.KEY OR LOOP.COUNT > 20
          SLEEP(1)
          LOOP.COUNT += 1
       REPEAT
       IF NOT(FOUND.SMTP.KEY) THEN
          STOP 'UNABLE TO GENERATE NETWORK MAIL MESSAGE ':SMTP.KEY
       END
       MESSAGE.KEY = 'd':SMTP.KEY[2,999]
       RETURN
 
 
 SEND.MESSAGE: 
       WRITE SMTP.MAIL.REC ON IMAILCM.F.TCP.OUTGOING, SMTP.KEY
       OPEN '','UFD' TO F.UFD ELSE STOP 'OPEN UFD'
       WRITE SMTP.MAIL.REC ON F.UFD,'DLR9'
       TEMP.MESSAGE = MAIL.MESSAGE
       CONVERT @VM TO @FM IN TEMP.MESSAGE
 *DLR*      INS 'To: ':ADDRESSEE BEFORE TEMP.MESSAGE<1>
 *DLR*      INS 'From: ':USE.SENDER BEFORE TEMP.MESSAGE<1>
       WRITE TEMP.MESSAGE ON IMAILCM.F.TCP.OUTGOING, MESSAGE.KEY
       WRITE TEMP.MESSAGE ON F.UFD,'DLR8'
       RETURN.MESSAGE<-1> = 'NET':@SM:'via gateway ':IMAILCM.TCP.ROUTER
C:' key ':SMTP.KEY
       RETURN
 
    END
 ======== END OF RECORD ===============================================
 ### END OF FILE ######################################################
