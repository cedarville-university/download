*
* INFO/BASIC PROGRAM
* 07/15/94
* DWS
* TITLE ----- SAVING.KEY
*
*
* PURPOSE: DUPLICATE FUNCTIONALITY OF 'SELECT ... SAVING XYZ' WHERE
*          FIELD XYZ MAY BE A LONG LIST OF IDS SEPARATED BY CHAR(10),
*          @VM, @FM, @SM
*
*
* Stamped: pty/ttyp4 rotmand, /disk1/collive, user #2442, 25 May 95, 04:43PM.
* Add UNIQUE parameter.
* Stamped: pty/ttys3 sjoquist, /disk1/collive, user #16901, 15 Jul 94, 09:36AM.
*
*************************************************************************
*

      COMMAND.LINE = @SENTENCE

      GOSUB SET.UP
      GOSUB OPEN.FILE
      GOSUB PARSE.COMMAND
      IF FATAL.ERROR THEN
         STOP 'Fatal errors, can not continue.'
      END
*
      IF LIST.NAME THEN
         OPENSEQ 'SAVEDLISTS', LIST.NAME:'000' TO F.SEQ.FILE THEN
            WEOFSEQ F.SEQ.FILE
         END
      END
      DONE.LIST = @FALSE
      NUM.READ = 0
      LOOP
         READNEXT KEY FROM FROM.UNIT ELSE DONE.LIST = @TRUE
      UNTIL DONE.LIST
         GOSUB READ.RECORD
         IF DISPLAY.MODE THEN
            IF MOD(NUM.READ,10) = 0 THEN
               CRT '*':
               IF MOD(NUM.READ,500) = 0 THEN
                  CRT ' ':NUM.READ:' ':NUM.NEW:' ':NUM.MISSING
               END
            END
         END
         IF RECORD.OKAY THEN
            GOSUB PROCESS.RECORD
         END ELSE
            GOSUB PROCESS.MISSING
         END
      REPEAT
      IF DISPLAY.MODE THEN
         CRT
         CRT 'NUM.READ ':NUM.READ
         CRT 'NUM.NEW ':NUM.NEW
         CRT 'NUM.MISSING ':NUM.MISSING
      END
      IF LIST.NAME THEN
         CLOSESEQ F.SEQ.FILE
      END ELSE
         GOSUB SAVE.LIST
      END
      IF MISSING.LIST AND NOT(QUIET.MODE) THEN
         GOSUB DISPLAY.MISSING
      END
      STOP


SET.UP: 
      FROM.UNIT = 0
      TO.UNIT = 0
      QUIET.MODE = @FALSE
      DISPLAY.MODE = @FALSE
      LIST.NAME = ''
      UNIQUE.MODE = @FALSE
      FIELD.NAME = ''
      FILE.NAME = ''
      NUM.NEW = 0
      NEW.LIST = ''
      NUM.MISSING = 0
      MISSING.LIST = ''
*
      PARAM.STR = ''
      PARAM.QUOTED = ''
      NUM.PARAMS = 0
      CALL PARSE.LINE(COMMAND.LINE, PARAM.STR, PARAM.QUOTED, NUM.PARAMS)
      IF PARAM.STR<1> = 'RUN' THEN
         STARTING.PARAM = 4
      END ELSE
         STARTING.PARAM = 2
      END
      IF NUM.PARAMS < STARTING.PARAM + 1 THEN
         GOSUB DISPLAY.SYNTAX
         STOP
      END
      FATAL.ERROR = @FALSE
      RETURN


DISPLAY.SYNTAX: 
      CRT
      CRT 'Syntax:'
      CRT
      CRT '   SAVING.KEY FileName FieldName [QUIET] [UNIQUE] [FROM #] [TO #]'
      CRT '                                 [LIST list.name] [DISPLAY]'
      CRT
      CRT 'SAVING.KEY works from regular or expanded select lists.'
      CRT 'QUIET  turns off display of messages.'
      CRT 'UNIQUE removes duplicate entries in the list.'
      CRT 'DISPLAY turns on display of record count'
      CRT 'LIST list.name writes records directly to the SAVEDLISTS directory'
      RETURN


OPEN.FILE: 
      FILE.NAME = PARAM.STR<STARTING.PARAM>
      OPEN '', FILE.NAME TO F.DATA.FILE ELSE
         STOP 'Can not open "':FILE.NAME:'"'
      END
      FIELD.NAME = PARAM.STR<STARTING.PARAM+1>
      DICT.REC = ''
      ERRMSG = ''
      CALL GET.DICT.REC(FILE.NAME, FIELD.NAME, QUIET.MODE, DICT.REC, ERRMSG)
      IF ERRMSG THEN
         CRT ERRMSG
         FATAL.ERROR = @TRUE
CRT '1'
         RETURN
      END
*
      FIELD.TYPE = FIELD(DICT.REC<1>,' ',1,1)
      IF FIELD.TYPE # 'I' AND FIELD.TYPE # 'D' THEN
         CRT 'Illegal field type for "':FIELD.NAME:'", must by type D or I'
         FATAL.ERROR = @TRUE
CRT '2'
      END
      FIELD.LOC = DICT.REC<2>
      FIELD.SM = DICT.REC<6>
      IF FIELD.SM = '' THEN
         FIELD.SM = 'S'
      END
      RETURN


*
*
* PARSE REST OF COMMAND LINE CHECKING FOR ERRORS
*
PARSE.COMMAND: 
      PARAM.CTR = STARTING.PARAM + 1
      LOOP
         PARAM.CTR += 1
      UNTIL PARAM.CTR > NUM.PARAMS
         PARAM = OCONV(PARAM.STR<PARAM.CTR>,'MCU')
         BEGIN CASE
            CASE PARAM = 'FROM'
               PARAM.CTR += 1
               FROM.UNIT = PARAM.STR<PARAM.CTR>
               IF FROM.UNIT < 0 OR FROM.UNIT > 9 THEN
                  CRT 'FROM unit must be between 0 and 9 inclusive'
                  FATAL.ERROR = @TRUE
CRT '3'
               END
            CASE PARAM = 'TO'
               PARAM.CTR += 1
               TO.UNIT = PARAM.STR<PARAM.CTR>
               IF TO.UNIT < 0 OR TO.UNIT > 9 THEN
                  CRT 'TO unit must be between 0 and 9 inclusive'
                  FATAL.ERROR = @TRUE
CRT '4'
               END
            CASE PARAM = 'QUIET'
               QUIET.MODE = @TRUE
            CASE PARAM = 'UNIQUE'
               IF LIST.NAME THEN
                  CRT '"UNIQUE and LIST list.name" are mutually exclusive'
                  FATAL.ERROR = @TRUE
CRT '5'
               END
               UNIQUE.MODE = @TRUE
            CASE PARAM = 'LIST'
               IF UNIQUE.MODE THEN
                  CRT '"UNIQUE and LIST list.name" are mutually exclusive'
                  FATAL.ERROR = @TRUE
CRT '6'
               END
               PARAM.CTR += 1
               LIST.NAME = PARAM.STR<PARAM.CTR>
            CASE PARAM = 'DISPLAY'
               DISPLAY.MODE = @TRUE
            CASE 1
               CRT 'Unknown parameter: ':PARAM.QUOTED<PARAM.CTR>:PARAM.STR<PARAM.CTR:PARAM.QUOTED<PARAM.CTR>
         END CASE
      REPEAT
      RETURN


READ.RECORD: 
      @ID = KEY<1,1>
      VALUE.CTR = KEY<1,2>
      SUBVALUE.CTR = KEY<1,3>
      READ @RECORD FROM F.DATA.FILE, @ID THEN
         RECORD.OKAY = @TRUE
      END ELSE
         RECORD.OKAY = @FALSE
      END
      NUM.READ += 1
      RETURN


PROCESS.RECORD: 
      GOSUB GET.VALUE.LIST
      IF VALUE.LIST # '' THEN
         CONVERT @SM:@VM:@IM:CHAR(10) TO @FM:@FM:@FM:@FM IN VALUE.LIST
         NUM.VALUES = COUNT(VALUE.LIST,@FM) + 1
         FOR VALUE.CTR=1 TO NUM.VALUES
            VALUE = VALUE.LIST<VALUE.CTR>
            IF VALUE # '' THEN
               BEGIN CASE
                  CASE UNIQUE.MODE
                     LOCATE VALUE IN NEW.LIST<1> SETTING NEW.POS ELSE
                        NUM.NEW += 1
                        NEW.LIST<NUM.NEW> = VALUE
                     END
                  CASE LIST.NAME
                     NUM.NEW += 1
                     WRITESEQ VALUE TO F.SEQ.FILE ELSE STOP 'Can not write "':VALUE:'"'
                  CASE 1
                     NUM.NEW += 1
                     NEW.LIST<NUM.NEW> = VALUE
               END CASE
            END
         NEXT VALUE.CTR
      END
      RETURN



GET.VALUE.LIST: 
      BEGIN CASE
         CASE FIELD.TYPE = 'I'
            FIELD.VALUE = ITYPE(DICT.REC)
         CASE FIELD.TYPE = 'D' AND FIELD.LOC = 0
            FIELD.VALUE = @ID
         CASE FIELD.TYPE = 'D'
            FIELD.VALUE = @RECORD<FIELD.LOC>
         CASE 1
            FIELD.VALUE = ''
      END CASE
*
      IF VALUE.CTR > 0 AND FIELD.SM = 'M' THEN
         VALUE.LIST = FIELD.VALUE<1,VALUE.CTR>
      END ELSE
         VALUE.LIST = FIELD.VALUE
      END
      RETURN

PROCESS.MISSING: 
      NUM.MISSING += 1
      MISSING.LIST<NUM.MISSING> = @ID
      RETURN

DISPLAY.MISSING: 
      CRT 'The following record ids do not exist:'
      FOR CTR=1 TO NUM.MISSING
         CRT MISSING.LIST<CTR>
      NEXT CTR
      RETURN

SAVE.LIST: 
      CRT
      CRT NUM.NEW:' records selected to list ':TO.UNIT:'.'
      CRT
      FORMLIST NEW.LIST TO TO.UNIT
      RETURN

   END
