      SUBROUTINE PRINT.PAGE.PROCESS(FORM.NUM,NUM.ACTUAL.LINES,ERRMSG)
*
* INFO/BASIC SUBROUTINE
* 2/11/88
* DWS
* TITLE ----- PRINT.PAGE.PROCESS
*
*
* MODULE:  PRINT.PAGE
* PURPOSE: PRINT A SINGLE FORM FROM PARAMETERS IN COMMON &
*            BY USING @RECORD & @ID
*
* Stamped: pts_82 rotmand, /datatel/live/collive, user #29971, 19 Mar 07, 04:42PM.
*  Version 5.0
*  Add ATTACH.FILE option.
* Stamped: pb howders, /datatel/live/collive, user #18592, 23 Feb 04, 04:46PM.
*   and bowenr
*  When inserting data use DATA.ARRAY(FIELD.NUM)<1,KEY.NUM> instead of
*       DATA.ARRAY(FIELD.NUM)<1,-1>
* Stamped: qc rotmand, /datatel/live/collive, user #8284, 18 Dec 00, 09:20AM.
*  Version 4.0
*  Add FONT predefined field.
* Stamped: p2 rotmand, /disk1/collive, user #14054, 05 Apr 00, 07:42AM.
*  Implement sleep delay for sending email to large groups (pause
*  after every PP.MAIL.DELAY.INTERVAL records)
* Stamped: te rotmand, /disk1/collive, user #19746, 19 Mar 98, 12:32PM.
*   Invoke BPIOCP after FORM.FEED assignment so that TTY option
*   pages correctly.
*     Last updated by LIVE (ROTMAN) at 13:05:25 on 07/18/1991.
* Correct bug so that default values print on windows.
* Format source code.
*     Last updated by LIVE (ROTMAN) at 09:36:40 on 09/11/1989.
* Allow SUBROUTINE field type.
* Add &INITIALIZATION and &TERMINATION sections to definition file.
* Shorten subroutine names for customers with long account names.
*     Last updated by LIVE (SJOQUIST) at 12:07:38 on 05/17/1989.
* Upgrade to 3.2
*  PAGE.COUNT is number of pages printed for current record
*
*     Last updated by LIVE (SJOQUIST) at 15:58:32 on 12/14/1988.
* Upgrade to 3.0
*     Last updated by LIVE (SJOQUIST) at 10:13:23 on 02/16/1988.
*       REV 2.2
*       Allow expandable lines (for multi-value lists)
*       Allow options top.of.form
*        Allow inserting fields (instead of overlaying, default = overlay)
*     Last updated by LIVE (SJOQUIST) at 14:42:39 on 02/12/1988.
*        Allow multiple pages per run
*     Last updated by LIVE (SJOQUIST) at 13:48:15 on 02/11/1988.
*        Split into control program, Init sub, & Process sub
*     Last updated by LIVE (SJOQUIST) at 09:40:01 on 01/14/1988.
*
*
*************************************************************************
*
*  COPYRIGHT (C) 1989, ROTMAN & SJOQUIST
*
*      The information contained in this file is proprietary to
*      ROTMAN & SJOQUIST and shall not be reproduced in part or
*      in whole without their prior written authorization.
*      This file may be modified for the internal use of this
*      institution, but no part of this file nor any program or
*      file derived from it may be distributed to any other
*      individual or institution.
*
*************************************************************************
*

      $INSERT I_PRINT.PAGE.COMMON
      $INSERT I_PP.DATA.COMMON
*1


*
*
* MAIN CONTROL
*

      SAVE.ID = @ID
      SAVE.RECORD = @RECORD
      GOSUB SET.UP
      NUM.RECS(FORM.NUM) += 1
      FILE.NUM = 1
      GOSUB LOAD.PRIMARY.FIELDS
      FOR FILE.NUM=2 TO NUM.FILES(FORM.NUM)
         GOSUB READ.SECONDARY.FILE
      NEXT FILE.NUM
      GOSUB BUILD.PAGE
      IF NUM.LINE.UP(FORM.NUM) AND NUM.RECS(FORM.NUM) = 1 THEN
         IF NOT(PP.HAVE.MAIL) THEN
            GOSUB PRINT.LINE.UP
         END
      END
      GOSUB GENERATE.FORM
      IF PP.HAVE.MAIL THEN
         IF FORM.NUM = 1 THEN
            GOSUB SEND.FORM.AS.MAIL
         END
         IF PP.MAIL.DELAY.INTERVAL GT 0 THEN
            IF MOD(NUM.RECS(FORM.NUM),PP.MAIL.DELAY.INTERVAL) = 0 THEN
               CRT 'SLEEPING ':NUM.RECS(FORM.NUM):' RECORDS    ':PP.MAIL.DELAY.TIME:' SECONDS'
               SLEEP PP.MAIL.DELAY.TIME
            END
         END
      END
      @ID = SAVE.ID
      @RECORD = SAVE.RECORD
      RETURN





*
*
* SET UP
*
SET.UP: 
      FORM.PAGE.NUM = 0
      FMT.ID = SAVE.ID:': '
      FMT.SP = SPACE(LEN(FMT.ID))
      PC.INSERTING.MARKER = CHAR(1)
      PC.OVERLAY.MARKER = CHAR(2)
      NUM.ACTUAL.LINES = 0
      FORM.FEED = CHAR(12)
* DLR CHANGE HERE 03/19/98
      BPIOCP
* END DLCR CHANGE 03/19/98
      DIM INFO.REC(999)
      DIM HEADING.LINES(MAX.LINES)
      DIM FOOTING.LINES(MAX.LINES)
      DIM BODY.LINES(MAX.LINES*5)
      DIM NEW.PAGE.IN.BODY(MAX.LINES*5)
      MAT NEW.PAGE.IN.BODY = FALSE
      INFO.KEY = @ID<1,1,1>
      INFO.VALUE.NUM = @ID<1,2,1>
      INFO.SUBVALUE.NUM = @ID<1,3,1>
      @ID = INFO.KEY
*
*
      MAT DATA.ARRAY = ''
      RETURN




*
*
* LOAD FIELDS FROM PRIMARY FILE
*   FIRST LOAD ALL NON "EVALUATE" FIELDS (EVALUATE FIELDS MAY NEED DATA
*     FROM THE OTHER FIELDS TO OPERATE CORRECTLY)
*
*
LOAD.PRIMARY.FIELDS: 
      FILE.NUM = 1
      MATPARSE INFO.REC FROM @RECORD, @FM
      FOR FIELD.NUM=1 TO NUM.FIELDS(FORM.NUM)
         IF PP.FILE.NUM(FIELD.NUM,FORM.NUM) = FILE.NUM AND FIELD.TYPE(FIELD.NUM,FORM.NUM) # 'E' THEN
            GOSUB LOAD.FIELD
            DATA.ARRAY(FIELD.NUM) = INFO.DATA
         END
      NEXT FIELD.NUM
      FOR FIELD.NUM=1 TO NUM.FIELDS(FORM.NUM)
         IF PP.FILE.NUM(FIELD.NUM,FORM.NUM) = FILE.NUM AND FIELD.TYPE(FIELD.NUM,FORM.NUM) = 'E' THEN
            GOSUB LOAD.FIELD
            DATA.ARRAY(FIELD.NUM) = INFO.DATA
         END
      NEXT FIELD.NUM
*2
      RETURN


*
*
* LOAD A SINGLE FIELD
*
LOAD.FIELD: 
      BEGIN CASE
         CASE FIELD.TYPE(FIELD.NUM,FORM.NUM) = 'D'
            LOC = DICT.REC(FIELD.NUM,FORM.NUM)<2>
            IF LOC = 0 THEN
               INFO.DATA = INFO.KEY
            END ELSE
               INFO.DATA = INFO.REC(LOC)
            END
         CASE FIELD.TYPE(FIELD.NUM,FORM.NUM) = 'I'
            INFO.DATA = ITYPE(DICT.REC(FIELD.NUM,FORM.NUM))
         CASE FIELD.TYPE(FIELD.NUM,FORM.NUM) = 'E'
            RETURN.STATUS = ''
            RETURN.ERRMSG = ''
            CALL PP.EVAL.POST(INFO.DATA,POSTFIX.PHRASE(FIELD.NUM,FORM.NUM),RETURN.ERRMSG)
            IF RETURN.ERRMSG THEN
               ERRMSG<-1> = FMT.ID:'Error in evaluating phrase for field "':PP.FIELD(FIELD.NUM,FORM.NUM):'"'
               ERRMSG<-1> = FMT.SP:RETURN.ERRMSG
            END
         CASE FIELD.TYPE(FIELD.NUM,FORM.NUM) = 'P'
            INFO.DATA = PROMPT.VALUE(FIELD.NUM,FORM.NUM)
         CASE FIELD.TYPE(FIELD.NUM,FORM.NUM) = 'S'
            INFO.DATA = ''
            SUBR.NAME = PP.SUBR.NAMES(FIELD.NUM,FORM.NUM)
            CALL @SUBR.NAME(INFO.DATA)
         CASE FIELD.TYPE(FIELD.NUM,FORM.NUM) = 'STATIC'
            INFO.DATA = DEFAULT.VALUE(FIELD.NUM,FORM.NUM)
         CASE FIELD.TYPE(FIELD.NUM,FORM.NUM) = 'PRE'
            BEGIN CASE
               CASE DICT.NAME(FIELD.NUM,FORM.NUM) = 'DATE()'
                  INFO.DATA = DATE()
*
* PAGE.COUNT NEEDS SPECIAL HANDLING
*
               CASE DICT.NAME(FIELD.NUM,FORM.NUM) = 'PAGE.COUNT'
                  IF INSERTING(FIELD.NUM,FORM.NUM) THEN
                     INFO.DATA = PC.INSERTING.MARKER
                  END ELSE
                     INFO.DATA = PC.OVERLAY.MARKER
                  END
               CASE DICT.NAME(FIELD.NUM,FORM.NUM) = 'RECORD.COUNT'
                  INFO.DATA = NUM.RECS(FORM.NUM)
               CASE DICT.NAME(FIELD.NUM,FORM.NUM) = 'TIME()'
                  INFO.DATA = TIME()
               CASE DICT.NAME(FIELD.NUM,FORM.NUM) = 'TIMEDATE()'
                  INFO.DATA = TIMEDATE()
            END CASE
      END CASE
      RETURN


*
*
* READ SECONDARY FILE
*
READ.SECONDARY.FILE: 
      KEY.FIELD.NUM = PP.KEY.FIELD.NUM(FILE.NUM,FORM.NUM)
*
* DETERMINE WHICH KEYS TO USE
*
      FIELD.NUM = KEY.FIELD.NUM
      INFO.DATA = DATA.ARRAY(FIELD.NUM)
      GOSUB CALC.FIRST.LAST.VALUES
      FIRST.KEY = FIRST.VALUE
      LAST.KEY = LAST.VALUE
*
      F.FILE = F.PP.FILE(FILE.NUM,FORM.NUM)
      KEY.LIST = DATA.ARRAY(KEY.FIELD.NUM)
      FOR KEY.NUM=FIRST.KEY TO LAST.KEY
         INFO.KEY = KEY.LIST<1,KEY.NUM>
         @ID = INFO.KEY
         READ @RECORD FROM F.FILE, @ID ELSE
            @RECORD = ''
            ERRMSG<-1> = FMT.ID:'Could not read the record "':INFO.KEY:'" from "':PP.FILE.NAME(FILE.NUM,FORM.NUM):'"'
            ERRMSG<-1> = FMT.SP:'   using the field "':PP.FIELD(FIELD.NUM,FORM.NUM):'" for a key'
         END
*
*   FIRST LOAD ALL NON "EVALUATE" FIELDS (EVALUATE FIELDS MAY NEED DATA
*     FROM THE OTHER FIELDS TO OPERATE CORRECTLY)
*
         MATPARSE INFO.REC FROM @RECORD, @FM
         FOR FIELD.NUM=1 TO NUM.FIELDS(FORM.NUM)
            IF PP.FILE.NUM(FIELD.NUM,FORM.NUM) = FILE.NUM AND FIELD.TYPE(FIELD.NUM,FORM.NUM) # 'E' THEN
               GOSUB LOAD.FIELD
               IF MULTI.VALUE(KEY.FIELD.NUM,FORM.NUM) THEN
                  CONVERT @SM TO @TM IN INFO.DATA
                  CONVERT @VM TO @SM IN INFO.DATA
                  DATA.ARRAY(FIELD.NUM)<1,KEY.NUM> = INFO.DATA
               END ELSE
                  DATA.ARRAY(FIELD.NUM) = INFO.DATA
               END
            END
         NEXT FIELD.NUM
         FOR FIELD.NUM=1 TO NUM.FIELDS(FORM.NUM)
            IF PP.FILE.NUM(FIELD.NUM,FORM.NUM) = FILE.NUM AND FIELD.TYPE(FIELD.NUM,FORM.NUM) = 'E' THEN
               GOSUB LOAD.FIELD
               IF MULTI.VALUE(KEY.FIELD.NUM,FORM.NUM) THEN
                  CONVERT @SM TO @TM IN INFO.DATA
                  CONVERT @VM TO @SM IN INFO.DATA
                  DATA.ARRAY(FIELD.NUM)<1,KEY.NUM> = INFO.DATA
               END ELSE
                  DATA.ARRAY(FIELD.NUM) = INFO.DATA
               END
            END
         NEXT FIELD.NUM
      NEXT KEY.NUM
      RETURN


*
* BUILD PAGE
*
BUILD.PAGE: 
      MAT PRINT.LINES = MAT MASK.LINES
      NUM.PRINT.LINES = NUM.LINES(FORM.NUM)
*
*3
      FOR POSITION.NUM=1 TO NUM.POSITIONS(FORM.NUM)
         GOSUB PROCESS.POSITION
      NEXT POSITION.NUM
*
*
* DETERMINE HOW MANY LINES THE HEADING & FOOTING ARE BEFORE DECIDING HOW
* MUCH ROOM IS LEFT FOR THE BODY
*
      NUM.HEADING.LINES = 0
      FOR LINE.NUM=HEADING.BEGIN.LINE(FORM.NUM) TO HEADING.END.LINE(FORM.NUM)
         NUM.SUBLINES = COUNT(PRINT.LINES(LINE.NUM,FORM.NUM),@FM) + 1
         FOR SUBLINE.NUM=1 TO NUM.SUBLINES
            NUM.SUBVAL.LINES = COUNT(PRINT.LINES(LINE.NUM,FORM.NUM)<SUBLINE.NUM>,@VM) + 1
            FOR SUBVAL.LINE.NUM=1 TO NUM.SUBVAL.LINES
               IF SKIP.NULL.LINES(LINE.NUM,FORM.NUM) THEN
                  LINE.TO.BE.PRINTED = TRIM(PRINT.LINES(LINE.NUM,FORM.NUM)<SUBLINE.NUM,SUBVAL.LINE.NUM>)
               END ELSE
                  LINE.TO.BE.PRINTED = TRUE
               END
               IF LINE.TO.BE.PRINTED THEN
                  NUM.HEADING.LINES += 1
                  HEADING.LINES(NUM.HEADING.LINES) = PRINT.LINES(LINE.NUM,FORM.NUM)<SUBLINE.NUM,SUBVAL.LINE.NUM>
               END
            NEXT SUBVAL.LINE.NUM
         NEXT SUBLINE.NUM
      NEXT LINE.NUM
*
      NUM.FOOTING.LINES = 0
      FOR LINE.NUM=FOOTING.BEGIN.LINE(FORM.NUM) TO FOOTING.END.LINE(FORM.NUM)
         NUM.SUBLINES = COUNT(PRINT.LINES(LINE.NUM,FORM.NUM),@FM) + 1
         FOR SUBLINE.NUM=1 TO NUM.SUBLINES
            NUM.SUBVAL.LINES = COUNT(PRINT.LINES(LINE.NUM,FORM.NUM)<SUBLINE.NUM>,@VM) + 1
            FOR SUBVAL.LINE.NUM=1 TO NUM.SUBVAL.LINES
               IF SKIP.NULL.LINES(LINE.NUM,FORM.NUM) THEN
                  LINE.TO.BE.PRINTED = TRIM(PRINT.LINES(LINE.NUM,FORM.NUM)<SUBLINE.NUM,SUBVAL.LINE.NUM>)
               END ELSE
                  LINE.TO.BE.PRINTED = TRUE
               END
               IF LINE.TO.BE.PRINTED THEN
                  NUM.FOOTING.LINES += 1
                  FOOTING.LINES(NUM.FOOTING.LINES) = PRINT.LINES(LINE.NUM,FORM.NUM)<SUBLINE.NUM,SUBVAL.LINE.NUM>
               END
            NEXT SUBVAL.LINE.NUM
         NEXT SUBLINE.NUM
      NEXT LINE.NUM
*
      NUM.BODY.LINES = 0
      FOR LINE.NUM=BODY.BEGIN.LINE(FORM.NUM) TO BODY.END.LINE(FORM.NUM)
         IF NEW.PAGE(LINE.NUM,FORM.NUM) THEN
            NEW.PAGE.IN.BODY(NUM.BODY.LINES+1) = TRUE
         END
         IF FILL.MARGINS(LINE.NUM,FORM.NUM) THEN
            GOSUB PROCESS.FILL
         END
         NUM.SUBLINES = COUNT(PRINT.LINES(LINE.NUM,FORM.NUM),@FM) + 1
         FOR SUBLINE.NUM=1 TO NUM.SUBLINES
            NUM.SUBVAL.LINES = COUNT(PRINT.LINES(LINE.NUM,FORM.NUM)<SUBLINE.NUM>,@VM) + 1
            FOR SUBVAL.LINE.NUM=1 TO NUM.SUBVAL.LINES
               IF SKIP.NULL.LINES(LINE.NUM,FORM.NUM) THEN
                  LINE.TO.BE.PRINTED = TRIM(PRINT.LINES(LINE.NUM,FORM.NUM)<SUBLINE.NUM,SUBVAL.LINE.NUM>)
               END ELSE
                  LINE.TO.BE.PRINTED = TRUE
               END
               IF LINE.TO.BE.PRINTED THEN
                  NUM.BODY.LINES += 1
                  BODY.LINES(NUM.BODY.LINES) = PRINT.LINES(LINE.NUM,FORM.NUM)<SUBLINE.NUM,SUBVAL.LINE.NUM>
               END
            NEXT SUBVAL.LINE.NUM
         NEXT SUBLINE.NUM
      NEXT LINE.NUM
      RETURN


*
* PRINT OUT HEADING,BODY,& FOOTING
*
GENERATE.FORM: 
      IF PP.HAVE.MAIL THEN
         IF FORM.NUM = 1 THEN
            MAIL.MESSAGE = ''
         END ELSE
            PP.ATTACH.TEXT = ''
         END
      END
      LINES.PER.PAGE = PRINT.LINES.ON.FORM(FORM.NUM) - NUM.HEADING.LINES - NUM.FOOTING.LINES
      IF LINES.PER.PAGE < 1 THEN
         ERRMSG<-1> = FMT.ID:'The headings & footings are too large for this record: "':SAVE.ID:'"'
      END
      LINES.BEFORE.FOOTING = PRINT.LINES.ON.FORM(FORM.NUM) - NUM.FOOTING.LINES
      GOSUB PRINT.HEADINGS
      FOR BODY.LINE.NUM=1 TO NUM.BODY.LINES
         IF LINE.COUNT >= LINES.BEFORE.FOOTING OR NEW.PAGE.IN.BODY(BODY.LINE.NUM) THEN
            GOSUB PRINT.FOOTINGS
            GOSUB PRINT.HEADINGS
         END
         PRTLINE = BODY.LINES(BODY.LINE.NUM)
         GOSUB PRINT.LINE
         LINE.COUNT += 1
         NUM.ACTUAL.LINES += 1
      NEXT BODY.LINE.NUM
      GOSUB PRINT.FOOTINGS
      RETURN


*
*
* SEND FORM AS MAIL
*
SEND.FORM.AS.MAIL: 
      ADDRESSEE = DATA.ARRAY(MAIL.ID.FIELD.NUM)
      IF ADDRESSEE = '' THEN
         ERRMSG<-1> = FMT.ID:' no addressee specified by field ':MAIL.ID.FIELD
         RETURN
      END
      IF MAIL.SENDER = '' THEN
         SENDER = @LOGNAME
      END ELSE
         SENDER = MAIL.SENDER
      END
      RETURN.MESSAGE = ''
      BEGIN CASE
         CASE PP.HAVE.ATTACH
            X.USE.LANDSCAPE = @FALSE
            X.CHARS.PER.LINE = 80
            CRT 'SENDING ':ADDRESSEE:' ':MAIL.SUBJECT:' WITH ATTACHMENT FORM ':PP.ATTACH.FORM.NAME
            CONVERT CHAR(13) TO '' IN MAIL.MESSAGE
            CALL ATTACH.MAIL.NETWORK(RETURN.MESSAGE,ADDRESSEE,SENDER,MAIL.SUBJECT,MAIL.MESSAGE,PP.ATTACH.TEXT,X.USE.LANDSCAPE,X.CHARS.PER.LINE)
         CASE PP.HAVE.ATTACH.FILE
            CRT 'SENDING ':ADDRESSEE:' ':MAIL.SUBJECT:' ':PP.ATTACH.FILE.DIR:' ':PP.ATTACH.FILE.NAME
            CONVERT CHAR(13) TO '' IN MAIL.MESSAGE
            X.SPARE = ''
            CALL ATTACH.BINARY.NETWORK(RETURN.MESSAGE,ADDRESSEE,SENDER,MAIL.SUBJECT,MAIL.MESSAGE,PP.ATTACH.FILE.DIR,PP.ATTACH.FILE.NAME,X.SPARE)
         CASE 1
            CRT 'SENDING ':ADDRESSEE:' ':MAIL.SUBJECT
            CONVERT CHAR(13) TO '' IN MAIL.MESSAGE
            CALL SEND.MAIL.NETWORK(RETURN.MESSAGE,ADDRESSEE,SENDER,MAIL.SUBJECT,MAIL.MESSAGE)
      END CASE
      RETURN


*
*
* FILL LINE BETWEEN MARGINS
*
PROCESS.FILL: 
      FILL.LINE = PRINT.LINES(LINE.NUM,FORM.NUM)
      LEFT.MARGIN = FILL.MARGINS(LINE.NUM,FORM.NUM)<1,1>
      RIGHT.MARGIN = FILL.MARGINS(LINE.NUM,FORM.NUM)<1,2>
      FILL.LEN = RIGHT.MARGIN - LEFT.MARGIN + 1
      FILL.FMT = FILL.LEN:'T'
      CONVERT @FM:@VM:@SM:@TM TO '    ' IN FILL.LINE
      FILL.LINE = FMT(TRIM(FILL.LINE),FILL.FMT)
      CONVERT @TM TO @FM IN FILL.LINE
      IF LEFT.MARGIN < 2 THEN
         PRINT.LINES(LINE.NUM,FORM.NUM) = FILL.LINE
      END ELSE
         PRINT.LINES(LINE.NUM,FORM.NUM) = ''
         LEFT.MARGIN.SPACE = SPACE(LEFT.MARGIN-1)
         NUM.FILL.LINES = COUNT(FILL.LINE,@FM) + 1
         FOR FILL.CTR=1 TO NUM.FILL.LINES
            PRINT.LINES(LINE.NUM,FORM.NUM)<FILL.CTR> = LEFT.MARGIN.SPACE:FILL.LINE<FILL.CTR>
         NEXT FILL.CTR
      END
      RETURN


*
*
* PRINT HEADINGS
*
PRINT.HEADINGS: 
      NUM.PAGES(FORM.NUM) += 1
      FORM.PAGE.NUM += 1
      IF TOP.OF.FORM(FORM.NUM) = 'FORM.FEED' THEN
         IF PP.HAVE.MAIL THEN
            NULL
         END ELSE
            PRINT FORM.FEED
         END
      END
      FOR HEADING.LINE.NUM=1 TO NUM.HEADING.LINES
         PRTLINE = HEADING.LINES(HEADING.LINE.NUM)
         GOSUB PRINT.LINE
      NEXT HEADING.LINE.NUM
      LINE.COUNT = NUM.HEADING.LINES
      NUM.ACTUAL.LINES += NUM.HEADING.LINES
      RETURN


*
*
* PRINT FOOTINGS
*
PRINT.FOOTINGS: 
      IF FOOTING.END.LINE(FORM.NUM) = -1 AND TOP.OF.FORM(FORM.NUM) # 'BLANKS' THEN
         RETURN
      END
      NUM.BLANKS = LINES.BEFORE.FOOTING - LINE.COUNT
      IF NUM.BLANKS < 1 THEN
         NUM.BLANKS = 0
      END
      FOR FOOTING.LINE.NUM=1 TO NUM.BLANKS
         IF PP.HAVE.MAIL THEN
            IF FORM.NUM = 1 THEN
               MAIL.MESSAGE := @FM
            END ELSE
               PP.ATTACH.TEXT := @FM
            END
         END ELSE
            PRINT
         END
      NEXT FOOTING.LINE.NUM
      FOR FOOTING.LINE.NUM=1 TO NUM.FOOTING.LINES
         PRTLINE = FOOTING.LINES(FOOTING.LINE.NUM)
         GOSUB PRINT.LINE
      NEXT FOOTING.LINE.NUM
      NUM.ACTUAL.LINES += NUM.BLANKS + NUM.FOOTING.LINES
      LINE.COUNT += NUM.BLANKS + NUM.FOOTING.LINES
      IF TOP.OF.FORM(FORM.NUM) = 'BLANKS' THEN
         FOR FOOTING.LINE.NUM=(PRINT.LINES.ON.FORM(FORM.NUM) + 1) TO FORM.LENGTH(FORM.NUM)
            IF PP.HAVE.MAIL THEN
               IF FORM.NUM = 1 THEN
                  MAIL.MESSAGE := @FM
               END ELSE
                  PP.ATTACH.TEXT := @FM
               END
            END ELSE
               PRINT
            END
            NUM.ACTUAL.LINES += 1
            LINE.COUNT += 1
         NEXT FOOTING.LINE.NUM
      END
      RETURN


*
*
* PRINT LINE
*  (LOOK FOR PAGE.COUNT.MARKER)
*
PRINT.LINE: 
      PAGE.NUM = FORM.PAGE.NUM
      COPY.LEN = LEN(PRTLINE) + LEN(PAGE.NUM)
      PAGE.NUM.LEN = LEN(PAGE.NUM)
      LOOP
         PC.COL = INDEX(PRTLINE,PC.INSERTING.MARKER,1)
      UNTIL NOT(PC.COL)
         PRTLINE = PRTLINE[1,PC.COL-1]:PAGE.NUM:PRTLINE[PC.COL+1,COPY.LEN]
      REPEAT
      LOOP
         PC.COL = INDEX(PRTLINE,PC.OVERLAY.MARKER,1)
      UNTIL NOT(PC.COL)
         PRTLINE = PRTLINE[1,PC.COL-PAGE.NUM.LEN]:PAGE.NUM:PRTLINE[PC.COL+1,COPY.LEN]
      REPEAT
      IF PP.HAVE.MAIL THEN
         IF FORM.NUM = 1 THEN
            MAIL.MESSAGE := PRTLINE:@FM
         END ELSE
            PP.ATTACH.TEXT := PRTLINE:@FM
         END
      END ELSE
         PRINT PRTLINE
      END
      RETURN


*
*
* PRINT LINE.UP
*
PRINT.LINE.UP: 
      LC.FOOTING = FOOTING.END.LINE(FORM.NUM) - FOOTING.BEGIN.LINE(FORM.NUM) + 1
      IF LC.FOOTING < 0 THEN
         LC.FOOTING = 0
      END
      LINE.UP.LC.BEFORE.FOOTING = PRINT.LINES.ON.FORM(FORM.NUM) - LC.FOOTING
      FOR LINE.UP.CTR=1 TO NUM.LINE.UP(FORM.NUM)
         GOSUB PRINT.LINE.UP.HEADINGS
         FOR LINE.NUM=BODY.BEGIN.LINE(FORM.NUM) TO BODY.END.LINE(FORM.NUM)
            IF LINE.UP.LINE.COUNT >= LINE.UP.LC.BEFORE.FOOTING OR NEW.PAGE(LINE.NUM,FORM.NUM) THEN
               GOSUB PRINT.LINE.UP.FOOTINGS
               GOSUB PRINT.LINE.UP.HEADINGS
            END
            PRINT DUMMY.LINES(LINE.NUM,FORM.NUM)
            LINE.UP.LINE.COUNT += 1
         NEXT LINE.NUM
         GOSUB PRINT.LINE.UP.FOOTINGS
      NEXT LINE.UP.CTR
      RETURN


*
* PRINT LINE.UP HEADING
*
PRINT.LINE.UP.HEADINGS: 
      IF TOP.OF.FORM(FORM.NUM) = 'FORM.FEED' THEN
         PRINT FORM.FEED
      END
      LINE.UP.LINE.COUNT = 0
      FOR HEADING.LINE.NUM=HEADING.BEGIN.LINE(FORM.NUM) TO HEADING.END.LINE(FORM.NUM)
         PRINT DUMMY.LINES(HEADING.LINE.NUM,FORM.NUM)
         LINE.UP.LINE.COUNT += 1
      NEXT HEADING.LINE.NUM
      RETURN



*
*
* PRINT LINE.UP.FOOTINGSS
*
PRINT.LINE.UP.FOOTINGS: 
      IF FOOTING.END.LINE(FORM.NUM) = -1 AND TOP.OF.FORM(FORM.NUM) # 'BLANKS' THEN
         RETURN
      END
      NUM.BLANKS = LINE.UP.LC.BEFORE.FOOTING - LINE.UP.LINE.COUNT
      IF NUM.BLANKS < 1 THEN
         NUM.BLANKS = 0
      END
      FOR FOOTING.LINE.NUM=1 TO NUM.BLANKS
         PRINT
      NEXT FOOTING.LINE.NUM
      FOR FOOTING.LINE.NUM=FOOTING.BEGIN.LINE(FORM.NUM) TO FOOTING.END.LINE(FORM.NUM)
         PRINT DUMMY.LINES(FOOTING.LINE.NUM,FORM.NUM)
      NEXT FOOTING.LINE.NUM
      LINE.UP.LINE.COUNT += NUM.BLANKS + LC.FOOTING
      IF TOP.OF.FORM(FORM.NUM) = 'BLANKS' THEN
         FOR FOOTING.LINE.NUM=(PRINT.LINES.ON.FORM(FORM.NUM) + 1) TO FORM.LENGTH(FORM.NUM)
            PRINT
         NEXT FOOTING.LINE.NUM
      END
      RETURN

*
* BUILD FIELD
*
PROCESS.POSITION: 
      ROW = ROW.NUM(POSITION.NUM,FORM.NUM)
      COLUMN = COLUMN.NUM(POSITION.NUM,FORM.NUM)
      FIELD.NUM = RC.FIELD.NUM(POSITION.NUM,FORM.NUM)
      FILE.NUM = PP.FILE.NUM(FILE.NUM,FORM.NUM)
      INFO.DATA = DATA.ARRAY(FIELD.NUM)
      GOSUB BUILD.PRINT.LINES
      RETURN



*
* BUILD CONV.CODE
*
BUILD.CONV.CODE: 
      TEMP = OCONV(INFO.VALUE,CONV.CODE(FIELD.NUM,FORM.NUM))
      IF STATUS() AND INFO.VALUE NE '' THEN
         LOCATE 'CONV' IN IGNORE.ERROR(FIELD.NUM,FORM.NUM)<1> SETTING POS ELSE
            ERRMSG<-1> = FMT.ID:'Cannot convert "':PP.FILE.NAME(FILE.NUM,FORM.NUM):'" "':PP.FIELD(FIELD.NUM,FORM.NUM):'" using conv code "':CONV.CODE(FIELD.NUM,FORM.NUM):'" for record "':INFO.KEY:'"'
         END
      END ELSE
         INFO.VALUE = TEMP
      END
      RETURN



*
* BUILD SPECIAL.CONV.CODE
*
BUILD.SPECIAL.CONV.CODE: 
      IF NOT(NUM(INFO.VALUE)) THEN
         LOCATE 'SPECIAL.CONV' IN IGNORE.ERROR(FIELD.NUM,FORM.NUM)<1> SETTING POS ELSE
            ERRMSG<-1> = FMT.ID:'Cannot convert "':PP.FILE.NAME(FILE.NUM,FORM.NUM):'" "':PP.FIELD(FIELD.NUM,FORM.NUM):'" using special conv "':SPECIAL.CONV.CODE(FIELD.NUM,FORM.NUM):'" for record "':INFO.KEY:'"'
            RETURN
         END
      END
      SPECIAL.CODE = SPECIAL.CONV.CODE(FIELD.NUM,FORM.NUM)
      BEGIN CASE
*
* UNIDATA SYSTEM DATE OF '0' IS A SUNDAY
*
         CASE SPECIAL.CODE = 'DAY.OF.WEEK'
            INFO.VALUE = MOD(INFO.VALUE,7) + 1
         CASE SPECIAL.CODE = 'DAY.OF.WEEK.TEXT'
            INFO.VALUE = DAY.OF.WEEK.TEXT(MOD(INFO.VALUE,7) + 1)
         CASE SPECIAL.CODE = 'MONTH.TEXT'
            INFO.VALUE = MONTH.TEXT(OCONV(INFO.VALUE,'DM[2]'))
         CASE SPECIAL.CODE = 'DATE.TEXT'
            INFO.VALUE = MONTH.TEXT(OCONV(INFO.VALUE,'DM[2]')):' ':(OCONV(INFO.VALUE,'DD')+0):', ':OCONV(INFO.VALUE,'D4Y')
      END CASE
      RETURN


*
* BUILD FMT.CODE
*
BUILD.FMT.CODE: 
      TEMP = FMT(INFO.VALUE,FMT.CODE(FIELD.NUM,FORM.NUM))
      IF STATUS() THEN
         LOCATE 'FMT' IN IGNORE.ERROR(FIELD.NUM,FORM.NUM)<1> SETTING POS ELSE
            ERRMSG<-1> = FMT.ID:'Cannot format "':PP.FILE.NAME(FILE.NUM,FORM.NUM):'" "':PP.FIELD(FIELD.NUM,FORM.NUM):'" using fmt code "':FMT.CODE(FIELD.NUM,FORM.NUM):'" for record "':INFO.KEY:'"'
         END
      END ELSE
         INFO.VALUE = TEMP
      END
      RETURN


*
* BUILD PRINT.LINES
*
BUILD.PRINT.LINES: 
*
*    DETERMINE HOW MANY & WHICH VALUES TO USE FOR MV FIELD
*
      IF MULTI.VALUE(FIELD.NUM,FORM.NUM) THEN
         GOSUB CALC.FIRST.LAST.VALUES
         GOSUB POSITION.WINDOW
*
*   SINGLE VALUE ITEM
*
      END ELSE
         LINE.NUM = ROW
         SUBLINE.NUM = 0
         SUBVAL.LINE.NUM = 0
         INFO.VALUE = INFO.DATA<1,1,1>
         GOSUB POSITION.VALUE
      END
      RETURN


*
*
* CALCULATE THE FIRST & LAST VALUE #'S FOR THIS MV FIELD
*
CALC.FIRST.LAST.VALUES: 
      IF BY.EXP(FIELD.NUM,FORM.NUM) THEN
         FIRST.VALUE = INFO.VALUE.NUM
         LAST.VALUE = INFO.VALUE.NUM
      END ELSE
         NUM.VAL.FOUND = COUNT(INFO.DATA,@VM) + (INFO.DATA # '')
         IF USE.LAST.VALUES(FIELD.NUM,FORM.NUM) THEN
            LAST.VALUE = NUM.VAL.FOUND
            FIRST.VALUE = NUM.VAL.FOUND - NUM.VALUES(FIELD.NUM,FORM.NUM) + 1
            IF FIRST.VALUE < 1 THEN FIRST.VALUE = 1
         END ELSE
            FIRST.VALUE = 1
            LAST.VALUE = NUM.VALUES(FIELD.NUM,FORM.NUM)
            IF LAST.VALUE > NUM.VAL.FOUND THEN LAST.VALUE = NUM.VAL.FOUND
         END
      END
      RETURN


*
*   POSITION "WINDOW" FOR MV FIELDS
*
POSITION.WINDOW: 
      IF LAST.VALUE < FIRST.VALUE THEN
         IF DEFAULT.VALUE(FIELD.NUM,FORM.NUM) = '' THEN
            RETURN
         END ELSE
            LAST.VALUE = FIRST.VALUE
         END
      END
      FOR VALUE.NUM=FIRST.VALUE TO LAST.VALUE
         INFO.VALUE = INFO.DATA<1,VALUE.NUM>
         IF EXPAND.LINES(FIELD.NUM,FORM.NUM) THEN
            LINE.NUM = ROW
            SUBLINE.NUM = VALUE.NUM - FIRST.VALUE + 1
            LAST.SUBVALUE = COUNT(INFO.VALUE,@SM) + 1
            IF LAST.SUBVALUE > NUM.SUBVALUES(FIELD.NUM,FORM.NUM) THEN
               LAST.SUBVALUE = NUM.SUBVALUES(FIELD.NUM,FORM.NUM)
            END
         END ELSE
            LINE.NUM = ROW + VALUE.NUM - FIRST.VALUE
            SUBLINE.NUM = 0
            LAST.SUBVALUE = NUM.SUBVALUES(FIELD.NUM,FORM.NUM)
         END
         ORIG.INFO.VALUE = INFO.VALUE
         FOR SUBVAL.LINE.NUM=1 TO LAST.SUBVALUE
            INFO.VALUE = ORIG.INFO.VALUE<1,1,SUBVAL.LINE.NUM>
            IF LINE.NUM <= MAX.LINES THEN
               GOSUB POSITION.VALUE
            END
         NEXT SUBVAL.LINE.NUM
      NEXT VALUE.NUM
      RETURN


*
* POSITION VALUE
*
POSITION.VALUE: 
*
* CHECK FOR NULL VALUE & USE DEFAULT VALUE INSTEAD
*
      IF INFO.VALUE = '' THEN
         INFO.VALUE = DEFAULT.VALUE(FIELD.NUM,FORM.NUM)
      END
      IF CONV.CODE(FIELD.NUM,FORM.NUM) THEN
         GOSUB BUILD.CONV.CODE
      END
      IF SPECIAL.CONV.CODE(FIELD.NUM,FORM.NUM) THEN
         GOSUB BUILD.SPECIAL.CONV.CODE
      END
      IF FMT.CODE(FIELD.NUM,FORM.NUM) THEN
         GOSUB BUILD.FMT.CODE
      END
*
*  IF INSERTING THE FIELD, REMOVE THE SPACES GENERATED BY THE FMT
*
      IF INSERTING(FIELD.NUM,FORM.NUM) THEN
         INFO.VALUE = TRIM(INFO.VALUE)
      END
      IF MAX.LENGTH(FIELD.NUM,FORM.NUM) THEN
         INFO.VALUE = INFO.VALUE[1,MAX.LENGTH(FIELD.NUM,FORM.NUM)]
      END
*
      IF LINE.NUM > NUM.PRINT.LINES THEN
         NUM.PRINT.LINES = LINE.NUM
      END
*
*
* THERE ARE TWO OPTIONS HERE WE NEED TO CONSIDER:
*  1. EXPAND.LINES:
*      SUBLINE.NUM TELLS US WHICH EXPANSION LINE IT IS, IF THIS FIELD IS
*      NOT EXPAND.LINES, THEN SUBLINE.NUM = 0 GIVING US THE SINGLE
*      ORIGINAL LINE; OTHERWISE, IT INSERTS LINES AS WE NEED THEM.
*      NUM.VALUES GIVES US THE MAXIMUM LINES TO EXPAND TO.
*         (THE DEFAULT FOR NUM.VALUES WITH EXPAND.LINES IS INFINITE,
*                          WITHOUT EXPAND.LINES IS 1.)
*  2. INSERTING
*      THIS ALLOWS THE INSERTION OF THE VALUE INTO THE LINE INSTEAD OF
*      OVERLAYING IT.
*
      LEN.VALUE = LEN(INFO.VALUE)
      TEMP.LINE = PRINT.LINES(LINE.NUM,FORM.NUM)<SUBLINE.NUM,SUBVAL.LINE.NUM>
      LEN.LINE = LEN(TEMP.LINE)
      PREVCOL = COLUMN - 1
      IF LEN.LINE < PREVCOL THEN
         TEMP.LINE := SPACE(PREVCOL-LEN.LINE):INFO.VALUE
      END ELSE
         IF INSERTING(FIELD.NUM,FORM.NUM) THEN
            PARTIAL.BEFORE = TEMP.LINE[1,PREVCOL]
            PARTIAL.AFTER = TEMP.LINE[COLUMN,LEN.LINE]
            TEMP.LINE = PARTIAL.BEFORE:INFO.VALUE:PARTIAL.AFTER
         END ELSE
            IF LEN.LINE < PREVCOL + LEN.VALUE THEN
               PARTIAL.BEFORE = TEMP.LINE[1,PREVCOL]
               TEMP.LINE = PARTIAL.BEFORE:INFO.VALUE
            END ELSE
               PARTIAL.BEFORE = TEMP.LINE[1,PREVCOL]
               PARTIAL.AFTER = TEMP.LINE[COLUMN+LEN.VALUE,LEN.LINE]
               TEMP.LINE = PARTIAL.BEFORE:INFO.VALUE:PARTIAL.AFTER
            END
         END
      END
      PRINT.LINES(LINE.NUM,FORM.NUM)<SUBLINE.NUM,SUBVAL.LINE.NUM> = TEMP.LINE
      RETURN



   END
