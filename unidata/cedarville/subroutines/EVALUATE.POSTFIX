      SUBROUTINE EVALUATE.POSTFIX(RETURN.VALUE,POSTFIX.STRING,RETURN.STATUS)
*
* INFO/BASIC SUBROUTINE
* 7/26/88
* DWS
* TITLE ----- EVALUATE.POSTFIX
*
*
* MODULE : EVALUATE.PHRASE
* PURPOSE: CALCULATE VALUE OF POSTFIX STRING (ASSUMES ALL FIELDS &
*             & VARIABLES HAVE BEEN RESOLVED, AND ONLY VALUES ARE PASSED)
*
*     Last updated by LIVE (SJOQUIST) at 15:18:37 on 07/26/1988.
*
*************************************************************************
*

$INSERT I_OPERATORS.COMMON
$INSERT I_EVALUATE.PHRASE.COMMON

*
*
* MAIN CONTROL
*

      GOSUB SET.UP
      GOSUB PROCESS.STRING
      GOSUB GET.VALUE
      RETURN



*
* SETUP
*
SET.UP:
      RETURN.STATUS = 0
      MAX.STACK = 1500
      DIM STACK(MAX.STACK)
      STACK.PTR = 0
      MAT EP.FLD.CALCULATED = ''
      MAT EP.FLD.RESULT = ''
      RETURN


*
* PROCESS STRING
*
PROCESS.STRING:
*
* RESET STRING FOR REMOVE FUNCTION
*
      POSTFIX.STRING = POSTFIX.STRING
      LOOP
         REMOVE ITEM.TYPE FROM POSTFIX.STRING SETTING DELIM
*
* ALL VALUES ARE ONE SET OF LITERAL VALUES
*   (ALLOWS PHRASE "WITH MAJOR = 'EDUC''UNDEC'")
*
         REMOVE ITEM FROM POSTFIX.STRING SETTING DELIM
         LOOP
         UNTIL DELIM # 3
            REMOVE NEXT.ITEM FROM POSTFIX.STRING SETTING DELIM
            ITEM := @VM:NEXT.ITEM
         REPEAT
*
         BEGIN CASE
            CASE ITEM.TYPE = 'F'
               GOSUB EVALUATE.FIELDS
            CASE ITEM.TYPE = 'O'
               ON OP.TYPE(ITEM) GOSUB FUNC.ARITHMETIC, FUNC.STRING, FUNC.COMPARISON, FUNC.LOGICAL, FUNC.FUNCTIONS, FUNC.IF
            CASE 1
               VALUE = ITEM
               GOSUB PUSH
         END CASE
      UNTIL DELIM = 0
      REPEAT
      RETURN


*
*
* EVALUATE FIELDS
*
EVALUATE.FIELDS:
*
* STORE RESULT FOR USE LATER IN CALC IF NEEDED
*  (EG.   (BALANCE + (BALANCE*1.05))
*
      IF EP.FLD.CALCULATED(ITEM) THEN
         VALUE = EP.FLD.RESULT(ITEM)
      END ELSE
         FIELD.TYPE = EP.DICT.REC(ITEM)<1>[1,1]
         BEGIN CASE
            CASE FIELD.TYPE = 'I'
               VALUE = ITYPE(EP.DICT.REC(ITEM))
            CASE FIELD.TYPE = 'D'
               FIELD.LOC = EP.DICT.REC(ITEM)<2>
               IF FIELD.LOC = 0 THEN
                  VALUE = @ID
               END ELSE
                  VALUE = @RECORD<FIELD.LOC>
               END
            CASE 1
               VALUE = ''
         END CASE
         EP.FLD.CALCULATED(ITEM) = 1
         EP.FLD.RESULT(ITEM) = VALUE
      END
      GOSUB PUSH
      RETURN


*
*  ARITHMETIC FUNCTIONS:
*
FUNC.ARITHMETIC:
      IF ITEM <= 2 THEN
         GOSUB POP
      END ELSE
         GOSUB POP.2
      END
      ON ITEM GOSUB FUNC.UNARY.MINUS, FUNC.UNARY.PLUS, FUNC.EXP, FUNC.MULT, FUNC.DIV, FUNC.ADD, FUNC.SUB
      GOSUB PUSH
      RETURN
*
FUNC.UNARY.MINUS:
      VALUE = -VALUE
      RETURN
FUNC.UNARY.PLUS:
      VALUE = VALUE
      RETURN
FUNC.EXP:
      VALUE = V2 ** V1
      RETURN
FUNC.MULT:
      VALUE = V1 * V2
      RETURN
FUNC.DIV:
      VALUE = V2/V1
      RETURN
FUNC.ADD:
      VALUE = V1 + V2
      RETURN
FUNC.SUB:
      VALUE = V2 - V1
      RETURN
*
* STRING FUNCTIONS
*
FUNC.STRING:
      GOSUB POP.2
      GOSUB FUNC.CAT                    ;* ONLY STRING FUNCTION RIGHT NOW
      GOSUB PUSH
      RETURN
*
FUNC.CAT:
      VALUE = V2:V1
      RETURN

*
* COMPARISON FUNCTIONS
*   ALL COMPARE OPS ALLOW FOR COMPARISON WITH MULTIPLE LITERAL VALUES
*
FUNC.COMPARISON:
      GOSUB POP.2
      VALUE = 0
      FUNC.NUMBER = ITEM - 8
      LOOP
         REMOVE SV.V2 FROM V2 SETTING V2.DELIM
         V1 = V1
         LOOP
            REMOVE SV.V1 FROM V1 SETTING V1.DELIM
            ON FUNC.NUMBER GOSUB FUNC.LT, FUNC.GT, FUNC.EQ, FUNC.NE, FUNC.LE, FUNC.GE, FUNC.MATCH
         UNTIL V1.DELIM = 0 OR VALUE
         REPEAT
      UNTIL V2.DELIM = 0 OR VALUE
      REPEAT
      GOSUB PUSH
      RETURN
*
FUNC.LT:
      VALUE = (SV.V2 < SV.V1)
      RETURN
FUNC.GT:
      VALUE = (SV.V2 > SV.V1)
      RETURN
FUNC.EQ:
      VALUE = (SV.V2 = SV.V1)
      RETURN
FUNC.NE:
      VALUE = (SV.V2 # SV.V1)
      RETURN
FUNC.LE:
      VALUE = (SV.V2 <= SV.V1)
      RETURN
FUNC.GE:
      VALUE = (SV.V2 >= SV.V1)
      RETURN
FUNC.MATCH:
      VALUE = (SV.V2 MATCHES SV.V1)
      RETURN


*
* LOGICAL FUNCTIONS
*
FUNC.LOGICAL:
      IF ITEM = 16 THEN
         GOSUB POP
      END ELSE
         GOSUB POP.2
      END
      FUNC.NUMBER = ITEM - 15
      ON FUNC.NUMBER GOSUB FUNC.NOT, FUNC.AND, FUNC.OR
      GOSUB PUSH
      RETURN
*
FUNC.NOT:
      VALUE = NOT(VALUE)
      RETURN
FUNC.AND:
      VALUE = (V1 AND V2)
      RETURN
FUNC.OR:
      VALUE = (V1 OR V2)
      RETURN


*
*
* FUNCTIONS
*
FUNC.FUNCTIONS:
* DOES NOTHING YET
RETURN



*
*
* IF THEN ELSE
*
FUNC.IF:
GOSUB POP
FALSE.VALUE = VALUE
GOSUB POP
TRUE.VALUE = VALUE
GOSUB POP
CHECK.VALUE = VALUE
IF CHECK.VALUE THEN
  VALUE = TRUE.VALUE
END ELSE
  VALUE = FALSE.VALUE
END
GOSUB PUSH
RETURN



*
* POP
*
POP:
      IF STACK.PTR > 0 THEN
         VALUE = STACK(STACK.PTR)
         STACK.PTR -= 1
      END ELSE
*         CRT 'STACK UNDERFLOW ON "':ORIG.OPS(ITEM):'"'
         RETURN.STATUS = 1
         RETURN
      END
      RETURN
*
* PUSH
*
PUSH:
      IF STACK.PTR < MAX.STACK THEN
         STACK.PTR += 1
         STACK(STACK.PTR) = VALUE
      END ELSE
*         CRT 'STACK OVERFLOW ON "':ORIG.OPS(ITEM):'"'
         RETURN.STATUS = 2
         RETURN
      END
      RETURN

*
*
* POP.2
*
POP.2:
      GOSUB POP
      V1 = VALUE
      GOSUB POP
      V2 = VALUE
      RETURN

*
*
* GET RETURN VALUE
*
GET.VALUE:
      IF STACK.PTR # 1 THEN
*         CRT 'ERROR IN STACK: ':STACK.PTR:'  STACK FOLLOWS'
*         FOR J=STACK.PTR TO 1 STEP -1
*            CRT '   ITEM ':J:':  ':STACK(J)
*         NEXT J
         RETURN.STATUS = 3
      END ELSE
         RETURN.VALUE = STACK(STACK.PTR)
      END
      RETURN

   END
