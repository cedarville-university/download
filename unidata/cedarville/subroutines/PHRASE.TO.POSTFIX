      SUBROUTINE PHRASE.TO.POSTFIX(POSTFIX.STRING,PHRASE.STRING,PHRASE.QUOTED,F.FILE,F.DICT,RETURN.STATUS)
*
* INFO/BASIC SUBROUTINE
* 7/26/88
* DWS
* TITLE ----- PHRASE.TO.POSTFIX
*
*
* MODULE : EVALUATE.PHRASE
* PURPOSE: CONVERTS AN WITH PHRASE STRING TO POSTFIX NOTATION
*
* Stamped: pty/ttyp8 sjoquist, /disk1/collive, user #12854, 24 Jun 94, 08:37PM.
* Updated for HP-UX
*     Last updated by LIVE (SJOQUIST) at 15:14:10 on 08/04/1988.
* HANDLE CONV CODES (EG.  WITH TR.DATE >= '5/15/87')
*     Last updated by LIVE (SJOQUIST) at 09:16:47 on 07/27/1988.
*
*************************************************************************
*

$INSERT I_OPERATORS.COMMON
$INSERT I_EVALUATE.PHRASE.COMMON
*
*
* MAIN CONTROL
*

      GOSUB SET.UP
      GOSUB CONVERT.WITH.TO.INFIX
      GOSUB PROCESS.STRING
      IF NOT(RETURN.STATUS) THEN
         GOSUB VERIFY.POSTFIX
      END
      RETURN


*
*
* SET UP
*
SET.UP:
      RETURN.STATUS = 0
      PROMPT ''
      DIM OPSTK(999)
      LAST.CONV.CODE = ''
      LAST.SYMBOL.TYPE = ''
      LAST.OP.VALUE = 0
      RETURN



*
*
* WITH PHRASE TO INFIX NOTATION
*
CONVERT.WITH.TO.INFIX:
      INFIX.STRING = PHRASE.STRING
      INFIX.QUOTED = PHRASE.QUOTED
      FOUND.WITH = @FALSE
      WITH.POS = 0
      DONE.WITH = @FALSE
      LOOP
         LOCATE 'WITH' IN INFIX.STRING<WITH.POS+1> SETTING WITH.POS ELSE
            DONE.WITH = @TRUE
         END
      UNTIL DONE.WITH
*
* THE QUOTED FLAGS ESTABLISHED IN 'PARSE.OPERATORS' NEED TO BE
*   ADJUSTED WHENEVER INFIX.STRING IS CHANGED
*  (ADDITIONAL FIELDS ARE INSERTED INTO INFIX.STRING, SO ADDITONAL FLAGS NEED TO
*     BE INSERTED INTO INFIX.QUOTED)
*
         IF NOT(INFIX.QUOTED<WITH.POS>) THEN
            IF NOT(FOUND.WITH) THEN
               INFIX.STRING<WITH.POS> = '('
            END ELSE
               PREV.WORD = INFIX.STRING<WITH.POS-1>
               PREV.QUOTED = INFIX.QUOTED<WITH.POS-1>
               IF NOT(PREV.QUOTED) THEN
                  IF PREV.WORD = 'OR' OR PREV.WORD = 'AND' THEN
                     INFIX.STRING<WITH.POS-1> = ')':@TM:PREV.WORD
                     INFIX.QUOTED<WITH.POS-1> = @TM
                     INFIX.STRING<WITH.POS> = '('
                  END ELSE
                     INFIX.STRING<WITH.POS> = ')':@TM:'AND':@TM:'('
                     INFIX.QUOTED<WITH.POS> = @TM:@TM
                  END
               END
            END
            FOUND.WITH = @TRUE
         END
      REPEAT
      IF FOUND.WITH THEN
         INFIX.STRING := @TM:')'
         INFIX.QUOTED := @TM
         CONVERT @TM TO @FM IN INFIX.STRING
         CONVERT @TM TO @FM IN INFIX.QUOTED
      END
      RETURN


*
*
* CONVERT PHRASE TO POSTFIX
*
PROCESS.STRING:
      NOPSTK = 0
      CHECK.FOR.UNARY.OP = @TRUE
      NUM.SYMBOLS = 0
      POSTFIX.STRING = ''
      LOOP
         REMOVE ITEM FROM INFIX.STRING SETTING DELIM
         REMOVE ITEM.QUOTED FROM INFIX.QUOTED SETTING JUNK
         NUM.SYMBOLS += 1
*
* SPECIAL CASES (UNARY -/+, WITH)
*
         IF CHECK.FOR.UNARY.OP THEN
            IF (ITEM = '-' OR ITEM = '+') AND NOT(ITEM.QUOTED) THEN
               ITEM = 'U':ITEM
            END
         END
         CHECK.FOR.UNARY.OP = @FALSE
*
         IF ITEM.QUOTED THEN
            GOSUB PROCESS.LITERAL
         END ELSE
            LOCATE ITEM IN OPS.LIST<1> BY 'AL' SETTING OP.POS THEN
               GOSUB PROCESS.SYMBOL
            END ELSE
               GOSUB PROCESS.FIELD.OR.LITERAL
            END
         END
      UNTIL DELIM = 0
      REPEAT
      FOR OPSTK.CTR=NOPSTK TO 1 STEP -1
         POSTFIX.STRING := @FM:'O':@VM:OP.VALUE(OPSTK(OPSTK.CTR))
      NEXT OPSTK.CTR
      POSTFIX.STRING = POSTFIX.STRING[2,32000]
      RETURN


*
*
* PROCESS ITEM
*
PROCESS.SYMBOL:
      LAST.OP.VALUE = OP.VALUE(OP.POS)
      LOOP
         FIRST.OP.HIGHER = @FALSE
         IF NOPSTK > 0 THEN
            OP.POS1 = OPSTK(NOPSTK)
            OP.POS2 = OP.POS
            GOSUB CHECK.OP.PREC
         END
      UNTIL NOT(NOPSTK > 0 AND FIRST.OP.HIGHER)
         OPERATOR.VALUE = OP.VALUE(OPSTK(NOPSTK))
         POSTFIX.STRING := @FM:'O':@VM:OPERATOR.VALUE
         NOPSTK -= 1
      REPEAT
*  (ASSUMES BALANCED PAREN'S HAVE BEEN ENTERED)
*   REMOVES LEFT PAREN WHEN RIGHT ONE IS FOUND
      IF ITEM # ')' THEN
         NOPSTK += 1
         OPSTK(NOPSTK) = OP.POS
      END ELSE
         NOPSTK -= 1
      END
      IF ITEM # ')' THEN
         CHECK.FOR.UNARY.OP = @TRUE
      END
      LAST.SYMBOL.TYPE = 'O'
      RETURN

CHECK.OP.PREC:
      IF OPS.LIST<OP.POS1> = '(' OR OPS.LIST<OP.POS2> = '(' THEN
         FIRST.OP.HIGHER = @FALSE
      END ELSE
         FIRST.OP.HIGHER = (OP.PREC(OP.POS1) < OP.PREC(OP.POS2))
      END
      RETURN



*
*
* DETERMINE IF ITEM IS A FIELD OR A LITERAL
*
PROCESS.FIELD.OR.LITERAL:
      LOCATE ITEM IN EP.FIELD.NAME.LIST<1> SETTING FIELD.POS THEN
         IS.VALID.FIELD = @TRUE
      END ELSE
         GOSUB LOAD.DICT.REC
      END
      IF IS.VALID.FIELD THEN
         GOSUB PROCESS.FIELD
      END ELSE
         GOSUB PROCESS.LITERAL
      END
      RETURN


*
*
* PROCESS FIELD
*
PROCESS.FIELD:
      POSTFIX.STRING := @FM:'F':@VM:FIELD.POS
      LAST.CONV.CODE = EP.DICT.REC(FIELD.POS)<3>
      LAST.SYMBOL.TYPE = 'F'
      RETURN


*
*
* PROCESS LITERAL
*
PROCESS.LITERAL:
      IF LAST.CONV.CODE AND NOT(OP.CANCEL.CONV(LAST.OP.VALUE)) THEN
         LITERAL.VALUE = ICONV(ITEM,LAST.CONV.CODE)
      END ELSE
         LITERAL.VALUE = ITEM
      END
*
*  ALLOW MULTIPLE LITERALS IN A ROW FOLLOWING AN COMPARISON OPERATION
*    (OP.TYPE = 3)
*   (EG.  WITH MAJOR = 'BUSAD''EDUC' ...)
* STORE AS SUCCESSIVE VALUES
*
      IF LAST.SYMBOL.TYPE = 'L' AND OP.TYPE(LAST.OP.VALUE) = '3' THEN
         POSTFIX.STRING := @VM:LITERAL.VALUE
      END ELSE
         POSTFIX.STRING := @FM:'':@VM:LITERAL.VALUE
      END
      LAST.SYMBOL.TYPE = 'L'
      RETURN


*
*
* LOAD DICT REC FOR A FIELD
*
LOAD.DICT.REC:
      IS.VALID.FIELD = @FALSE
      READ DICT.REC FROM F.DICT, ITEM THEN
         DICT.TYPE = DICT.REC<1>[1,1]
         IF DICT.TYPE = 'I' OR DICT.TYPE = 'D' THEN
            IS.VALID.FIELD = @TRUE
            IF NUM.EP.FLDS = MAX.EP THEN
               RETURN.STATUS = 101      ;* OUT OF ROOM
            END ELSE
               NUM.EP.FLDS += 1
               EP.DICT.REC(NUM.EP.FLDS) = DICT.REC
               FIELD.POS = NUM.EP.FLDS
               EP.FIELD.NAME.LIST<FIELD.POS> = ITEM
            END
         END
      END
      RETURN



*
*
* VERIFY POSTFIX STRING
*
VERIFY.POSTFIX:
      RESULT = ''
      CALL EVALUATE.POSTFIX(RESULT,POSTFIX.STRING,RETURN.STATUS)
      RETURN


   END
